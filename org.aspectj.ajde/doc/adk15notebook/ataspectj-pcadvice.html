<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Pointcuts and Advice</title><meta name="generator" content="DocBook XSL Stylesheets V1.44"><link rel="home" href="index.html" title="The AspectJTM 5 Development Kit Developer's Notebook"><link rel="up" href="ataspectj.html" title="Chapter 9. An Annotation Based Development Style"><link rel="previous" href="ataspectj-aspects.html" title="Aspect Declarations"><link rel="next" href="ataspectj-itds.html" title="Inter-type Declarations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Pointcuts and Advice</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ataspectj-aspects.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter 9. An Annotation Based Development Style</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ataspectj-itds.html">Next</a></td></tr></table><hr></div><div class="sect1"><a name="ataspectj-pcadvice"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ataspectj-pcadvice"></a>Pointcuts and Advice</h2></div></div><p>
          Pointcut and advice declarations can be made using the 
          <tt>Pointcut, Before, After, AfterReturning, AfterThrowing,</tt>
          and <tt>Around</tt> annotations.                    
      </p><div class="sect2"><a name="d0e2244"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2244"></a>Pointcuts</h3></div></div><p>
              Pointcuts are specified using the 
              <tt>org.aspectj.lang.annotation.Pointcut</tt> annotation
              on a method declaration. The method should have a <tt>void</tt>
              return type. The parameters of the method correspond to the parameters
              of the pointcut. The modifiers of the method correspond to the modifiers
              of the pointcut. The method body should be empty and there should be no
              throws clause.
          </p><p>A simple example:</p><pre class="programlisting">     
     @Pointcut("call(* *.*(..))")
     void anyCall() {}
     
     is equivalent to...
     
     pointcut anyCall() : call(* *.*(..));
      </pre><p>An example with modifiers:</p><pre class="programlisting">
     @Pointcut("")
     protected abstract void anyCall();
     
     is equivalent to...
     
     protected abstract pointcut anyCall();
      </pre><p>
          Using the code style, types referenced in pointcut expressions are 
          resolved with respect to the imported types in the compilation unit.
          When using the annotation style, types referenced in pointcut 
          expressions are resolved in the absence of any imports and so have
          to be fully qualified if they are not by default visible to the
          declaring type (outside of the declaring package and java.lang). This
          to not apply to type patterns with wildcards, which are always resolved
          in a global scope.            
          </p><p>
          Consider the following compilation unit:
          </p><pre class="programlisting">
     package org.aspectprogrammer.examples;
     
     import java.util.List;
     
     public aspect Foo {
     
       pointcut listOperation() : call(* List.*(..));
      
       pointcut anyUtilityCall() : call(* java.util..*(..));
           
     }
      </pre><p>
      Using the annotation style this would be written as:      
      </p><pre class="programlisting">
     package org.aspectprogrammer.examples;
     
     import java.util.List; // redundant but harmless
     
     @Aspect
     public class Foo {
     
       @Pointcut("call(* java.util.List.*(..))") // must qualify
       void listOperation() {}
      
       @Pointcut("call(* java.util..*(..))")
       void anyUtilityCall() {}
           
     }
      </pre><p>The <tt>value</tt> attribute of the 
      <tt>Pointcut</tt> declaration may contain any valid
      AspectJ pointcut declaration.</p></div><div class="sect2"><a name="d0e2281"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2281"></a>Advice</h3></div></div><p>In this section we first discuss the use of annotations for 
          simple advice declarations. Then we show how <tt>thisJoinPoint</tt>
          and its siblings are handled in the body of advice and discuss the 
          treatment of <tt>proceed</tt> in around advice.</p><p>Using the annotation style, an advice declaration is written as
          a regular Java method with one of the <tt>Before, After, AfterReturning,
          AfterThrowing,</tt> or <tt>Around</tt> annotations. Except in
          the case of around advice, the method should return void. The method should 
          be declared public.</p><p>A method that has an advice annotation is treated exactly as an
          advice declaration by AspectJ's weaver. This includes the join points that
          arise when the advice is executed (an adviceexecution join point, not a 
          method execution join point), and the restriction that advice cannot be
          invoked explicitly (the weaver will issue an error if an advice method
          is explicitly invoked).</p><p>The following example shows a simple before advice declaration in
          both styles:</p><pre class="programlisting">
     before() : call(* org.aspectprogrammer..*(..)) &amp;&amp; this(Foo) {
       System.out.println("Call from Foo");
     }
     
     is equivalent to...
     
     @Before("call(* org.aspectprogrammer..*(..)) &amp;&amp; this(Foo)")
     public void callFromFoo() {
       System.out.println("Call from Foo");
     }
      </pre><p>Notice one slight difference between the two advice declarations: in
          the annotation style, the advice has a name, "callFromFoo". Even though
          advice cannot be invoked explicitly, this name is useful in join point
          matching when advising advice execution. For this reason, and to preserve
          exact semantic equivalence between the two styles, we also support the
          <tt>org.aspectj.lang.annotation.AdviceName</tt> annotation.
          The exact equivalent declarations are:</p><pre class="programlisting">
     @AdviceName("callFromFoo")
     before() : call(* org.aspectprogrammer..*(..)) &amp;&amp; this(Foo) {
       System.out.println("Call from Foo");
     }
     
     is equivalent to...
     
     @Before("call(* org.aspectprogrammer..*(..)) &amp;&amp; this(Foo)")
     public void callFromFoo() {
       System.out.println("Call from Foo");
     }
      </pre><p>If the advice body needs to know which particular <tt>Foo</tt>
          was doing the calling, just add a parameter to the advice declaration.</p><pre class="programlisting">
     @AdviceName("callFromFoo")
     before(Foo foo) : call(* org.aspectprogrammer..*(..)) &amp;&amp; this(foo) {
       System.out.println("Call from Foo: " + foo);
     }
     
     is equivalent to...
     
     @Before("call(* org.aspectprogrammer..*(..)) &amp;&amp; this(foo)")
     public void callFromFoo(Foo foo) {
       System.out.println("Call from Foo: " + foo);
     }
      </pre><p>If the advice body needs access to <tt>thisJoinPoint</tt>,
          <tt>thisJoinPointStaticPart</tt>, 
          <tt>thisEnclosingJoinPointStaticPart</tt> then these need to 
          be declared as additional method parameters when using the annotation
          style. In AspectJ 1.5.0 we require that these parameters be declared
          first in the parameter list, in later releases we may relax this
          requirement.</p><pre class="programlisting">
     @AdviceName("callFromFoo")
     before(Foo foo) : call(* org.aspectprogrammer..*(..)) &amp;&amp; this(foo) {
       System.out.println("Call from Foo: " + foo + " at " 
                          + thisJoinPoint);
     }
     
     is equivalent to...
     
     @Before("call(* org.aspectprogrammer..*(..)) &amp;&amp; this(foo)")
     public void callFromFoo(JoinPoint thisJoinPoint, Foo foo) {
       System.out.println("Call from Foo: " + foo + " at " 
                          + thisJoinPoint);
     }
      </pre><p>Advice that needs all three variables would be declared:</p><pre class="programlisting">
     @Before("call(* org.aspectprogrammer..*(..)) &amp;&amp; this(Foo)")
     public void callFromFoo(JoinPoint thisJoinPoint, 
                             JoinPoint.StaticPart thisJoinPointStaticPart,
                             JoinPoint.EnclosingStaticPart thisEnclosingJoinPointStaticPart) {
         // ...                             
     }
      </pre><p>
          <tt>JoinPoint.EnclosingStaticPart</tt> is a new (empty) sub-interface
          of <tt>JoinPoint.StaticPart</tt> which allows the AspectJ weaver to 
          distinguish based on type which of <tt>thisJoinPointStaticPart</tt> and
          <tt>thisEnclosingJoinPointStaticPart</tt> should be passed in a given
          parameter position.
      </p><p><tt>After</tt> advice declarations take exactly the same form
      as <tt>Before</tt>, as do the forms of <tt>AfterReturning</tt>
      and <tt>AfterThrowing</tt> that do not expose the return type or
      thrown exception respectively.</p><p>
      To expose a return value with after returning advice simply declare the returning
      parameter as a parameter in the method body and bind it with the "returning"
      attribute:
      </p><pre class="programlisting">      
      after() returning : criticalOperation() {
        System.out.println("phew");
      }
      
      after() returning(Foo f) : call(Foo+.new(..)) {
        System.out.println("It's a Foo: " + f);
      }
      
      can be written as...
      
      @AfterReturning("criticalOperation()")
      public void phew() {
        System.out.println("phew");
      }
      
      @AfterReturning(value="call(Foo+.new(..))",returning="f")
      public void itsAFoo(Foo f) {
        System.out.println("It's a Foo: " + f);
      }            
      </pre><p>(Note the need for the "value=" prefix in front of the pointcut
      expression in the returning case).</p><p>After throwing advice works in a similar fashion, using the 
      <tt>throwing</tt> attribute when needing to expose a 
      thrown exception.</p><p>For around advice, we have to tackle the problem of <tt>proceed</tt>.
      One of the design goals for the annotation style is that a large class of
      AspectJ applications should be compilable with a standard Java 5 compiler.
      A straight call to <tt>proceed</tt> inside a method body:</p><pre class="programlisting">
     @Around("call(* org.aspectprogrammer..*(..))")
     public Object doNothing() {
       return proceed(); // CE on this line                            
     }
      </pre><p>will result in a "No such method" compilation error. For this 
      reason AspectJ 5 defines a new sub-interface of <tt>JoinPoint</tt>, 
      <tt>ProceedingJoinPoint</tt>. </p><pre class="programlisting">
     public interface ProceedingJoinPoint extends JoinPoint {
       public Object proceed(Object... args);
     }
      </pre><p>The around advice given above can now be written as:</p><pre class="programlisting">
     @Around("call(* org.aspectprogrammer..*(..))")
     public Object doNothing(ProceedingJoinPoint thisJoinPoint) {
       return thisJoinPoint.proceed();                             
     }
      </pre><p>Here's an example that uses parameters for the proceed call:</p><pre class="programlisting">
     public aspect ProceedAspect {
       pointcut setAge(int i): call(* setAge(..)) &amp;&amp; args(i);
    
       Object around(int i): setAge(i) {
         return proceed(i*2);
       }
     }
     
     can be written as...
     
     @Aspect
     public class ProceedAspect {
     
       @Pointcut("call(* setAge(..)) &amp;&amp; args(i)")
       void setAge(int i) {}
     
       @Around("setAge(i)")
       public Object twiceAsOld(ProceedingJoinPoint thisJoinPoint, int i) {
         return thisJoinPoint.proceed(i*2);
       }
     
     }          
      </pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ataspectj-aspects.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ataspectj-itds.html">Next</a></td></tr><tr><td width="40%" align="left">Aspect Declarations&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ataspectj.html">Up</a></td><td width="40%" align="right">&nbsp;Inter-type Declarations</td></tr></table></div></body></html>