<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Generics in AspectJ 5</title><link rel="stylesheet" href="aspectj-docs.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.44"><link rel="home" href="index.html" title="The AspectJTM 5 Development Kit Developer's Notebook"><link rel="up" href="generics.html" title="Chapter 3. Generics"><link rel="previous" href="generics.html" title="Chapter 3. Generics"><link rel="next" href="autoboxing.html" title="Chapter 4. Autoboxing and Unboxing"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Generics in AspectJ 5</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="generics.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter 3. Generics</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="autoboxing.html">Next</a></td></tr></table><hr></div><div class="sect1"><a name="generics-inAspectJ5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="generics-inAspectJ5"></a>Generics in AspectJ 5</h2></div></div><p>
        AspectJ 5 provides full support for all of the Java 5 language features, including generics. Any legal Java 5 program is a 
        legal AspectJ 5 progam. In addition, AspectJ 5 provides support for generic and parameterized types in pointcuts, inter-type
        declarations, and declare statements.  Parameterized types may freely be used within aspect members, and support is 
        also provided for generic <span class="emphasis"><i>abstract</i></span> aspects.
      </p><div class="sect2"><a name="d0e2095"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2095"></a>Matching generic and parameterized types in type patterns</h3></div></div><p>
        The foundation of AspectJ's support for generic and parameterized types in aspect declarations is the extension of type
        pattern matching to allow matching against generic and parameterized types.
      </p><p>
           The type pattern <tt>"Foo"</tt> matches all types named <tt>Foo</tt>, whether they
           be simple types, generic types, or parameterized types. So for example, <tt>Foo</tt>, 
           <tt>Foo&lt;T&gt;</tt>, and <tt>Foo&lt;String&gt;</tt>will all be matched. 
      </p><p>
          AspectJ 5 also extends the specification of type patterns to allow explicit matching of generic and parameterized
          types by including one or more type parameter patterns inside angle braces (<tt>&lt; &gt;</tt>) immediately
          after the type pattern. For example, <tt>List&lt;String&gt;</tt>
      </p><pre class="programlisting">
  	  	TypePattern := SimpleTypePattern |
  	  	               '!' TypePattern |
  	  	               '(' AnnotationPattern? TypePattern ')'
  	  	               TypePattern '&amp;&amp;' TypePattern |
  	  	               TypePattern '||' TypePattern |
  	  	               TypePattern '&lt;' TypeParameterPatternList '&gt;'
  	  	               
  	  	TypeParameterPatternList ::= TypeParameterPattern (',' TypeParameterPattern)*
  	  	
  	  	TypeParameterPattern ::= TypePattern |
  	  	                                    '?' TypeBoundPattern?
  	  	                                    
  	  	TypeBoundPattern ::= 'extends' TypePattern AdditionalBoundPatternList? |
  	  	                               'super' TypePattern AdditionalBoundPatternList?
  	  	                     
  	  	AdditionalBoundPatternList ::= AdditionalBoundPattern AdditionalBoundPatternList |
  	  	                                         AdditionalBoundPattern
  	  	                               
  	  	AdditionalBoundPattern ::= '&amp;' TypePattern 
  	  	
		</pre><p>
  	  	    A simple identifier (such as <tt>String</tt>) occuring in a type parameter list will be treated as a type name unless
  	  	    a type variable of that name is in scope (declaring type variables is covered later). The type pattern <tt>List&lt;E&gt;</tt>
  	  	    will result in an "invalid absolute type name" warning if no type <tt>E</tt> is in scope (declared in the default package, or
  	  	    imported in the compilation unit) and no declaration of <tt>E</tt> as a type variable is in scope either. 
  	  	</p><p>Some simple examples of type patterns follow:</p><div class="variablelist"><dl><dt><a name="d0e2144"></a><span class="term">List&lt;String&gt;</span></dt><dd><p><a name="d0e2147"></a>Matches the parameterized type <tt>List&lt;String&gt;</tt>
            </p></dd><dt><a name="d0e2153"></a><span class="term">List&lt;? extends Number&gt;</span></dt><dd><p><a name="d0e2156"></a>Matches the parameterized type <tt>List&lt;? extends Number&gt;</tt>
            </p></dd><dt><a name="d0e2162"></a><span class="term">List&lt;E&gt;</span></dt><dd><p><a name="d0e2165"></a>Outside of a scope in which <tt>E</tt>is defined as a type variable, this pattern matches the 
            parameterized type <tt>List&lt;E&gt;</tt>. If <tt>E</tt> is not
            a type then an <tt>invalidAbsoluteTypeName</tt> xlint warning will be issued. 
            </p><p>In a scope in which
            <tt>E</tt> is defined as a type variable, this pattern matches the generic type <tt>List&lt;E&gt;</tt>.
            The type parameter name does not have to match the name used in the declaration of <tt>List</tt>, 
            but the bounds must match. This pattern <span class="emphasis"><i>also</i></span> matches any parameterization of <tt>List</tt> 
            that satisfies the bounds of the type variable (for example, <tt>List&lt;String&gt;</tt>).
            </p></dd></dl></div><p>
  	    The <tt>*</tt>, <tt>+</tt>, and <tt>..</tt> wildcards may be used in type patterns
  	    matching against generic and parameterized types (just as in any other type pattern). The <tt>+</tt>
  	    wildcard matches all subtypes. Recalling the discussion on subtypes and supertypes in the previous section, note
  	    that the pattern <tt>List&lt;Number&gt;+</tt> will match <tt>List&lt;Number&gt;</tt> and
  	    <tt>LinkedList&lt;Number&gt;</tt>, but not <tt>List&lt;Double&gt;</tt>. To match lists of
  	    any number type use the pattern <tt>List&lt;Number+&gt;</tt> which will match 
  	    <tt>List&lt;Number&gt;</tt>, <tt>List&lt;Double&gt;</tt>, <tt>List&lt;Float&gt;</tt>
  	    and so on.  
  	  </p><p>
  	      The generics wildcard <tt>?</tt> is considered part of the signature of a parameterized type, and
  	      is <span class="emphasis"><i>not</i></span> used as an AspectJ wildcard in type matching. For example:
  	  </p><div class="variablelist"><dl><dt><a name="d0e2247"></a><span class="term">List&lt;*&gt;</span></dt><dd><p><a name="d0e2250"></a>Matches any generic or parameterized <tt>List</tt>type (<tt>List&lt;String&gt;</tt>,
              <tt>List&lt;Integer&gt;</tt> and so on) with a single type parameter.
            </p></dd><dt><a name="d0e2262"></a><span class="term">List&lt;?&gt;</span></dt><dd><p><a name="d0e2265"></a>Matches the parameterized type <tt>List&lt;?&gt;</tt> (and does 
              <span class="emphasis"><i>not</i></span> match <tt>List&lt;String&gt;</tt>,
              <tt>List&lt;Integer&gt;</tt> and so on)
            </p></dd><dt><a name="d0e2280"></a><span class="term">List&lt;? extends Number+&gt;</span></dt><dd><p><a name="d0e2283"></a>Matches <tt>List&lt;? extends Number&gt;</tt>, <tt>List&lt;? extends Double&gt;</tt>,
              and so on, but does not match <tt>List&lt;Double&gt;</tt>.
            </p></dd></dl></div></div><div class="sect2"><a name="d0e2295"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2295"></a>Signature patterns</h3></div></div><p>
              Now that we understand how to write type patterns that match generic and parameterized types, it is time to look at
              how these can be utilized to match member declarations by using signature patterns.
           </p><p>To match members declared in generic types and making use of type variables defined in those types (for
          example <tt>interface  Foo&lt;T&gt; { public T doSomething(); }</tt> use a signature pattern of the form:</p><pre class="programlisting">
      	X Foo&lt;X&gt;.doSomething()
		</pre><p>
            This assumes a scope in which <tt>X</tt> is declared as a type variable. As with type patterns, the name
            of the type variable does not have to match the name used in the member declaration, but the bounds must match.
            For example, if the interface was declared as <tt>Foo&lt;T extends Number&gt;</tt> then the signature 
            pattern would be: <tt>X Foo&lt;X extends Number&gt;.doSomething()</tt>.
          </p><div class="variablelist"><dl><dt><a name="d0e2319"></a><span class="term">T Util&lt;T extends Number,S&gt;.someFunction(List&lt;S&gt;)</span></dt><dd><p><a name="d0e2322"></a>Matches the method <tt>someFunction</tt> in a generic type <tt>Util</tt> with
            two type parameters, the first type parameter having an upper bound of <tt>Number</tt>.
            </p></dd><dt><a name="d0e2334"></a><span class="term">LinkedList&lt;E&gt;.new()</span></dt><dd><p><a name="d0e2337"></a>Matches the no-argument constructor of the generic type <tt>LinkedList</tt>. 
            </p></dd></dl></div><p>
            Matching a field with a generic type works in the same way. For example:
          </p><pre class="programlisting">
      	T *&lt;T&gt;.*
		</pre><p>Matches a field of the type of type parameter <tt>T</tt> in any generic type with a single
            unbounded type parameter (the pattern<tt>*&lt;T&gt;</tt>). The field may be of any name.
            </p><p>Matching of members of parameterized types is straightforward. For example, 
          <tt>void List&lt;String&gt;.add(String)</tt> matches the add method in the 
          parameterized type <tt>List&lt;String&gt;</tt>.     
     </p><p>
            To match a generic <span class="emphasis"><i>method</i></span> the generic method type variable
            declarations become part of the signature pattern. For example:          
          </p><pre class="programlisting">
          &lt;T&gt; List&lt;T&gt; *.favourites(List&lt;T&gt;)
		</pre><p>matches a generic method <tt>favourites</tt> declared in any type. To match a 
		static generic method simply include the <tt>static</tt> modifier in the type pattern.</p></div><div class="sect2"><a name="d0e2378"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2378"></a>Pointcuts</h3></div></div><p>
            In this section we discuss how type patterns and signature patterns matching on generic and 
            parameterized types, methods, and constructors can be used in pointcut expressions.  
            We distinguish between pointcuts that match based on static type information, and pointcuts 
            that match based on runtime type information (<tt>this, target, args</tt>).
        </p><p>
            First however we need to address the notion of type variables and scopes. There is a 
            convention in Java, but no requirement, that type variables are named with a single letter. 
            Likewise it is rare, but perfectly legal, to declare a type with a single character name. Given the
            type pattern <tt>List&lt;Strng&gt;</tt>, is this a mis-spelling of the 
            parameterized type pattern <tt>List&lt;String&gt;</tt> or is it a generic type pattern
            with one unbounded type variable <tt>Strng</tt>?. Alternatively, given the
            type pattern <tt>List&lt;E&gt;</tt>, if  the type <tt>E</tt> cannot be found,
            is this a missing import statement or an implied type variable? There is no way for AspectJ
            to disambiguate in these situations without an explicit declaration of type variable names. If 
            <tt>E</tt> is defined as a type variable, and <tt>Strng</tt> is not, then both
            declarations can be correctly interpreted.
         </p><div class="sect3"><a name="d0e2409"></a><div class="titlepage"><div><h4 class="title"><a name="d0e2409"></a>Type Variables in Pointcut Expressions</h4></div></div><p>The type variables in scope for a pointcut primitive are declared in a type variable
         list immediately following the pointcut desginator keyword. For example:</p><pre class="programlisting">
          call&lt;T&gt;(* Foo&lt;T&gt;.*(T))
		</pre><p>matches a call to a method with any name (<tt>*</tt>) declared 
        by a generic type <tt>Foo</tt> with one unbounded type parameter. The method
        takes one argument which is of the type of the type variable.</p><p>In contrast, the pointcut</p><pre class="programlisting">
          call(* Foo&lt;T&gt;.*(T))
		</pre><p>matches a call to a method with any name that takes an argument of
        type <tt>T</tt>, where the target of the call is declared as the parameterized
        type <tt>Foo&lt;T&gt;</tt>. If there is no type <tt>T</tt> in scope, an 
        "invalid absolute type name (T)" warning will be issued.</p><p>
            The type variables declaration following a pointcut designator permits only simple identifiers 
            (e.g. <tt>&lt;S,T&gt;</tt> and not <tt>&lt;S extends Number&gt;</tt>).
        </p><p>A type variable declaration list can appear following any pointcut designator except
        for <tt>handler</tt> (Java 5 does
        not permit a generic class to be a direct or indirect subtype of <tt>Throwable</tt>
         - see JLS 8.1.2), the dynamic pointcuts <tt>this, target, args, if, cflow, cflowbelow</tt>, 
         and the annotation pointcut designators 
        (<tt>@args, @this, @within</tt> and so on).</p></div><div class="sect3"><a name="d0e2461"></a><div class="titlepage"><div><h4 class="title"><a name="d0e2461"></a>Initialization and execution pointcuts</h4></div></div><p>
         Recall that there is only ever one type for a generic type (e.g. <tt>List&lt;E&gt;</tt>)
         regardless of how many different parameterizations of that type (e.g. 
         <tt>List&lt;String&gt;</tt>, <tt>List&lt;Double&gt;</tt>) are used within a
         program. For join points that occur within a type, such as execution join points, it therefore only
         makes sense to talk about execution join points for the generic type. Given the generic type 
         </p><pre class="programlisting">
        public class Foo&lt;T&gt; {
            
          T doSomething(T toSomeT) {
             return T;
          }  
          
        }
		</pre><p>
             then 
         </p><div class="variablelist"><dl><dt><a name="d0e2480"></a><span class="term">execution&lt;T&gt;(T Foo&lt;T&gt;.doSomething(..))</span></dt><dd><p><a name="d0e2483"></a>matches the execution of the <tt>doSomething</tt> method in
            <tt>Foo</tt>.
            </p></dd><dt><a name="d0e2492"></a><span class="term">execution(* Foo.doSomething(..))</span></dt><dd><p><a name="d0e2495"></a>also matches the execution of the <tt>doSomething</tt> method in
            <tt>Foo</tt>.
            </p></dd><dt><a name="d0e2504"></a><span class="term">execution(T Foo.doSomething(..))</span></dt><dd><p><a name="d0e2507"></a>results in an "invalid absolute type name (T)" warning since <tt>T</tt> is 
            interpreted as a type, not a type variable.
            </p></dd><dt><a name="d0e2513"></a><span class="term">execution(String Foo&lt;String&gt;.doSomething(..))</span></dt><dd><p><a name="d0e2516"></a>results in a compilation error "no execution join points for parameterized type
                Foo&lt;String&gt;, use a generic signature instead".
            </p></dd></dl></div><p>
          Given the type declaration
       </p><pre class="programlisting">
        public class Bar&lt;N extends Number&gt; {
            
          N doSomething(N toSomeN) {
             return N;
          }  
          
        }
		</pre><p>
             then 
         </p><div class="variablelist"><dl><dt><a name="d0e2526"></a><span class="term">execution&lt;T&gt;(T Bar&lt;T&gt;.doSomething(..))</span></dt><dd><p><a name="d0e2529"></a>does not match the execution of <tt>Bar.doSomething</tt> since
            the bounds of the type parameter <tt>T</tt> in the pointcut expression do
            not match the bounds of the type parameter <tt>N</tt> in the type declaration.
            </p></dd><dt><a name="d0e2541"></a><span class="term">execution&lt;T&gt;(T Bar&lt;T extends Number&gt;.doSomething(..))</span></dt><dd><p><a name="d0e2544"></a>matches the execution of the <tt>doSomething</tt> method in
            <tt>Bar</tt>.
            </p></dd><dt><a name="d0e2553"></a><span class="term">execution&lt;T extends Number&gt;(T Bar&lt;T&gt;.doSomething(..))</span></dt><dd><p><a name="d0e2556"></a>results in a compilation error, since type variable bounds must be specified as part
                of the declaring type pattern, and not in the type variable list.
            </p></dd></dl></div><p>
          If a type implements a <span class="emphasis"><i>parameterized</i></span> interface, then
          execution join points exist and can be matched for the parameterized interface operations within
          the implementing type. For example, given the pair of types:   
       </p><pre class="programlisting">
        public interface Greatest&lt;T&gt; {
            T greatest(List&lt;T&gt; ts);  
        }
        
        public class  NumberOperations implements Greatest&lt;Number&gt; {
             public Number greatest(List&lt;Number&gt; numbers) {
                //...
             }
        }
		</pre><p>
          then
       </p><pre class="programlisting">
        execution(* Greatest&lt;Number&gt;.*(..))
		</pre><p>
          will match the execution of the <tt>greatest</tt> method declared in 
          <tt>NumberOperations</tt>. However, it <span class="emphasis"><i>does not</i></span>
          match the execution of <tt>greatest</tt> in the program below:
       </p><pre class="programlisting">
        public interface Greatest&lt;T&gt; {
            T greatest(List&lt;T&gt; ts);  
        }
        
        public class  NumberOperations&lt;N extends Number&gt; implements Greatest&lt;N&gt; {
             public N greatest(List&lt;N&gt; numbers) {
                //...
             }
        }
        
        // in some fragment of code...
        NumberOperations&lt;Number&gt; numOps = new NumberOperations&lt;Number&gt;();
        numOps.greatest(numList);
		</pre><p>Since there is only one generic type, <tt>NumberOperations</tt>,
        which implements a generic interface. Either of the pointcut expressions
        <tt>execution&lt;T&gt;(* Greatest&lt;T&gt;&gt;.*(..))</tt> or 
        <tt>execution&lt;T&gt;(* Greatest&lt;T extends Number&gt;&gt;.*(..))</tt> will
        match the execution of <tt>greatest</tt> in this example.  Recall from 
        chapter <a href="jpsigs.html">Join Point Signatures</a> that a kinded pointcut primitive matches a join point if
        it exactly matches one of the signatures of the join point. The signatures of the
        execution join point for <tt>greatest</tt> in the example above are:</p><div class="variablelist"><dl><dt><a name="d0e2606"></a><span class="term">public N Greatest&lt;N&gt;.greatest(List&lt;N&gt;)</span></dt><dd><p><a name="d0e2609"></a>from the declaration in the <tt>Greatest</tt> interface, and
            </p></dd><dt><a name="d0e2615"></a><span class="term">public N Greatest&lt;N extends Number&gt;.greatest(List&lt;N&gt;)</span></dt><dd><p><a name="d0e2618"></a>from the additional bounds restriction of <tt>N</tt> in the
            declaration of <tt>NumberOperations</tt>
            </p></dd></dl></div><p>
        Join points for <tt>staticinitialization</tt>,<tt>initialization</tt> and 
        <tt>preinitialization</tt> 
        only ever exist on a generic type (an interface cannot define a constructor). The expression
        <tt>initialization&lt;T&gt;(Foo&lt;T&gt;.new(..))</tt> which match any initialization 
        join point for the generic type <tt>Foo&lt;T&gt;</tt>, and 
        <tt>staticinitialization&lt;T&gt;(Foo&lt;T&gt;)</tt> matches the static initialization 
        of that same type. 
     </p><p>
         The expression <tt>staticinitialization(List&lt;String&gt;)</tt> will result in a 
         compilation error: there is no static initialization join point for the parameterized type
         <tt>List&lt;String&gt;</tt>. However, the expression 
         <tt>staticinitialization(List&lt;String&gt;+)</tt> <span class="emphasis"><i>is</i></span>
         legal, and will match the static initialization of any type that 
         <tt>implements List&lt;String&gt;</tt>.  The expression
         <tt>staticinitialization&lt;T&gt;(List&lt;T&gt;+)</tt> will match the static
         initialization join point of any type that either extends or implements the generic
         type <tt>List&lt;T&gt;</tt> or implements any parameterization of that
         interface. 
      </p></div><div class="sect3"><a name="d0e2670"></a><div class="titlepage"><div><h4 class="title"><a name="d0e2670"></a>Static scoping: within and withincode</h4></div></div><p>The <tt>within</tt> and <tt>withincode</tt> 
         pointcut designators both match the
         execution of join points that occur within a type or a member of a type respectively. Therefore
         the same considerations with respect to there only being <tt>one</tt> type for
         a generic type regardless of how many parameterizations of that type are used in a program 
         apply.
         </p><p>The <tt>within</tt> pointcut designator can never be used in conjunction
         with a simple parameterized type. So
         </p><div class="variablelist"><dl><dt><a name="d0e2690"></a><span class="term">within&lt;T&gt;(Foo&lt;T&gt;)</span></dt><dd><p><a name="d0e2693"></a>matches all join points occurring within the generic type <tt>Foo&lt;T&gt;</tt>,
            and
            </p></dd><dt><a name="d0e2699"></a><span class="term">within(Foo&lt;String&gt;)</span></dt><dd><p><a name="d0e2702"></a>results in a compilation error since there is no concept of a join point within a 
            parameterized type, but 
            </p></dd><dt><a name="d0e2705"></a><span class="term">within(Foo&lt;String&gt;+)</span></dt><dd><p><a name="d0e2708"></a>matches any join point occurring within a type that 
            <tt>implements Foo&lt;String&gt;</tt>.
            </p></dd></dl></div><p>The <tt>withincode</tt> designator is likewise normally used with a 
         generic type, but can be used with a parameterized interface type to match join points
         arising from code lexically within the implementation of the interface methods in a type
         that implements the parameterized interface.
         </p><div class="variablelist"><dl><dt><a name="d0e2720"></a><span class="term">withincode&lt;T&gt;(* Foo&lt;T&gt;.*(..))</span></dt><dd><p><a name="d0e2723"></a>matches all join points arising from code lexically within a method of the 
            generic type <tt>Foo&lt;T&gt;</tt>
            </p></dd><dt><a name="d0e2729"></a><span class="term">withincode(* Foo&lt;String&gt;.*(..))</span></dt><dd><p><a name="d0e2732"></a>results in a compilation error if <tt>Foo</tt> is not an interface. If 
            <tt>Foo</tt> is an interface then it matches all join points arising from
            code lexically within the implementation of the interface methods in a type that
            implements <tt>Foo&lt;String&gt;</tt>.
            </p></dd><dt><a name="d0e2744"></a><span class="term">withincode(* Foo&lt;String&gt;+.*(..))</span></dt><dd><p><a name="d0e2747"></a>matches any join point occurring within a method of a type that 
            <tt>implements Foo&lt;String&gt;</tt>.
            </p></dd></dl></div></div><div class="sect3"><a name="d0e2753"></a><div class="titlepage"><div><h4 class="title"><a name="d0e2753"></a>Call, get and set pointcuts</h4></div></div><p>
         The <tt>call, get,</tt> and <tt>set</tt> join points can occur on the client
         side (ie. outside of the type owning the member being called, accessed, or updated) or 
         within the type that owns the target member. The following short program demonstrates this:
     </p><pre class="programlisting">
        public class Foo&lt;T&gt; {
        
          public T timeFor;  
          
          public Foo&lt;T&gt;(T aCuppa) {
                timeFor = aCuppa;      // set-site A
          }
        
          public void doThis(T t) {
            doThat(t);  // call-site A
          }    
          
          public void doThat(T t) {
             return;
          }
            
        }
        
        public class Main {
          public static void main(String[] args) {
            Foo&lt;String&gt; foos = new Foo&lt;String&gt;();
            foos.doThis("b");  //call-site B  
            foos.doThat("c");  // call-site C
            foos.timeFor = "a cuppa"; // set-site B
          }
        }
		</pre><p>
            We have annotated the three method call sites as call-site A, call-site B, and call-site C. 
            Call-site A is situated within the generic type <tt>Foo&lt;T&gt;</tt> and the call
            join point has signature <tt>public void Foo&lt;T&gt;doThat(T)</tt>. The join point
            arising from call-site B is a client-side call join point and has the signatures
            <tt>public void Foo&lt;String&gt;doThis(String)</tt> (from the static type of 
            <tt>foos</tt>) <span class="emphasis"><i>and</i></span>  
            <tt>public void Foo&lt;T&gt;doThis(T)</tt>. Likewise the call join point arising from
            call-site C has the signatures 
            <tt>public void Foo&lt;String&gt;doThat(String)</tt> (from the static type of 
            <tt>foos</tt>) <span class="emphasis"><i>and</i></span>  
            <tt>public void Foo&lt;T&gt;doThat(T)</tt>. A call pointcut expression matches if the
            signature pattern exactly matches one of the signatures of the call join point.
        </p><p>
            The signatures for get and set join points works in a similar fashion. At set-site A in the above
            example, the set join point has signature <tt>public T Foo&lt;T&gt;.timeFor</tt>. At 
            set-site B the set join point has signatures <tt>public T Foo&lt;T&gt;.timeFor</tt> and
            <tt>public String Foo&lt;String&gt;.timeFor</tt>. A get or set pointcut expression
            matches if the signature pattern exactly matches one of the signatures of the join point.
         </p>
         
         Some examples follow:

      <div class="variablelist"><dl><dt><a name="d0e2811"></a><span class="term">call(* List&lt;?&gt;.*(..))</span></dt><dd><p><a name="d0e2814"></a>matches a call to any method of a <tt>List&lt;?&gt;</tt> (a call where the
            target is declared to be a <tt>List&lt;?&gt;</tt>). For example:
            </p><pre class="programlisting">
        int countItems(List&lt;?&gt; anyList) {
          return anyList.size();   // matched by call(* List&lt;?&gt;.*(..))
        }
		</pre></dd><dt><a name="d0e2825"></a><span class="term">call&lt;T&gt;(* List&lt;T&gt;.*(..))</span></dt><dd><p><a name="d0e2828"></a>matches any call to an operation defined in the generic type 
            <tt>List&lt;E&gt;</tt>. This includes calls made to <tt>List&lt;String&gt;</tt>,
            <tt>List&lt;Number&gt;</tt>, <tt>List&lt;? super Foo&gt;</tt> and so on.
            </p></dd><dt><a name="d0e2843"></a><span class="term">get&lt;T&gt;(T *&lt;T extends Account&gt;.*)</span></dt><dd><p><a name="d0e2846"></a>matches the get of any field defined in a generic type with one type parameter that has 
                an upper bound of <tt>Account</tt>. The field has the type of the type parameter, and
                can be of any name. This pointcut expression matches both gets of the field within the
                declaring type, and also gets on parameterized instances of the type.
            </p></dd><dt><a name="d0e2852"></a><span class="term">set(Account Foo&lt;Account&gt;.*Account)</span></dt><dd><p><a name="d0e2855"></a>matches the set of a field of type <tt>Account</tt>  where the target
            is of type <tt>Foo&lt;Account&gt;</tt> and the field name ends with "Account". Does not
            match sets of any "*Account" field occurring within the <tt>Foo</tt> type itself.
            </p></dd><dt><a name="d0e2867"></a><span class="term">call(* List&lt;? extends Number&gt;.add(..))</span></dt><dd><p><a name="d0e2870"></a>matches any call to add an element to a list of type <tt>List&lt;? extends Number&gt;</tt>.
            Does not match calls to add elements to lists of type <tt>List&lt;Number&gt;</tt> or 
            <tt>List&lt;Double&gt;</tt> as these are distinct types.
            </p></dd><dt><a name="d0e2882"></a><span class="term">call(* List&lt;Number+&gt;.add(..))</span></dt><dd><p><a name="d0e2885"></a>matches any call to add an element to a list of type <tt> Number</tt> or
            any subclass of <tt>Number</tt>. For example, <tt>List&lt;Number&gt;, 
            List&lt;Double&gt; List&lt;Float&gt;</tt>.
            Does not match calls to add elements to lists of type <tt>List&lt;? extends Number&gt;</tt> 
            as this is a distinct type.
            </p></dd></dl></div></div><div class="sect3"><a name="d0e2900"></a><div class="titlepage"><div><h4 class="title"><a name="d0e2900"></a>Handler</h4></div></div><p>
          The Java Language Specification states that a generic class may not be a direct or indirect
          subclass of <tt>Throwable</tt>. Therefore it is a compilation error to use a generic
          or parameterized type pattern in a <tt>handler</tt> pointcut expression.
      </p></div><div class="sect3"><a name="d0e2911"></a><div class="titlepage"><div><h4 class="title"><a name="d0e2911"></a>Runtime type matching: this, target and args</h4></div></div><p>
         Java 5 generics are implemented using a technique known an <span class="emphasis"><i>erasure</i></span>.
         In particular, what gets "erased" is the ability to find out the parameterized runtime type
         of an instance of a generic type. You can ask if something is an <tt>instanceof List</tt>,
         but not if something is an <tt>instanceof List&lt;String&gt;</tt>
     </p><p>
         The <tt>this, target</tt> and <tt>args</tt> pointcut designators all match
         based on the runtime type of the appropriate object (this, target, or argument) at a join point. 
         To match any parameterization of a generic type, simply use the raw type (type variables are
         not permitted with these designators).  For example:
      </p><div class="variablelist"><dl><dt><a name="d0e2934"></a><span class="term">target(List)</span></dt><dd><p><a name="d0e2937"></a>matches any call to an instance of <tt>List</tt> (including 
            <tt>List&lt;String&gt;, List&lt;Number&gt;</tt>, and so on.
            </p></dd><dt><a name="d0e2946"></a><span class="term">args (List)</span></dt><dd><p><a name="d0e2949"></a>matches any join point with a single argument that is an instance of 
            <tt>List</tt>. 
            </p></dd></dl></div><p>
         To match specific parameterizations of a generic type, simply use the type that you require
         the relevant object to be an instance of inside the pointcut expression. For example:
         <tt>target(List&lt;String&gt;)</tt>. 
     </p><p>
         Recall that runtime tests to determine whether an object is an instance of a parameterized
         type are not possible due to erasure. Therefore AspectJ matching behaviour with 
         parameterized types for <tt>this, target</tt> and <tt>args</tt> is as follows. 
     </p><table class="simplelist" border="0" summary="Simple list"><tr><td>If it can be statically determined that a given object will always be an instance
         of the required type, then the pointcut expressions matches. For example, given a variable
         <tt>bankAccounts</tt>
         of type <tt>Set&lt;BankAccount&gt;</tt> and the pointcut expression
         <tt>target(Set&lt;BankAccount&gt;)</tt> then any call made to
         <tt>bankAccounts</tt> will be matched.</td></tr><tr><td>If it can be statically determined that a given object can never be an 
         instance of the required type, then the pointcut expression does not match. The
         expression <tt>target(List&lt;String&gt;)</tt>will never match a call made 
         using a variable of type <tt>List&lt;Number&gt;</tt> (it is not possible for
         a type to implement two different parameterizations of the same interface).</td></tr><tr><td>If an object <span class="emphasis"><i>might</i></span> be an instance of the required
         type in some circumstances but not in others, then since it is not possible to perform
         the runtime test, AspectJ deems the pointcut expression to match, but issues an
         unchecked warning. This is analogous to the behaviour of the Java compiler when
         converting between raw and parameterized types. Given a variable of type
         <tt>List&lt;? extends Number&gt;</tt> and a call join point with 
         target pointcut expression <tt>target(List&lt;Double&gt;)</tt> then 
         the expression matches but with an unchecked warning. The warning can be suppressed
         by annotating the associated advice with either <tt>@SuppressAjWarnings</tt>
         or <tt>@SuppressAjWarnings("unchecked")</tt>.</td></tr></table><p>   
         When using a parameterized type with the
         <tt>this</tt> pointcut designator then a joinpoint is unambiguously 
         matched if and only if one or more of the following conditions hold:
     </p><table class="simplelist" border="0" summary="Simple list"><tr><td>the runtime type of the <tt>this</tt> object extends or
         implements the parameterized type. For example, 
         <tt>class Foo implements List&lt;String&gt;</tt> will match
         <tt>this(List&lt;String&gt;)</tt>.</td></tr><tr><td>
           The parameterized "this" type is given using a generics wildcard in the pointcut 
           expression, and the bounds of
           the generic runtime type of <tt>this</tt> are such that all valid parameterizations
           are matched by the wildcard. For example, the pointcut expression 
           <tt>this(List&lt;? extends Number&gt;)</tt> will match a <tt>this</tt>
           object of type <tt>class Foo&lt;N extends Number&gt; implements List&lt;N&gt;</tt>,
           but not an object of type  <tt>class Foo&lt;N&gt; implements List&lt;N&gt;</tt>.
         </td></tr></table><p>
       You've already seen some examples of using the generic wildcard <tt>?</tt>
        in parameterized type patterns. Since <tt>this, target</tt> and 
       <tt>args</tt> match using an instance of test, the generic wildcard can be useful in
       specifying an acceptable range of parameterized types to match. When used in the binding
       form, the same restrictions on operations permitted on the bound variable apply as when a 
       method declares a parameter with a wildcard type. For example, in the advice below, it is
       a compilation error to attemp to add an element into the list <tt>aList</tt>. 
      </p><pre class="programlisting">
        before(List&lt;? extends Number&gt; aList) : 
          execution(* org.xyz.Foo.*(..)) &amp;&amp; args(aList) {
           aList.add(new Double(5.0d));  // Compilation error on this line
        }
		</pre></div><div class="sect3"><a name="d0e3058"></a><div class="titlepage"><div><h4 class="title"><a name="d0e3058"></a>Declaring pointcuts in generic classes</h4></div></div><p>
        AspectJ permits pointcuts to be declared in classes as well as aspects. A pointcut defined
        inside a generic class may not use the type variables of the class in the pointcut expression
        (just as static members of a generic class may not use type variables). 
        For example:        
     </p><pre class="programlisting">
        public class Foo&lt;T extends Number&gt; {
          
          ...
          
          // Not allowed - uses T in the pointcut expression
          public pointcut fooOperationCall(T t) : 
             call(* Foo&lt;T&gt;.*(T)) &amp;&amp; args(t);   
            
            
          // permitted, but recommended to use an alternate variable name in the local 
          // type variable declaration - e.g. execution&lt;S&gt;(...)
          public pointcut fooExecution(Number n) :
             execution&lt;T&gt;(* Foo&lt;T&gt;.*(T)) &amp;&amp; args(n); 
        }
		</pre></div></div><div class="sect2"><a name="d0e3065"></a><div class="titlepage"><div><h3 class="title"><a name="d0e3065"></a>Inter-type Declarations</h3></div></div><p>
            AspectJ 5 allows type parameters to be used in inter-type declarations - either for declaring generic
            methods and constructors, or for declaring members on generic types. The syntax for declaring generic
            methods and constructors follows the regular AspectJ convention of simply qualifying the member name with
            the target type.
          </p><div class="variablelist"><dl><dt><a name="d0e3071"></a><span class="term">&lt;T extends Number&gt; T Utils.max(T first, T second) {...}</span></dt><dd><p><a name="d0e3074"></a>Declares a generic instance method <tt>max</tt> on the class <tt>Util</tt>.
            The <tt>max</tt> method takes two arguments, <tt>first</tt> and <tt>second</tt> which must
            both be of the same type (and that type must be Number or a subtype of Number) and returns an instance
            of that type.
            </p></dd><dt><a name="d0e3092"></a><span class="term">static &lt;E&gt; E Utils.first(List&lt;E&gt; elements) {...}</span></dt><dd><p><a name="d0e3095"></a>Declares a static generic method <tt>first</tt> on the class <tt>Util</tt>.
            The <tt>first</tt> method takes a list of elements of some type, and returns an instance
            of that type.
            </p></dd><dt><a name="d0e3107"></a><span class="term">&lt;T&gt; Sorter.new(List&lt;T&gt; elements,Comparator&lt;? super T&gt; comparator) {...}</span></dt><dd><p><a name="d0e3110"></a>Declares a constructor on the class <tt>Sorter</tt>.
            The constructor takes a list of elements of some type, and a comparator that can compare instances
            of the element type.
            </p></dd></dl></div><p>
         A generic type may be the target of an inter-type declaration, used either in its raw form or with
         type parameters specified. If type parameters are specified, then the number of type parameters given
          must match the number of type parameters in
         the generic type declaration. Type parameter <span class="emphasis"><i>names</i></span> do not have to match.
         For example, given the generic type <tt>Foo&lt;T,S extends Number&gt;</tt> then:      
      </p><div class="variablelist"><dl><dt><a name="d0e3125"></a><span class="term">String Foo.getName() {...}</span></dt><dd><p><a name="d0e3128"></a>Declares a <tt>getName</tt> method on behalf of the raw type <tt>Foo</tt>. It is
            not possible to refer to the type parameters of Foo in such a declaration.
            </p></dd><dt><a name="d0e3137"></a><span class="term">R Foo&lt;Q, R&gt;.getMagnitude() {...}</span></dt><dd><p><a name="d0e3140"></a>Declares a method <tt>getMagnitude</tt> on the generic class <tt>Foo</tt>.
            The method returns an instance of the type substituted for the second type parameter in an invocation
            of <tt>Foo</tt>.
            </p></dd><dt><a name="d0e3152"></a><span class="term">R Foo&lt;Q, R extends Number&gt;.getMagnitude() {...}</span></dt><dd><p><a name="d0e3155"></a>Results in a compilation error since a bounds specification is not allowed in this
                form of an inter-type declaration (the bounds are determined from the declaration of the
                target type).
            </p></dd></dl></div><p>A parameterized type may not be the target of an inter-type declaration. This is because
      there is only one type (the generic type) regardless of how many different invocations (parameterizations) of
      that generic type are made in a program. Therefore it does not make sense to try and declare a member
      on behalf of (say) <tt>Foo&lt;String&gt;</tt>, you can only declare members on the generic
      type <tt>Foo&lt;T&gt;</tt>. 
      </p><p>
        If an inter-type member is declared inside a generic aspect, then the type parameter names from the
        aspect declaration may be used in the signature specification of the inter-type declaration, but 
        <span class="emphasis"><i>not</i></span> as type parameter names for a generic target type. In other words the example
        that follows is legal:
      </p><pre class="programlisting">
            public abstract aspect A&lt;T&gt; {
              
              private T Foo.data;
              
              public T Foo.getData(T defaultValue) {
                return (this.data != null ? data : defaultValue);
              }   
                
            }
		</pre><p>
       Whereas the following example is not allowed and will report an error that a parameterized type may not be the
       target of an inter-type declaration (since when the type parameter <tt>T</tt> in the aspect is subsituted with
       say, <tt>String</tt>, then the target of the inter-type declaration becomes <tt>Goo&lt;String&gt;</tt>).  
      </p><pre class="programlisting">
            public abstract aspect A&lt;T&gt; {
              
              private T Goo&lt;T&gt;.data;
              
              public T Goo&lt;T&gt;.getData(T defaultValue) {
                return (this.data != null ? data : defaultValue);
              }   
                
            }
		</pre></div><div class="sect2"><a name="d0e3186"></a><div class="titlepage"><div><h3 class="title"><a name="d0e3186"></a>Declare Parents</h3></div></div><p>Both generic and parameterized types can be used as the parent type in a <tt>declare parents</tt>
          statement (as long as the resulting type hierarchy would be well-formed in accordance with Java's sub-typing
          rules). Generic types may also be used as the target type of a <tt>declare parents</tt> statement: 
          a type variable list follows the <tt>parents</tt> keyword in these cases to declare the
          type variables in scope.
          Some examples follow:</p><div class="variablelist"><dl><dt><a name="d0e3201"></a><span class="term">declare parents: Foo implements List&lt;String&gt;</span></dt><dd><p><a name="d0e3204"></a>The <tt>Foo</tt> type implements the <tt>List&lt;String&gt;</tt> interface. If
            <tt>Foo</tt> already implements some other parameterization of the <tt>List</tt>
            interface (for example, <tt>List&lt;Integer&gt;</tt> then a compilation error will result since a 
            type cannot implement multiple parameterizations of the same generic interface type. 
            </p></dd><dt><a name="d0e3222"></a><span class="term">declare parents &lt;T&gt;:  org.xyz..*&lt;T&gt; extends Base&lt;T&gt;</span></dt><dd><p><a name="d0e3225"></a>All generic types declared in a package beginning with <tt>org.xyz</tt> and with a 
            single unbounded type parameter, extend the generic type <tt>Base&lt;T&gt;</tt>.
            </p></dd><dt><a name="d0e3234"></a><span class="term">declare parents &lt;T&gt;:  org.xyz..*&lt;T&gt; extends Base&lt;S&gt;</span></dt><dd><p><a name="d0e3237"></a>Results in a compilation error (unless <tt>S</tt> is a type) since <tt>S</tt> is
            not bound in the type pattern.
            </p></dd></dl></div></div><div class="sect2"><a name="d0e3246"></a><div class="titlepage"><div><h3 class="title"><a name="d0e3246"></a>Declare Soft</h3></div></div><p>It is an error to use a generic or parameterized type as the softened exception type in a declare soft statement. Java 5 does
          not permit a generic class to be a direct or indirect subtype of <tt>Throwable</tt> (JLS 8.1.2).</p></div><div class="sect2"><a name="d0e3254"></a><div class="titlepage"><div><h3 class="title"><a name="d0e3254"></a>Parameterized Aspects</h3></div></div><p>
            AspectJ 5 allows an <span class="emphasis"><i>abstract</i></span> aspect to be declared as a generic type. Any concrete
            aspect extending a generic abstract aspect must extend a parameterized version of the abstract aspect.
            Wildcards are not permitted in this parameterization.     
          </p><p>Given the aspect declaration:</p><pre class="programlisting">
            public abstract aspect ParentChildRelationship&lt;P,C&gt; {
                ...
            }
		</pre><p>then</p><div class="variablelist"><dl><dt><a name="d0e3269"></a><span class="term">public aspect FilesInFolders extends ParentChildRelationship&lt;Folder,File&gt; {...</span></dt><dd><p><a name="d0e3272"></a>declares a concrete sub-aspect, <tt>FilesInFolders</tt> which extends the
            parameterized abstract aspect <tt>ParentChildRelationship&lt;Folder,File&gt;</tt>.
            </p></dd><dt><a name="d0e3281"></a><span class="term">public aspect FilesInFolders extends ParentChildRelationship {...</span></dt><dd><p><a name="d0e3284"></a>results in a compilation error since the <tt>ParentChildRelationship</tt> aspect must
            be fully parameterized.
            </p></dd><dt><a name="d0e3290"></a><span class="term">public aspect ThingsInFolders&lt;T&gt; extends ParentChildRelationship&lt;Folder,T&gt;</span></dt><dd><p><a name="d0e3293"></a>results in a compilation error since concrete aspects may not have type parameters.
            </p></dd><dt><a name="d0e3296"></a><span class="term">public abstract aspect ThingsInFolders&lt;T&gt; extends ParentChildRelationship&lt;Folder,T&gt;</span></dt><dd><p><a name="d0e3299"></a>declares a sub-aspect of <tt>ParentChildRelationship</tt> in which <tt>Folder</tt>
            plays the role of parent (is bound to the type variable <tt>P</tt>).
            </p></dd></dl></div><p>An exception to the rule that concrete aspects may not be generic is a pertypewithin aspect, which
       may be declared with a single unbounded type parameter. This is discussed in the chapter on <a href="pertypewithin.html">pertypewithin</a>.</p><p>The type parameter variables from a generic aspect declaration may be used in place of a type within any
        member of the aspect. For example, we can declare a <tt>ParentChildRelationship</tt> aspect to
        manage the bi-directional relationship between parent and child nodes as follows:
        </p><pre class="programlisting">
            public abstract aspect ParentChildRelationship&lt;P,C&gt; {
                
                /**
                 * Parents contain a list of children
                 */
                private List&lt;C&gt; P.children;
                    
                /**
                 * Each child has a parent
                 */
                private P C.parent;

                /**
                  * Parents provide access to their children
                  */
                public List&lt;C&gt; P.getChildren() {
                    return Collections.unmodifiableList(children);  
                }
                
                /**
                 * A child provides access to its parent
                 */
                 public P C.getParent() {
                   return parent;
                 }
                
                /**
                 * ensure bi-directional navigation on adding a child
                 */
                public void P.addChild(C child) {
                   if (child.parent != null) {
                     child.parent.removeChild(child);
                   }
                   children.add(child);
                   child.parent = this;
                }

                /**
                 * ensure bi-directional navigation on removing a child
                 */
                public void P.removeChild(C child) {
                   if (children.remove(child)) {
                     child.parent = null;
                   }
                }

               /**
                 * ensure bi-directional navigation on setting parent
                 */
                public void C.setParent(P parent) {
                   parent.addChild(this);
                }
                
                public pointcut addingChild(P p, C c) :
                  execution(* P.addChild(C)) &amp;&amp; this(p) &amp;&amp; args(c);
                  
                public pointcut removingChild(P p, C c) :
                  execution(* P.removeChild(C)) &amp;&amp; this(p) &amp;&amp; args(c);
            }
		</pre><p>
          Note in the above example how the type parameters <tt>P</tt> and <tt>C</tt> can be
          used in inter-type declarations, pointcut expressions, and any other member of the aspect type. 
        </p><p>
          The example aspect captures the protocol for managing a bi-directional parent-child relationship between
          any two types playing the role of parent and child. In a compiler implementation managing an abstract syntax
          tree (AST) in which AST nodes may contain other AST nodes we could declare the concrete aspect:
        </p><pre class="programlisting">
            public aspect ASTNodeContainment extends ParentChildRelationship&lt;ASTNode,ASTNode&gt; {
                
                before(ASTNode parent, ASTNode child) : addingChild(parent, child) {
                  ...
                }
                
            }
		</pre><p>
           As a result of this declaration, <tt>ASTNode</tt> gains members:
         </p><table class="simplelist" border="0" summary="Simple list"><tr><td><tt>List&lt;ASTNode&gt; children</tt></td></tr><tr><td><tt>ASTNode parent</tt></td></tr><tr><td><tt>List&lt;ASTNode&gt;getChildren()</tt></td></tr><tr><td><tt>ASTNode getParent()</tt></td></tr><tr><td><tt>void addChild(ASTNode child)</tt></td></tr><tr><td><tt>void removeChild(ASTNode child)</tt></td></tr><tr><td><tt>void setParent(ASTNode parent)</tt></td></tr></table><p>
           In a system managing files and folders, we could declare the concrete aspect:
         </p><pre class="programlisting">
            public aspect FilesInFolders extends ParentChildRelationship&lt;Folder,File&gt; {
                                
            }
		</pre><p>
           As a result of this declaration, <tt>Folder</tt> gains members:
         </p><table class="simplelist" border="0" summary="Simple list"><tr><td><tt>List&lt;File&gt; children</tt></td></tr><tr><td><tt>List&lt;File&gt; getChildren()</tt></td></tr><tr><td><tt>void addChild(File child)</tt></td></tr><tr><td><tt>void removeChild(File child)</tt></td></tr></table><p>and <tt>File</tt> gains members:</p><table class="simplelist" border="0" summary="Simple list"><tr><td><tt>Folder parent</tt></td></tr><tr><td><tt>Folder getParent()</tt></td></tr><tr><td><tt>void setParent(Folder parent)</tt></td></tr></table><p>When used in this way, the type parameters in a generic abstract aspect declare
        <span class="emphasis"><i>roles</i></span>, and the parameterization of the abstract aspect in the <tt>extends</tt>
        clause binds types to those roles. This is a case where you may consider departing from the standard practice 
        of using a single letter to represent a type parameter, and instead use a role name. It makes no difference
        to the compiler which option you choose of course.</p><pre class="programlisting">
            public abstract aspect ParentChildRelationship&lt;Parent,Child&gt; {
                
                /**
                 * Parents contain a list of children
                 */
                private List&lt;Child&gt; Parent.children;
                    
                /**
                 * Each child has a parent
                 */
                private Parent Child.parent;
                
                /**
                  * Parents provide access to their children
                  */
                public List&lt;Children&gt; Parent.getChildren() {
                    return Collections.unmodifiableList(children);  
                }
                
                /**
                 * A child provides access to its parent
                 */
                 public Parent Children.getParent() {
                   return parent;
                 }
                                
                /**
                 * ensure bi-directional navigation on adding a child
                 */
                public void Parent.addChild(Child child) {
                   if (child.parent != null) {
                     child.parent.removeChild(child);
                   }
                   children.add(child);
                   child.parent = this;
                }
         
                ...
		</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="generics.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="autoboxing.html">Next</a></td></tr><tr><td width="40%" align="left">Chapter 3. Generics&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="generics.html">Up</a></td><td width="40%" align="right">&nbsp;Chapter 4. Autoboxing and Unboxing</td></tr></table></div></body></html>