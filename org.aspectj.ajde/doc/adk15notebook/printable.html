<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>The AspectJTM 5 Development Kit Developer's Notebook</title><link rel="stylesheet" href="aspectj-docs.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.44"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" id="d0e1"><div class="titlepage"><div><h1 class="title"><a name="d0e1"></a>The AspectJ<sup>TM</sup> 5 Development Kit Developer's Notebook</h1></div><div><h3 class="author">the AspectJ Team</h3></div><div><div class="legalnotice"><p>
        Copyright (c) 2004 Contributors,  
        All rights reserved.
      </p></div></div><div><div class="abstract"><p><a name="d0e15"></a><b>Abstract</b></p><p>
        This guide describes the changes to the AspectJ language
        and tools in AspectJ 5. These include support for Java 5 (Tiger) features,
        enhancements to load-time weaving, an support for an annotation-based
        development style for aspects.
        If you are new to AspectJ, we recommend you start 
        by reading the programming guide.
      </p><p>
         This is a draft document and is <span class="emphasis"><i>subject to change</i></span> before
         the design and implementation is complete. There is also no guarantee that all
         of the features in this document will be implemented in a 1.5.0 release - some
         may be deferred until 1.5.1 or even later. In general, features in which we
         have more confidence in the design will be implemented earlier, providing a 
         framework for user feedback and direction setting on features for which the
         use cases are less obvious at time of writing.
      </p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt>1. <a href="#jpsigs">Join Point Signatures</a></dt><dd><dl><dt><a href="#join-point-matching">Join Point Matching</a></dt><dt><a href="#join-point-signatures">Join Point Signatures</a></dt><dd><dl><dt><a href="#d0e246">Method call join point signatures</a></dt><dt><a href="#d0e351">Method execution join point signatures</a></dt><dt><a href="#d0e373">Field get and set join point signatures</a></dt></dl></dd><dt><a href="#join-point-modifiers">Join Point Modifiers</a></dt><dt><a href="#join-point-matching-summary">Summary of Join Point Matching</a></dt></dl></dd><dt>2. <a href="#annotations">Annotations</a></dt><dd><dl><dt><a href="#annotations-inJava5">Annotations in Java 5</a></dt><dd><dl><dt><a href="#d0e578">Using Annotations</a></dt><dt><a href="#d0e624">Retention Policies</a></dt><dt><a href="#d0e659">Accessing Annotations at Runtime</a></dt><dt><a href="#d0e694">Annotation Inheritance</a></dt></dl></dd><dt><a href="#annotations-aspectmembers">Annotating Aspects</a></dt><dt><a href="#annotations-pointcuts-and-advice">Join Point Matching based on Annotations</a></dt><dd><dl><dt><a href="#d0e782">Annotation Patterns</a></dt><dt><a href="#d0e867">Type Patterns</a></dt><dt><a href="#signaturePatterns">Signature Patterns</a></dt><dt><a href="#d0e1121">Example Pointcuts</a></dt><dt><a href="#d0e1194">Runtime type matching and context exposure</a></dt><dt><a href="#d0e1421">Package and Parameter Annotations</a></dt><dt><a href="#d0e1431">Annotation Inheritance and pointcut matching</a></dt><dt><a href="#d0e1463">Limitations</a></dt></dl></dd><dt><a href="#annotations-decp">Using Annotations with declare statements</a></dt><dd><dl><dt><a href="#d0e1478">Declare error and declare warning</a></dt><dt><a href="#d0e1493">declare parents</a></dt><dt><a href="#d0e1541">declare precedence</a></dt></dl></dd><dt><a href="#annotations-declare">Declare Annotation</a></dt><dt><a href="#annotations-itds">Inter-type Declarations</a></dt></dl></dd><dt>3. <a href="#generics">Generics</a></dt><dd><dl><dt><a href="#generics-inJava5">Generics in Java 5</a></dt><dd><dl><dt><a href="#d0e1673">Declaring Generic Types</a></dt><dt><a href="#d0e1804">Using Generic and Parameterized Types</a></dt><dt><a href="#d0e1948">Subtypes, Supertypes, and Assignability</a></dt><dt><a href="#d0e2051">Generic Methods and Constructors</a></dt><dt><a href="#d0e2069">Erasure</a></dt></dl></dd><dt><a href="#generics-inAspectJ5">Generics in AspectJ 5</a></dt><dd><dl><dt><a href="#d0e2095">Matching generic and parameterized types in type patterns</a></dt><dt><a href="#d0e2295">Signature patterns</a></dt><dt><a href="#d0e2378">Pointcuts</a></dt><dt><a href="#d0e3065">Inter-type Declarations</a></dt><dt><a href="#d0e3186">Declare Parents</a></dt><dt><a href="#d0e3246">Declare Soft</a></dt><dt><a href="#d0e3254">Parameterized Aspects</a></dt></dl></dd></dl></dd><dt>4. <a href="#autoboxing">Autoboxing and Unboxing</a></dt><dd><dl><dt><a href="#boxing-inJava5">Autoboxing and Unboxing in Java 5</a></dt><dt><a href="#autoboxing-in-aspectj5">Autoboxing and Join Point matching in AspectJ 5</a></dt><dt><a href="#autoboxing-and-method-dispatch">Inter-type method declarations and method dispatch</a></dt></dl></dd><dt>5. <a href="#covariance">Covariance</a></dt><dd><dl><dt><a href="#covariance-inJava5">Covariance in Java 5</a></dt><dt><a href="#covariance-and-join-point-matching">Covariant methods and Join Point matching</a></dt></dl></dd><dt>6. <a href="#varargs">Varargs</a></dt><dd><dl><dt><a href="#varargs-inJava5">Variable-length Argument Lists in Java 5</a></dt><dd><dl><dt><a href="#d0e3620">Calling Methods and Constructors with variable-length arguments</a></dt></dl></dd><dt><a href="#varargs-in-pcds">Using Variable-length arguments in advice and pointcut expressions</a></dt><dd><dl><dt><a href="#d0e3654">Matching signatures based on variable length argument types</a></dt><dt><a href="#d0e3756">Exposing variable-length arguments as context in pointcuts and advice</a></dt></dl></dd></dl></dd><dt>7. <a href="#enumeratedtypes">Enumerated Types</a></dt><dd><dl><dt><a href="#enums-in-java5">Enumerated Types in Java 5</a></dt><dt><a href="#enums-in-aspectj5">Enumerated Types in AspectJ 5</a></dt></dl></dd><dt>8. <a href="#pertypewithin">The pertypewithin Aspect Instantiation Model</a></dt><dt>9. <a href="#ataspectj">An Annotation Based Development Style</a></dt><dd><dl><dt><a href="#ataspectj-intro">Introduction</a></dt><dt><a href="#ataspectj-aspects">Aspect Declarations</a></dt><dt><a href="#ataspectj-pcadvice">Pointcuts and Advice</a></dt><dd><dl><dt><a href="#d0e3980">Pointcuts</a></dt><dt><a href="#d0e4101">Advice</a></dt></dl></dd><dt><a href="#ataspectj-itds">Inter-type Declarations</a></dt><dt><a href="#ataspectj-declare">Declare statements</a></dt><dt><a href="#ataspectj-aspectof">aspectOf() and hasAspect() methods</a></dt></dl></dd><dt>10. <a href="#reflection">New Reflection Interfaces</a></dt><dd><dl><dt><a href="#reflection_api">The Aspect Class</a></dt></dl></dd><dt>11. <a href="#miscellaneous">Other Changes in AspectJ 5</a></dt><dd><dl><dt><a href="#d0e4336">Pointcuts</a></dt><dd><dl><dt><a href="#d0e4339">Binding of formals</a></dt><dt><a href="#d0e4348">Additional lint warnings</a></dt></dl></dd><dt><a href="#declare-soft">Declare Soft</a></dt><dt><a href="#d0e4390">Tools</a></dt><dd><dl><dt><a href="#d0e4393">Aspectpath</a></dt></dl></dd></dl></dd><dt>12. <a href="#ltw">Load-Time Weaving</a></dt><dd><dl><dt><a href="#ltw-introduction">Introduction</a></dt><dd><dl><dt><a href="#d0e4415">Weaving class files more than once</a></dt></dl></dd><dt><a href="#ltw-rules">Load-time Weaving Requirements</a></dt><dt><a href="#ltw-configuration">Configuration</a></dt><dd><dl><dt><a href="#d0e4443">Enabling Load-time Weaving</a></dt><dt><a href="#d0e4471">Configuring Load-time Weaving with aop.xml files</a></dt><dt><a href="#d0e4535">Configuring Load-time Weaving with Properties Files</a></dt><dt><a href="#d0e4545">Weaver Options</a></dt></dl></dd><dt><a href="#ltw-packaging">Runtime Requirements for Load-time Weaving</a></dt><dt><a href="#ltw-agents">Supported Agents</a></dt><dd><dl><dt><a href="#d0e4637">JVMTI</a></dt><dt><a href="#d0e4644">JRockit</a></dt></dl></dd></dl></dd><dt>A. <a href="#grammar">A Grammar for the AspectJ 5 Language</a></dt></dl></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="jpsigs"></a>Chapter 1. Join Point Signatures</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#join-point-matching">Join Point Matching</a></dt><dt><a href="#join-point-signatures">Join Point Signatures</a></dt><dd><dl><dt><a href="#d0e246">Method call join point signatures</a></dt><dt><a href="#d0e351">Method execution join point signatures</a></dt><dt><a href="#d0e373">Field get and set join point signatures</a></dt></dl></dd><dt><a href="#join-point-modifiers">Join Point Modifiers</a></dt><dt><a href="#join-point-matching-summary">Summary of Join Point Matching</a></dt></dl></div><p>
        Many of the extensions to the AspectJ language to address the new features of
        Java 5 are derived from a simple set of principles for join point
        matching. In this section, we outline these principles as a foundation
        for understanding the matching rules in the presence of annotations,
        generics, covariance, varargs, and autoboxing.
    </p><div class="sect1"><a name="join-point-matching"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="join-point-matching"></a>Join Point Matching</h2></div></div><p>AspectJ supports 11 different kinds of join points. These are
        the <tt>method call, method execution, constructor call,
        constructor execution, field get, field set, pre-initialization,
        initialization, static initialization, handler,</tt> and
        <tt>advice execution</tt> join points.</p><p>The <span class="emphasis"><i>kinded</i></span> pointcut designators match
        based on the kind of a join point. These are the <tt>call,
        execution, get, set, preinitialization, initialization, 
        staticinitialization, handler,</tt> and <tt>adviceexecution</tt>
        designators.</p><p>A kinded pointcut is written using patterns, some of which 
        match based on <span class="emphasis"><i>signature</i></span>, and some of which
        match based on <span class="emphasis"><i>modifiers</i></span>. For example, in 
        the <tt>call</tt> pointcut designator:</p><pre class="programlisting">
        call(ModifierPattern TypePattern TypePattern.IdPattern(TypePatternList) ThrowsPattern)
		</pre><p>the modifiers matching patterns are <tt>ModifierPattern</tt>
		and <tt>ThrowsPattern</tt>, and the signature matching patterns
		are <tt>TypePattern TypePattern.IdPattern(TypePatternList)</tt>.
		</p><p>
		A join point has potentially multiple signatures, but only one set of
		modifiers. <span class="emphasis"><i>A kinded primitive pointcut matches a particular join point 
		if and only if</i></span>:
		</p><div class="orderedlist"><ol type="1"><li><a name="d0e80"></a>They are of the same kind</li><li><a name="d0e82"></a>The signature pattern (exactly) matches at least one 
		    signature of the join point</li><li><a name="d0e84"></a>The modifiers pattern matches the modifiers of the
		    subject of the join point</li></ol></div><p>These rules make it very easily to quickly determine whether a 
        given pointcut matches a given join point. In the next two sections,
        we describe what the signature(s) of a join point are, and what the
        subjects of join points are.</p></div><div class="sect1"><a name="join-point-signatures"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="join-point-signatures"></a>Join Point Signatures</h2></div></div><p>Call, execution, get, and set join points may potentially have multiple
        signatures. All other join points have exactly one signature. The
        following table summarizes the constituent parts of a join point
        signature for the different kinds of join point.</p><div class="informaltable" id="d0e93"><a name="d0e93"></a><table border="1"><colgroup><col><col><col><col><col><col><col></colgroup><thead><tr><th>Join Point Kind</th><th>Return Type</th><th>Declaring Type</th><th>Id</th><th>Parameter Types</th><th>Field Type</th><th>Exception Type</th></tr></thead><tbody><tr><td>Method call</td><td>+</td><td>+</td><td>+</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Method execution</td><td>+</td><td>+</td><td>+</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Constructor call</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Constructor execution</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Field get</td><td>&nbsp;</td><td>+</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td></tr><tr><td>Field set</td><td>&nbsp;</td><td>+</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td></tr><tr><td>Pre-initialization</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Initialization</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Static initialization</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Handler</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>+</td></tr><tr><td>Advice execution</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></div><p>Note that whilst an advice excetution join point has a
        signature comprising the declaring type of the advice and the
        advice parameter types, the <tt>adviceexecution</tt>
        pointcut designator does not support matching based on this
        signature.</p><p>The signatures for most of the join point kinds should be
        self-explanatory, except for field get and set, and method call and execution
        join points, which can have multiple signatures. Each signature of 
        a method call or execution join point has the same id and parameter
        types, but the declaring type and return type (with covariance) may vary.
        Each signature of a field get or set join point has the same id and field
        type, but the declaring type may vary.
        </p><p>The following sections examine signatures for these join points 
        in more detail.</p><div class="sect2"><a name="d0e246"></a><div class="titlepage"><div><h3 class="title"><a name="d0e246"></a>Method call join point signatures</h3></div></div><p>
          For a call join point where a call is made to a method
          <tt>m(parameter_types)</tt> on a target type <tt>T</tt> (where
          <tt>T</tt> is the static type of the target):
        </p><pre class="programlisting">
		T t = new T(); 
		t.m("hello");  &lt;= call join point occurs when this line is executed
		</pre><p>
            Then the signature <tt>R(T) T.m(parameter_types)</tt> is a signature
            of the call join point, where <tt>R(T)</tt> is the return
            type of <tt>id</tt> in <tt>T</tt>, and 
            <tt>parameter_types</tt> are the parameter types of
            <tt>m</tt>. If <tt>T</tt> itself does not
            declare a definition of <tt>m(parameter_types)</tt>, then 
            <tt>R(T)</tt> is the return type in the definition of 
            <tt>m</tt> that <tt>T</tt> inherits. Given the
            call above, and the definition of <tt>T.m</tt>:                      
        </p><pre class="programlisting">
        interface Q {
          R m(String s);
        }
        
        class P implements Q {
          R m(String s) {...}        
        }
        
        class S extends P {
          R' m(String s) {...}
        }
        
        class T extends S {} 
		
		</pre><p>Then <tt>R' T.m(String)</tt> is a signature of the
        call join point for <tt>t.m("hello")</tt>.</p><p>
            For each ancestor (super-type) <tt>A</tt> of <tt>T</tt>, 
            if <tt>m(parameter_types)</tt> is defined for that super-type, then
            <tt>R(A) A.m(parameter_types)</tt> is a signature of the call join
            point, where <tt>R(A)</tt> is the return type of <tt>
            m(parameter_types)</tt> as defined in <tt>A</tt>, or as inherited
            by <tt>A</tt> if <tt>A</tt> itself does not
            provide a definition of <tt>m(parameter_types)</tt>.            
        </p><p>
            Continuing the example from above,we can deduce that
        </p><pre class="programlisting">
        R' S.m(String)
        R  P.m(String)
        R  Q.m(String)
		</pre><p>are all additional signatures for the call join point arising
        from the call <tt>t.m("hello")</tt>. Thus this call
        join point has four signatures in total. Every signature has the same
        id and parameter types, and a different declaring type.</p></div><div class="sect2"><a name="d0e351"></a><div class="titlepage"><div><h3 class="title"><a name="d0e351"></a>Method execution join point signatures</h3></div></div><p>Join point signatures for execution join points are defined
          in a similar manner to signatures for call join points. Given the
          hierarchy:
          </p><pre class="programlisting">
        interface Q {
          R m(String s);
        }
        
        class P implements Q {
          R m(String s) {...}        
        }
        
        class S extends P {
          R' m(String s) {...}
        }
        
        class T extends S { }
        
        class U extends T {
          R' m(String s) {...}
        }
		
		</pre><p>Then the execution join point signatures arising as a result
        of the call to <tt>u.m("hello")</tt> are: </p><pre class="programlisting">
        R' U.m(String)
        R' S.m(String)
        R  P.m(String)
        R  Q.m(String)
		</pre><p>Each signature has the same id and parameter types, and a 
        different declaring type. There is one signature for each type
        that provides its own declaration of the method. Hence in this 
        example there is no signature <tt>R' T.m(String)</tt>
        as <tt>T</tt> does not provide its own declaration of
        the method.</p></div><div class="sect2"><a name="d0e373"></a><div class="titlepage"><div><h3 class="title"><a name="d0e373"></a>Field get and set join point signatures</h3></div></div><p>
            For a field get join point where an access is made to a field
            <tt>f</tt> of type <tt>F</tt> 
            on a object with declared type <tt>T</tt>, then
            <tt>F T.f</tt> is a signature of the get join point.  
        </p><p>
            If <tt>T</tt> does not directly declare a member
            <tt>f</tt>, then for each super type <tt>S</tt>
            of <tt>T</tt>, up to and including the most specific
            super type of <tt>T</tt> that does declare the member
            <tt>f</tt>, <tt>F S.f</tt> is a signature
            of the join point. For example, given the hierarchy:
        </p><pre class="programlisting">        
        class P  {
          F f;        
        }
        
        class S extends P {
          F f;
        }
        
        class T extends S { }                
		</pre><p>
		    Then the join point signatures for a field get join point of
		    the field <tt>f</tt> on an object with declared type
		    <tt>T</tt> are:
		</p><pre class="programlisting">
        F S.f
        F T.f
		</pre><p>The signatures for a field set join point are derived in an
            identical manner.</p></div></div><div class="sect1"><a name="join-point-modifiers"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="join-point-modifiers"></a>Join Point Modifiers</h2></div></div><p>Every join point has a single set of modifiers - these include
          the standard Java modifiers such as <tt>public, private,
          static, abstract</tt> etc., any annotations, and the throws
          clauses of methods and constructors. These modifiers are the
          modifiers of the <span class="emphasis"><i>subject</i></span> of the join point.</p><p>
          The following table defines the join point subject for each kind
          of join point.
          </p><div class="informaltable" id="d0e440"><a name="d0e440"></a><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Join Point Kind</th><th>Subject</th></tr></thead><tbody><tr><td>Method call</td><td>The method picked out by Java as
                       the static target of the method call.</td></tr><tr><td>Method execution</td><td>The method that is executing.</td></tr><tr><td>Constructor call</td><td>The constructor being called.</td></tr><tr><td>Constructor execution</td><td>The constructor executing.</td></tr><tr><td>Field get</td><td>The field being accessed.</td></tr><tr><td>Field set</td><td>The field being set.</td></tr><tr><td>Pre-initialization</td><td>The first constructor executing in
                       this constructor chain.</td></tr><tr><td>Initialization</td><td>The first constructor executing in
                       this constructor chain.</td></tr><tr><td>Static initialization</td><td>The type being initialized.</td></tr><tr><td>Handler</td><td>The declared type of the
                       exception being handled.</td></tr><tr><td>Advice execution</td><td>The advice being executed.</td></tr></tbody></table></div><p>For example, given the following types</p><pre class="programlisting">
        public class X {        
          @Foo
          protected void doIt() {...} 
        }
        
        public class Y extends X {        
          public void doIt() {...}        
        }
		</pre><p>Then the modifiers for a call to <tt>(Y y) y.doIt()</tt>
         are simply <tt>{public}</tt>. The modifiers for a call to
         <tt>(X x) x.doIt()</tt> are <tt>{@Foo,protected}</tt>.
         </p></div><div class="sect1"><a name="join-point-matching-summary"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="join-point-matching-summary"></a>Summary of Join Point Matching</h2></div></div><p>
		A join point has potentially multiple signatures, but only one set of
		modifiers. <span class="emphasis"><i>A kinded primitive pointcut matches a particular join point 
		if and only if</i></span>:
		</p><div class="orderedlist"><ol type="1"><li><a name="d0e531"></a>They are of the same kind</li><li><a name="d0e533"></a>The signature pattern (exactly) matches at least one 
		    signature of the join point</li><li><a name="d0e535"></a>The modifiers pattern matches the modifiers of the
		    subject of the join point</li></ol></div><p>Given the hierarchy</p><pre class="programlisting">
        interface Q {
          R m(String s);
        }
        
        class P implements Q {
          @Foo
          public R m(String s) {...}        
        }
        
        class S extends P {
          @Bar
          public R' m(String s) {...}
        }
        
        class T extends S {} 
		
		</pre><p>and the program fragment:</p><pre class="programlisting">
        P p = new P();
        S s = new S();
        T t = new T();
        ...
        p.m("hello");
        s.m("hello");
        t.m("hello");
		</pre><p>
        The the pointcut <tt>call(@Foo R P.m(String))</tt> matches the
        call <tt>p.m("hello")</tt> since both the signature and the 
        modifiers match. It does not match the call <tt>s.m("hello")</tt>
        because even though the signature pattern matches one of the signatures
        of the join point, the modifiers pattern does not match the modifiers of
        the method m in S which is the static target of the call.
        </p><p>The pointcut <tt>call(R' m(String))</tt> matches the
        calls <tt>t.m("hello")</tt> and <tt>s.m("hello")</tt>.
        It does not match the call <tt>p.m("hello")</tt> since the
        signature pattern does not match any signature for the call join point
        of m in P.</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="annotations"></a>Chapter 2. Annotations</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#annotations-inJava5">Annotations in Java 5</a></dt><dd><dl><dt><a href="#d0e578">Using Annotations</a></dt><dt><a href="#d0e624">Retention Policies</a></dt><dt><a href="#d0e659">Accessing Annotations at Runtime</a></dt><dt><a href="#d0e694">Annotation Inheritance</a></dt></dl></dd><dt><a href="#annotations-aspectmembers">Annotating Aspects</a></dt><dt><a href="#annotations-pointcuts-and-advice">Join Point Matching based on Annotations</a></dt><dd><dl><dt><a href="#d0e782">Annotation Patterns</a></dt><dt><a href="#d0e867">Type Patterns</a></dt><dt><a href="#signaturePatterns">Signature Patterns</a></dt><dt><a href="#d0e1121">Example Pointcuts</a></dt><dt><a href="#d0e1194">Runtime type matching and context exposure</a></dt><dt><a href="#d0e1421">Package and Parameter Annotations</a></dt><dt><a href="#d0e1431">Annotation Inheritance and pointcut matching</a></dt><dt><a href="#d0e1463">Limitations</a></dt></dl></dd><dt><a href="#annotations-decp">Using Annotations with declare statements</a></dt><dd><dl><dt><a href="#d0e1478">Declare error and declare warning</a></dt><dt><a href="#d0e1493">declare parents</a></dt><dt><a href="#d0e1541">declare precedence</a></dt></dl></dd><dt><a href="#annotations-declare">Declare Annotation</a></dt><dt><a href="#annotations-itds">Inter-type Declarations</a></dt></dl></div><div class="sect1"><a name="annotations-inJava5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="annotations-inJava5"></a>Annotations in Java 5</h2></div></div><p>
		This section provides the essential information about annotations in
		Java 5 needed to understand how annotations are treated in AspectJ 5.
		For a full introduction to annotations in Java, please see the
		documentation for the Java 5 SDK.
	</p><div class="sect2"><a name="d0e578"></a><div class="titlepage"><div><h3 class="title"><a name="d0e578"></a>Using Annotations</h3></div></div><p>
	      Java 5 introduces <span class="emphasis"><i>annotation types</i></span> which can
	      be used to express metadata relating to program members in the
	      form of <span class="emphasis"><i>annotations</i></span>. Annotations in Java 5 
	      can be applied to package and type declarations (classes,
	      interfaces, enums, and annotations), constructors, methods, 
	      fields, parameters, and variables. Annotations are specified in the
	      program source by using the <tt>@</tt> symbol. For example,
	      the following piece of code uses the <tt>@Deprecated</tt>
	      annotation to indicate that the <tt>obsoleteMethod()</tt>
	      has been deprecated:
	    </p><pre class="programlisting">
		@Deprecated
		public void obsoleteMethod() { ... }
		</pre><p>
			Annotations may be <span class="emphasis"><i>marker annotations</i></span>,
			<span class="emphasis"><i>single-valued annotations</i></span>, or 
			<span class="emphasis"><i>multi-valued annotations</i></span>.
			Annotation types with no members or that provide default values
			for all members may be used simply as marker annotations, as in
			the deprecation example above. Single-value annotation types have
			a single member, and the annotation may be written in one of
			two equivalent forms:
		</p><pre class="programlisting">
		@SuppressWarnings({"unchecked"})
		public void someMethod() {...}
		</pre><p>
			or
		</p><pre class="programlisting">
		@SuppressWarnings(value={"unchecked"})
		public void someMethod() {...}
		</pre><p>
			Multi-value annotations must use the <tt>member-name=value
			</tt> syntax to specify annotation values. For example:
		</p><pre class="programlisting">
		@Authenticated(role="supervisor",clearanceLevel=5)
		public void someMethod() {...}
		</pre></div><div class="sect2"><a name="d0e624"></a><div class="titlepage"><div><h3 class="title"><a name="d0e624"></a>Retention Policies</h3></div></div><p>
	      Annotations can have one of three retention policies:
	    </p><div class="variablelist"><dl><dt><a name="d0e630"></a><span class="term">Source-file retention</span></dt><dd><p><a name="d0e633"></a>
	            	Annotations with source-file retention are read by the 
	            	compiler during the compilation process, but are not
	            	rendered in the generated <tt>.class</tt> files.
	            </p></dd><dt><a name="d0e639"></a><span class="term">Class-file retention</span></dt><dd><p><a name="d0e642"></a>
	        			This is the default retention policy. Annotations
	        			with class-file retention are read by the compiler
	        			and also retained in the generated <tt>
	        			.class</tt> files.
	        		</p></dd><dt><a name="d0e648"></a><span class="term">Runtime retention</span></dt><dd><p><a name="d0e651"></a>
	        			Annotations with runtime retention are read by the
	        			compiler, retained in the generated <tt>
	        			.class</tt> files, and also made available
	        			at runtime.
	        		</p></dd></dl></div><p>Local variable annotations are not retained in class files (or at runtime)
	    regardless of the retention policy set on the annotation type. See JLS 9.6.1.2.</p></div><div class="sect2"><a name="d0e659"></a><div class="titlepage"><div><h3 class="title"><a name="d0e659"></a>Accessing Annotations at Runtime</h3></div></div><p>
    		Java 5 supports a new interface, 
    		<tt>java.lang.reflect.AnnotatedElement</tt>, that is
    		implemented by the reflection classes in Java (<tt>Class</tt>, 
    		<tt>Constructor</tt>,
    		<tt>Field</tt>, <tt>Method</tt>, and 
    		<tt>Package</tt>). This interface gives you access
    		to annotations <span class="emphasis"><i>that have runtime retention</i></span> via
    		the <tt>getAnnotation</tt>, <tt>getAnnotations</tt>, 
    		and <tt>isAnnotationPresent</tt>. Because annotation types are
    		just regular Java classes, the annotations returned by these methods
    		can be queried just like any regular Java object.
    	</p></div><div class="sect2"><a name="d0e694"></a><div class="titlepage"><div><h3 class="title"><a name="d0e694"></a>Annotation Inheritance</h3></div></div><p>
    		It is important to understand the rules relating to inheritance of
    		annotations, as these have a bearing on join point matching
    		based on the presence or absence of annotations.
    	</p><p>
    		By default annotations are <span class="emphasis"><i>not</i></span> inherited. Given
    		the following program
    	</p><pre class="programlisting">
			@MyAnnotation
			class Super {
			  @Oneway public void foo() {}
			}
			
			class Sub extends Super {
			  public void foo() {}
			}
			</pre><p>
    		Then <tt>Sub</tt> <span class="emphasis"><i>does not</i></span> have
    		the <tt>MyAnnotation</tt> annotation, and 
    		<tt>Sub.foo()</tt> is not an <tt>@Oneway</tt>
    		method, despite the fact that it overrides 
    		<tt>Super.foo()</tt> which is.
    	</p><p>
    		If an annotation type has the meta-annotation <tt>@Inherited</tt>
    		then an annotation of that type on a <span class="emphasis"><i>class</i></span> will cause
    		the annotation to be inherited by sub-classes. So, in the example
    		above, if the <tt>MyAnnotation</tt> type had the
    		<tt>@Inherited</tt> attribute, then <tt>Sub</tt>
    		would have the <tt>MyAnnotation</tt> annotation.    		
    	</p><p>
    		<tt>@Inherited</tt> annotations are not inherited when used to
    		annotate anything other than a type. A type
    		that implements one or more interfaces never inherits any annotations from
    		the interfaces it implements.
    	</p></div></div><div class="sect1"><a name="annotations-aspectmembers"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="annotations-aspectmembers"></a>Annotating Aspects</h2></div></div><p>
    	AspectJ 5 supports annotations on aspects, and on method, field,
    	constructor, advice, and inter-type declarations within aspects. 
    	Method and advice parameters may also be annotated.
    	Annotations are not permitted on pointcut declarations or on 
    	<tt>declare</tt> statements.
    </p><p>
    	The following example illustrates the use of annotations in aspects:
    </p><pre class="programlisting">
		@AspectAnnotation
		public abstract aspect ObserverProtocol {
		
			@InterfaceAnnotation
			interface Observer {}		
		
			@InterfaceAnnotation
			interface Subject {}
		
			@ITDFieldAnnotation
			private List&lt;Observer&gt; Subject.observers;  
				
			@ITDMethodAnnotation
			public void Subject.addObserver(Observer o) { 
			  observers.add(o);
			}
			
			@ITDMethodAnnotation
			public void Subject.removeObserver(Observer o) {
			  observers.remove(o);
			}
			
			@MethodAnnotation
			private void notifyObservers(Subject subject) {
			  for(Observer o : subject.observers) 
			    notifyObserver(o,subject);
			}
			
			/**
			 * Delegate to concrete sub-aspect the actual form of
			 * notification for a given type of Observer.
			 */
			@MethodAnnotation
			protected abstract void notifyObserver(Observer o, Subject s);
			
			/* no annotations on pointcuts */
			protected abstract pointcut observedEvent(Subject subject);
			
			@AdviceAnnotation
			after(Subject subject) returning : observedEvent(subject) {
				notifyObservers(subject);  
			} 
		}
	</pre><p>
    An annotation on an aspect will be inherited by sub-aspects, iff it has
    the <tt>@Inherited</tt> meta-annotation.
    </p><p>
        AspectJ 5 supports a new XLint warning, "the pointcut associated with this
        advice does not match any join points". The warning is enabled by default and
        will be emitted by the compiler if the pointcut expression associated with an 
        advice statement can be statically determined to not match any join points. The
        warning can be suppressed for an individual advice statement by using the 
        <tt>@SuppressAjWarnings({"adviceDidNotMatch"})</tt> annotation. This works in
        the same way as the Java 5 SuppressWarnings annotation (See JLS 9.6.1.5), but has class file
        retention.
    </p><pre class="programlisting">
	    import org.aspectj.lang.annotation.SuppressAjWarnings;
	    
	    public aspect AnAspect {
		
	      pointcut anInterfaceOperation() : execution(* AnInterface.*(..));
		  
		  
	      @SuppressAjWarnings // may not match if there are no implementers of the interface...
	      before() : anInterfaceOperation() {
	         // do something...
	      }		
		  
	      @SuppressAjWarnings("adviceDidNotMatch") // alternate form
	      after() returning : anInterfaceOperation() {
	         // do something...
	      }
	    }
	</pre></div><div class="sect1"><a name="annotations-pointcuts-and-advice"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="annotations-pointcuts-and-advice"></a>Join Point Matching based on Annotations</h2></div></div><p>
  	This section discusses changes to type pattern and signature pattern matching in
  	AspectJ 5 that support matching join points based on the presence or absence of
  	annotations. We then discuss means of exposing annotation values within the body
  	of advice.
  </p><div class="sect2"><a name="d0e782"></a><div class="titlepage"><div><h3 class="title"><a name="d0e782"></a>Annotation Patterns</h3></div></div><p>
          For any kind of annotated element (type, method, constructor, package, etc.), 
          an annotation pattern can be used to match against the set of annotations
          on the annotated element. Annotation patterns are defined by the following
          grammar.
      </p><pre class="programlisting">
		AnnotationPattern := '!'? '@' AnnotationTypePattern AnnotationPattern* 
        
		AnnotationTypePattern := FullyQualifiedName |
		                         '(' TypePattern ')'
  		                     
  		FullyQualifiedName := JavaIdentifierCharacter+ ('.' JavaIdentifierCharacter+)*  		
      </pre><p>In simple terms, an annotation pattern element has one of two basic
      forms:</p><div class="itemizedlist"><ul><li><a name="d0e792"></a>@&lt;qualified-name&gt;, for example, @Foo, or 
          @org.xyz.Foo.</li><li><a name="d0e794"></a>@(&lt;type-pattern&gt;), for example, @(org.xyz..*), or
          @(Foo || Boo)</li></ul></div><p>These simple elements may be negated using <tt>!</tt>, and
      combined by simple concatentation. The pattern <tt>@Foo @Boo</tt>
      matches an annotated element that has both an annotation of type <tt>Foo</tt>
      and an annotation of type <tt>Boo</tt>.</p><p>Some examples of annotation patterns follow:</p><div class="variablelist"><dl><dt><a name="d0e813"></a><span class="term">@Immutable</span></dt><dd><p><a name="d0e816"></a>
            	Matches any annotated element which has an annotation of 
      			type <tt>Immutable</tt>.
            </p></dd><dt><a name="d0e822"></a><span class="term">!@Persistent</span></dt><dd><p><a name="d0e825"></a>
				Matches any annotated element which does not have an annotation of 
      			type <tt>Persistent</tt>.
            </p></dd><dt><a name="d0e831"></a><span class="term">@Foo @Goo</span></dt><dd><p><a name="d0e834"></a>
				Matches any annotated element which has both an annotation of type <tt>Foo</tt> and
      			an annotation of type <tt>Goo</tt>.
            </p></dd><dt><a name="d0e843"></a><span class="term">@(Foo || Goo)</span></dt><dd><p><a name="d0e846"></a>
				  Matches any annotated element which has either an annotation of a type matching
			      the type pattern <tt>(Foo || Goo)</tt>. 
			      In other words, an annotated element with either an
			      annotation of type <tt>Foo</tt> or
			      an annotation of type <tt>Goo</tt> (or both). (The parenthesis are required in this example).
            </p></dd><dt><a name="d0e858"></a><span class="term">@(org.xyz..*)</span></dt><dd><p><a name="d0e861"></a>
		      Matches any annotated element which has either an annotation of a type matching
		      the type pattern <tt>(org.xyz..*)</tt>. 
		      In other words, an annotated element with an annotation that is declared in the
		      org.xyz package or a sub-package. (The parenthesis are required in this example).
            </p></dd></dl></div></div><div class="sect2"><a name="d0e867"></a><div class="titlepage"><div><h3 class="title"><a name="d0e867"></a>Type Patterns</h3></div></div><p>AspectJ 1.5 extends type patterns to allow an optional <tt>AnnotationPattern</tt>
	prefix. (Extensions to this definition for generics are shown in the next chapter).</p><pre class="programlisting">
  	  	TypePattern := SimpleTypePattern |
  	  	               '!' TypePattern |
  	  	               '(' AnnotationPattern? TypePattern ')'
  	  	               TypePattern '&amp;&amp;' TypePattern |
  	  	               TypePattern '||' TypePattern 
  	  	
  	  	SimpleTypePattern := DottedNamePattern '+'? '[]'*
  	  	
  		DottedNamePattern := FullyQualifiedName RestOfNamePattern? |
  		                     '*' NotStarNamePattern?
  		
  		RestOfNamePattern := '..' DottedNamePattern |
  		                     '*' NotStarNamePattern?
  		                     
  		NotStarNamePattern := FullyQualifiedName RestOfNamePattern? |
  		                      '..' DottedNamePattern               

  		FullyQualifiedName := JavaIdentifierCharacter+ ('.' JavaIdentifierCharacter+)*  				  		  		  		               									 				  		             
	</pre><p>Note that in most cases when annotations are used as part of a type pattern,
        the parenthesis are required (as in <tt>(@Foo Hello+)</tt>). In
        some cases (such as a type pattern used within a <tt>this</tt>
        pointcut expression, the parenthesis are optional:</p><pre class="programlisting">
        OptionalParensTypePattern := AnnotationPattern? TypePattern
      </pre><p>
		The following examples illustrate the use of annotations in type
		patterns:
	</p><div class="variablelist"><dl><dt><a name="d0e890"></a><span class="term">(@Immutable *)</span></dt><dd><p><a name="d0e893"></a>
            	Matches any type with an <tt>@Immutable</tt> annotation.
            </p></dd><dt><a name="d0e899"></a><span class="term">(!@Immutable *)</span></dt><dd><p><a name="d0e902"></a>
            	Matches any type which does not have an <tt>@Immutable</tt> annotation.
            </p></dd><dt><a name="d0e908"></a><span class="term">  (@Immutable (org.xyz.* || org.abc.*))</span></dt><dd><p><a name="d0e911"></a>
            	Matches any type in the <tt>org.xyz</tt> or <tt>org.abc</tt>
 			    packages with the <tt>@Immutable</tt> annotation.
            </p></dd><dt><a name="d0e923"></a><span class="term">((@Immutable Foo+) || Goo)</span></dt><dd><p><a name="d0e926"></a>
            	Matches a type <tt>Foo</tt> or any of its subtypes, which have the <tt>@Immutable</tt>
     			annotation, or a type <tt>Goo</tt>.
            </p></dd><dt><a name="d0e938"></a><span class="term">((@(Immutable || NonPersistent) org.xyz..*)</span></dt><dd><p><a name="d0e941"></a>
            	Matches any type in a package beginning with the prefix <tt>org.xyz</tt>,
     			which has either the <tt>@Immutable</tt> annotation or the
     			<tt>@NonPersistent</tt> annotation.            	
            </p></dd><dt><a name="d0e953"></a><span class="term">(@Immutable @NonPersistent org.xyz..*)</span></dt><dd><p><a name="d0e956"></a>
            	 Matches any type in a package beginning with the prefix <tt>org.xyz</tt>,
			     which has both an <tt>@Immutable</tt> annotation and an
			     <tt>@NonPersistent</tt> annotation.
            </p></dd><dt><a name="d0e968"></a><span class="term">  (@(@Inherited *) org.xyz..*)</span></dt><dd><p><a name="d0e971"></a>
            	Matches any type in a package beginning with the prefix <tt>org.xyz</tt>,
			     which has an inheritable annotation. The annotation pattern 
			     <tt>@(@Inherited *)</tt> matches any annotation of a type matching the
			     type pattern <tt>@Inherited *</tt>, which in turn matches any type with the
			     <tt>@Inherited</tt> annotation.
            </p></dd></dl></div></div><div class="sect2"><a name="signaturePatterns"></a><div class="titlepage"><div><h3 class="title"><a name="signaturePatterns"></a>Signature Patterns</h3></div></div><p>A <tt>FieldPattern</tt> is described by the following
  	grammar:</p><pre class="programlisting">  	
  		FieldPattern := 
  		    AnnotationPattern? FieldModifiersPattern? 
  		    TypePattern (TypePattern DotOrDotDot)? SimpleNamePattern

		FieldModifiersPattern := '!'? FieldModifier FieldModifiersPattern*
		                         		
		FieldModifier := 'public' | 'private' | 'protected' | 'static' | 
		                 'transient' | 'final' 

		DotOrDotDot := '.' | '..'		            		      
		            		      		            			
		SimpleNamePattern := JavaIdentifierChar+ ('*' SimpleNamePattern)?		            
	</pre><p>
  	    The optional <tt>AnnotationPattern</tt> restricts matches to fields with
  	    annotations that match the pattern. For example:
  	</p><div class="variablelist"><dl><dt><a name="d0e1002"></a><span class="term">@SensitiveData * *</span></dt><dd><p><a name="d0e1005"></a>
            	Matches a field of any type and any name, that has an annotation of
            	type <tt>@SensitiveData</tt>
            </p></dd><dt><a name="d0e1011"></a><span class="term">@SensitiveData List org.xyz..*.*</span></dt><dd><p><a name="d0e1014"></a>
            	Matches a member field of a type in a package with prefix <tt>org.xzy</tt>,
            	where the field is of type <tt>List</tt>, and has an annotation of type
            	<tt>@SensitiveData</tt>
            </p></dd><dt><a name="d0e1026"></a><span class="term">(@SensitiveData *) org.xyz..*.*</span></dt><dd><p><a name="d0e1029"></a>
            	Matches a member field of a type in a package with prefix <tt>org.xzy</tt>,
            	where the field is of a type which has a <tt>@SensitiveData</tt> annotation.
            </p></dd><dt><a name="d0e1038"></a><span class="term">@Foo (@Goo *) (@Hoo *).*</span></dt><dd><p><a name="d0e1041"></a>
            	Matches a field with an annotation <tt>@Foo</tt>, of a type with an 
            	annotation <tt>@Goo</tt>, declared in a type with annotation
            	<tt>@Hoo</tt>.
            </p></dd><dt><a name="d0e1053"></a><span class="term">@Persisted @Classified * *</span></dt><dd><p><a name="d0e1056"></a>
            	Matches a field with an annotation <tt>@Persisted</tt> and
            	an annotation <tt>@Classified</tt>.
            </p></dd></dl></div><p>A <tt>MethodPattern</tt> is of the form</p><pre class="programlisting">  	
  		MethodPattern := 
  		    AnnotationPattern? MethodModifiersPattern? TypePattern 
  		                       (TypePattern DotOrDotDot)? SimpleNamePattern 
  		                       '(' FormalsPattern ')'ThrowsPattern?

		MethodModifiersPattern := '!'? MethodModifier MethodModifiersPattern*
		
		MethodModifier := 'public' | 'private' | 'protected' | 'static' | 
		                  'synchronized' | 'final' 
		            		      
		FormalsPattern := '..' (',' FormalsPatternAfterDotDot)* |
		                  OptionalParensTypePattern (',' FormalsPattern)* |
		                  TypePattern '...'
		                  
		FormalsPatternAfterDotDot := 
		        OptionalParensTypePattern (',' FormalsPatternAfterDotDot)* |
		        TypePattern '...'
		                                               		                  
		ThrowsPattern := 'throws' TypePatternList
		
		TypePatternList := TypePattern (',' TypePattern)*
		            					            
	</pre><p><span class="emphasis"><i>Note: compared to the previous version, this definition of MethodPattern does
  	not allow parameter annotation matching (only matching on annotations of parameter types).</i></span></p><p>A <tt>ConstructorPattern</tt> has the form</p><pre class="programlisting">  	
  		ConstructorPattern := 
  		    AnnotationPattern? ConstructorModifiersPattern?  
  		                       (TypePattern DotOrDotDot)? 'new' '(' FormalsPattern ')'
  		                       ThrowsPattern?
	
		ConstructorModifiersPattern := '!'? ConstructorModifier ConstructorModifiersPattern*
		
		ConstructorModifier := 'public' | 'private' | 'protected'
		
	</pre><p>
  	    The optional <tt>AnnotationPattern</tt> at the beginning of a 
  	    method or constructor pattern restricts matches to methods/constructors with
  	    annotations that match the pattern. For example:
  	</p><div class="variablelist"><dl><dt><a name="d0e1088"></a><span class="term">@Oneway * *(..)</span></dt><dd><p><a name="d0e1091"></a>
            	Matches a method with any return type and any name, that has an annotation of
            	type <tt>@Oneway</tt>.
            </p></dd><dt><a name="d0e1097"></a><span class="term">@Transaction * (@Persistent org.xyz..*).*(..)</span></dt><dd><p><a name="d0e1100"></a>
            	Matches a method with the <tt>@Transaction</tt> annotation,
            	declared in a type with the <tt>@Persistent</tt> annotation, and
            	in a package beginning with the <tt>org.xyz</tt> prefix.
            </p></dd><dt><a name="d0e1112"></a><span class="term">* *.*(@Immutable *,..)</span></dt><dd><p><a name="d0e1115"></a>
            	Matches any method taking at least one parameter, where the parameter
            	type has an annotation <tt>@Immutable</tt>.
            </p></dd></dl></div></div><div class="sect2"><a name="d0e1121"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1121"></a>Example Pointcuts</h3></div></div><div class="variablelist"><dl><dt><a name="d0e1125"></a><span class="term">within(@Secure *)</span></dt><dd><p><a name="d0e1128"></a>
            	Matches any join point where the code executing is declared in a 
            	type with an <tt>@Secure</tt>
            	annotation. The format of the <tt>within</tt> pointcut designator
            	in AspectJ 5 is <tt>'within' '(' OptionalParensTypePattern ')'</tt>.
            </p></dd><dt><a name="d0e1140"></a><span class="term">staticinitialization(@Persistent *)</span></dt><dd><p><a name="d0e1143"></a>
            	Matches the staticinitialization join point of any type with the
            	<tt>@Persistent</tt> annotation. The format of the 
            	<tt>staticinitialization</tt> pointcut designator
            	in AspectJ 5 is <tt>'staticinitialization' '(' OptionalParensTypePattern ')'</tt>.
            </p></dd><dt><a name="d0e1155"></a><span class="term">call(@Oneway * *(..))</span></dt><dd><p><a name="d0e1158"></a>
            	Matches a call to a method with a <tt>@Oneway</tt> annotation.
            </p></dd><dt><a name="d0e1164"></a><span class="term">execution(public (@Immutable *) org.xyz..*.*(..))</span></dt><dd><p><a name="d0e1167"></a>
                The execution of any public method in a package with prefix 
                <tt>org.xyz</tt>, where the method returns an 
                immutable result.
            </p></dd><dt><a name="d0e1173"></a><span class="term">set(@Cachable * *)</span></dt><dd><p><a name="d0e1176"></a>
                Matches the set of any cachable field.
            </p></dd><dt><a name="d0e1179"></a><span class="term">handler(!@Catastrophic *)</span></dt><dd><p><a name="d0e1182"></a>
                Matches the handler join point for the handling of any exception that is
                not <tt>Catastrophic</tt>. The format of the <tt>handler</tt>
                pointcut designator in AspectJ 5 is <tt>'handler' '(' OptionalParensTypePattern ')'</tt>.
            </p></dd></dl></div></div><div class="sect2"><a name="d0e1194"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1194"></a>Runtime type matching and context exposure</h3></div></div><p>AspectJ 5 supports a set of "@" pointcut designators which
    can be used both to match based on the presence of an annotation at
    runtime, and to expose the annotation value as context in a pointcut or
    advice definition. These designators are <tt>@args, @this, @target,
    @within, @withincode</tt>, and <tt>@annotation</tt>
    </p><p>It is a compilation error to attempt to match on an annotation type 
    that does not have runtime retention using <tt>@this, @target</tt>
    or <tt>@args</tt>. It is a compilation error to attempt to use
    any of these designators to expose an annotation value that does not
    have runtime retention.</p><p>
        The <tt>this()</tt>, <tt>target()</tt>, and
        <tt>args()</tt> pointcut designators allow matching based
        on the runtime type of an object, as opposed to the statically 
        declared type. In AspectJ 5, these designators are supplemented
        with three new designators : <tt>@this()</tt> (read, "this
        annotation"), <tt>@target()</tt>, and <tt>@args()</tt>.    
    </p><p>
        Like their counterparts, these pointcut designators can be used 
        both for join point matching, and to expose context. The format of 
        these new designators is:
    </p><pre class="programlisting">  	
  	    AtThis := '@this' '(' AnnotationOrIdentifer ')'
    
  	    AtTarget := '@target' '(' AnnotationOrIdentifier ')'
  	
  	    AnnotationOrIdentifier := FullyQualifiedName | Identifier
        
  	    AtArgs := '@args' '(' AnnotationsOrIdentifiersPattern ')'
        
  	    AnnotationsOrIdentifiersPattern :=
  	                      '..' (',' AnnotationsOrIdentifiersPatternAfterDotDot)? |
  	                      AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPattern)* |
  	                      '*' (',' AnnotationsOrIdentifiersPattern)*
		                  
  	    AnnotationsOrIdentifiersPatternAfterDotDot := 
		                  AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPatternAfterDotDot)* |
		                  '*' (',' AnnotationsOrIdentifiersPatternAfterDotDot)*
  	
	</pre><p>
        The forms of <tt>@this()</tt> and <tt>@target()</tt> that
        take a single annotation name are analogous to their counterparts that take
        a single type name. They match at join points where the object bound to 
        <tt>this</tt> (or <tt>target</tt>, respectively) has an
        annotation of the specified type. For example: 
    </p><div class="variablelist"><dl><dt><a name="d0e1252"></a><span class="term">@this(Foo)</span></dt><dd><p><a name="d0e1255"></a>
            	Matches any join point where the object currently bound to 'this'
            	has an annotation of type <tt>Foo</tt>.
            </p></dd><dt><a name="d0e1261"></a><span class="term">call(* *(..)) &amp;&amp; @target(Classified)</span></dt><dd><p><a name="d0e1264"></a>
            	Matches a call to any object where the target of the call has
            	a <tt>@Classified</tt> annotation.
            </p></dd></dl></div><p>
        Annotations can be exposed as context in the body of advice by 
        using the forms of <tt>@this(), @target()</tt> and
        <tt>@args()</tt> that use bound variables in the place
        of annotation names. For example:
    </p><pre class="programlisting">
  	pointcut callToClassifiedObject(Classified classificationInfo) :
  	    call(* *(..)) &amp;&amp; @target(classificationInfo);

  	pointcut txRequiredMethod(Tx transactionAnnotation) :
  	    execution(* *(..)) &amp;&amp; @this(transactionAnnotation) 
  	    &amp;&amp; if(transactionAnnotation.policy() == TxPolicy.REQUIRED);
	</pre><p>
        The <tt>@args</tt> pointcut designator behaves as its <tt>args</tt>
        counterpart, matching join points based on number and position of arguments, and 
        supporting the <tt>*</tt> wildcard and at most one <tt>..</tt>
        wildcard. An annotation at a given position in an <tt>@args</tt> expression
        indicates that the runtime type of the argument in that position at a join point must
        have an annotation of the indicated type. For example:
    </p><pre class="programlisting">
  	/**
  	 * matches any join point with at least one argument, and where the
  	 * type of the first argument has the @Classified annotation
  	 */
  	pointcut classifiedArgument() : @args(Classified,..);
  	
  	/**
  	 * matches any join point with three arguments, where the third
  	 * argument has an annotation of type @Untrusted.
  	 */
  	pointcut untrustedData(Untrusted untrustedDataSource) : 
  	    @args(*,*,untrustedDataSource);
	</pre><p>
        <span class="emphasis"><i>Note: an alternative design would be to allow both annotation
        patterns and type patterns to be specified in the existing args pcd.
        This works well for matching, but is more awkward when it comes to
        exposing context.</i></span>
    </p><p>Access to <tt>AnnotatedElement</tt> information is available
    reflectively with the body of advice through the <tt>thisJoinPoint</tt>,
    <tt>thisJoinPointStaticPart</tt>, and 
    <tt>thisEnclosingJoinPointStaticPart</tt> variables. To access 
    annotations on the arguments, or object bound to this or target at a join
    point you can use the following code fragments:</p><pre class="programlisting">
  	Annotation[] thisAnnotations = thisJoinPoint.getThis().getClass().getAnnotations();
  	Annotation[] targetAnnotations = thisJoinPoint.getTarget().getClass().getAnnotations();
  	Annotation[] firstParamAnnotations = thisJoinPoint.getArgs()[0].getClass().getAnnotations();
	</pre><p>
        <span class="emphasis"><i>Note: it would be nicer to provide direct helper methods in
        the JoinPoint interface or a sub-interface that provide the annotations
        directly, something like "AnnotatedElement getThisAnnotationInfo()".
        The problem here is that the "AnnotatedElement" type is only in the
        Java 5 runtime libraries, and we don't want to tie the AspectJ runtime
        library to Java 5. A sub-interface and downcast solution could be used
        if these helpers were felt to be sufficiently important.</i></span>
    </p><p>
    The <tt>@within</tt> and <tt>@withincode</tt> pointcut designators
    match any join point where the executing code is defined within a type (<tt>@within</tt>),
     or a method/constructor (<tt>@withincode</tt>) that has an annotation of the specified 
    type. The form of these designators is:
    </p><pre class="programlisting">  	
        AtWithin := '@within' '(' AnnotationOrIdentifier ')'
        AtWithinCode := '@withincode' '(' AnnotationOrIdentifier ')'        
    </pre><p>Some examples of using these designators follow:</p><div class="variablelist"><dl><dt><a name="d0e1344"></a><span class="term">@within(Foo)</span></dt><dd><p><a name="d0e1347"></a>
            	Matches any join point where the executing code is defined 
            	within a type which has an annotation of type <tt>Foo</tt>.
            </p></dd><dt><a name="d0e1353"></a><span class="term">pointcut insideCriticalMethod(Critical c) : 
                  @withincode(c);</span></dt><dd><p><a name="d0e1356"></a>
            	Matches any join point where the executing code is defined
            	in a method or constructor which has an annotation of type <tt>@Critical</tt>,
            	and exposes the value of the annotation in the parameter 
            	<tt>c</tt>.
            </p></dd></dl></div><p>The <tt>@annotation</tt> pointcut designator matches any
    join point where the <span class="emphasis"><i>subject</i></span> of the join point has 
    an annotation of the given type. Like the other @pcds, it can also be
    used for context exposure.</p><pre class="programlisting">  	
        AtAnnotation := '@annotation' '(' AnnotationOrIdentifier ')'
    </pre><p>The subject of a join point is defined in the table in chapter one of
    this guide.</p><p>
      Access to annotation information on members at a matched join point is also available
      through the <tt>getSignature</tt> method of the <tt>JoinPoint</tt>
      and <tt>JoinPoint.StaticPart</tt> interfaces. The <tt>Signature</tt>
      interfaces are extended with additional operations that provide access to the  
      <tt>java.lang.reflect</tt> <tt>Method, Field</tt> and 
      <tt>Constructor</tt> objects on which annnotations can be queried. The following fragment
      illustrates an example use of this interface to access annotation information.
    </p><pre class="programlisting">
  	Signature sig = thisJoinPointStaticPart.getSignature();
  	AnnotatedElement declaringTypeAnnotationInfo = sig.getDeclaringType();
  	if (sig instanceof MethodSignature) {
  	  // this must be a call or execution join point
  	  Method method = ((MethodSignature)sig).getMethod();
  	}
	</pre><p>
        <span class="emphasis"><i>Note again that it would be nicer to add the method getAnnotationInfo
        directly to MemberSignature, but this would once more couple the runtime library
        to Java 5.</i></span>
    </p><p>
        The <tt>@this,@target</tt> and <tt>@args</tt> 
        pointcut designators can only be used to match against annotations 
        that have runtime retention. The <tt>@within, @withincode</tt>
        and <tt>@annotation</tt> pointcut designators can only be used
        to match against annotations that have at least class-file retention, and
        if used in the binding form the annotation must have runtime retention. 
    </p></div><div class="sect2"><a name="d0e1421"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1421"></a>Package and Parameter Annotations</h3></div></div><p>
          <span class="emphasis"><i>Note: A previous design allowed package annotation patterns to be specified
          directly in type patterns, and parameter annotation patterns to be
          specified directly in method and constructor signature patterns. Because
          this made some pointcut expressions hard to read and understand, we moved
          in favour of the design presented below, which also has its drawbacks. 
          Matching on package and parameter annotations will be
          deferred until after the 1.5.0 release so that we can gain more understanding
          of the kinds of uses AspectJ users are making of annotations in pointcut
          expressions before commiting to any one approach.</i></span>
      </p></div><div class="sect2"><a name="d0e1431"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1431"></a>Annotation Inheritance and pointcut matching</h3></div></div><p>
  	    According to the Java 5 specification, non-type annotations are not
  	    inherited, and annotations on types are only inherited if they have the 
  	    <tt>@Inherited</tt> meta-annotation.
  	    
  	    Given the following program:
  	</p><pre class="programlisting">
  	class C1 {
  	  @SomeAnnotation
  	  public void aMethod() {...}
  	}
  	
  	class C2 extends C1 {
  	  public void aMethod() {...}
  	}
  	
  	class Main {
  	  public static void main(String[] args) {
  	    C1 c1 = new C1();
  	    C2 c2 = new C2();
  	    c1.aMethod();
  	    c2.aMethod();
  	  }
  	}
  	
  	aspect X {
  	
  	  pointcut annotatedMethodCall() : 
  	    call(@SomeAnnotation * C1.aMethod());
  	
  	  pointcut c1MethodCall() :
  	    call(* C1.aMethod());
  	}
	</pre><p>
  	    The pointcut <tt>annotatedMethodCall</tt> will match the call
  	    to <tt>c1.aMethod()</tt>, but not the call to 
  	    <tt>c2.aMethod()</tt>.
  	</p><p>
  	    The pointcut <tt>c1MethodCall</tt> matches both 
  	    <tt>c1.aMethod()</tt> and <tt>c2.aMethod()</tt>.
  	</p></div><div class="sect2"><a name="d0e1463"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1463"></a>Limitations</h3></div></div><p>
        It would be useful to be able to match join points based on  
        annotation values, rather than merely the presence of a
        class-file retention annotation of a given type. This facility may be supported in a future version of AspectJ, by expanding the
        definition of <tt>AnnotationPattern</tt>. Matching annotation values for
        annotations with runtime retention can be done by exposing the annotation value
        as a pointcut parameter and then using an <tt>if</tt> pointcut expression
        to test the value. 
    </p></div></div><div class="sect1"><a name="annotations-decp"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="annotations-decp"></a>Using Annotations with declare statements</h2></div></div><div class="sect2"><a name="d0e1478"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1478"></a>Declare error and declare warning</h3></div></div><p>
  	    Since pointcut expressions in AspectJ 5 support join point matching based
  	    on annotations, this facility can be exploited when writing
  	    <tt>declare warning</tt> and <tt>declare error</tt>
  	    statements. For example:
  	</p><pre class="programlisting">
  	declare warning : withincode(@PerformanceCritical * *(..)) &amp;&amp;
  	                  call(@ExpensiveOperation * *(..))
  	                : "Expensive operation called from within performance critical section";
	</pre><pre class="programlisting">
  	declare error : call(* org.xyz.model.*.*(..)) &amp;&amp;
  	                !@within(Trusted)
  	                : "Untrusted code should not call the model classes directly";
	</pre></div><div class="sect2"><a name="d0e1493"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1493"></a>declare parents</h3></div></div><p>
  		The general form of a <tt>declare parents</tt> statement is:
  	</p><pre class="programlisting">
  	declare parents : TypePattern extends Type;
  	declare parents : TypePattern implements TypeList;
	</pre><p>
		Since AspectJ 5 supports annotations as part of a type pattern
		specification, it is now possible to match types based on the presence
		of annotations <span class="emphasis"><i>with either class-file or runtime retention</i></span>.
		For example:
	</p><div class="variablelist"><dl><dt><a name="d0e1509"></a><span class="term">declare parents : (@Secured *) implements SecuredObject;</span></dt><dd><p><a name="d0e1512"></a>
	            	All types with the <tt>@Secured</tt> annotation
	            	implement the <tt>SecuredObject</tt> inteface.
	            </p></dd><dt><a name="d0e1521"></a><span class="term">declare parents : (@Secured BankAccount+) implements SecuredObject;</span></dt><dd><p><a name="d0e1524"></a>
	            	The subset of types drawn from the <tt>BankAccount</tt> type and any subtype of
	            	<tt>BankAccount</tt>, where the 
	            	<tt>@Secured</tt> annotation is present, implement the
	            	<tt>SecuredObject</tt> interface.
	            </p></dd></dl></div><p>An annotation type may not be used as the target of a declare parents
    statement. If an annotation type is named explicitly as the target of a
    declare parents statement, a compilation error will result. If an annotation
    type is matched by a non-explicit type pattern used in a declare parents
    statement it will be ignored (and an XLint warning issued).</p></div><div class="sect2"><a name="d0e1541"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1541"></a>declare precedence</h3></div></div><p>
		The general form of a declare precedence statement is:
	</p><pre class="programlisting">
  	declare precedence : TypePatList;
	</pre><p>
		AspectJ 5 allows the type patterns in the list to include annotation information
		as part of the pattern specification. For example:
	</p><div class="variablelist"><dl><dt><a name="d0e1551"></a><span class="term">declare precedence : (@Security *),*;</span></dt><dd><p><a name="d0e1554"></a>
            	All aspects with the <tt>@Security</tt> annotation
            	take precedence over any other aspects in the system. (Or, more
            	informally, all security-related aspects take precedence).
            </p></dd></dl></div></div></div><div class="sect1"><a name="annotations-declare"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="annotations-declare"></a>Declare Annotation</h2></div></div><p>AspectJ 5 supports a new kind of declare statement, <tt>declare annotation</tt>.
      This takes different forms according to the recipient of the annotation: 
      <tt>declare @type</tt> for types, <tt>declare @method</tt> for methods,
      <tt>declare @constructor</tt> for constructors, and <tt>declare @field</tt>
      for fields. <tt>declare @package</tt> may be supported in a future release.
      </p><p>The general form is:</p><pre class="programlisting">
  	declare @&lt;kind&gt; : ElementPattern : Annotation ;
	</pre><p>Where annotation is a regular annotation expression as defined in the Java 5 language. If the annotation has 
    the <tt>@Target</tt> meta-annotation, then the elements matched by <tt>ElementPattern</tt>
    must be of the kind specified by the <tt>@Target</tt> annotation.</p><p><tt>ElementPattern</tt> is defined as follows:</p><pre class="programlisting">
  	        ElementPattern := TypePattern |
  	                          MethodPattern |
  	                          ConstructorPattern |
  	                          FieldPattern
	</pre><p>The following examples illustrate the use of <tt>declare annotation</tt>.</p><div class="variablelist"><dl><dt><a name="d0e1611"></a><span class="term">declare @type : org.xyz.model..* : @BusinessDomain ;</span></dt><dd><p><a name="d0e1614"></a>
                    All types defined in a package with the prefix <tt>org.xyz.model</tt>
                    have the <tt>@BusinessDomain</tt> annotation.
	            </p></dd><dt><a name="d0e1623"></a><span class="term">declare @method : public * BankAccount+.*(..) : @Secured(role="supervisor")</span></dt><dd><p><a name="d0e1626"></a>
	                All public methods in <tt>BankAccount</tt> and its subtypes have the
	                annotation <tt>@Secured(role="supervisor")</tt>.
	            </p></dd><dt><a name="d0e1635"></a><span class="term">declare @constructor : BankAccount+.new(..) : @Secured(role="supervisor")</span></dt><dd><p><a name="d0e1638"></a>
	                All constructors in <tt>BankAccount</tt> and its subtypes have the
	                annotation <tt>@Secured(role="supervisor")</tt>.
	            </p></dd><dt><a name="d0e1647"></a><span class="term">declare @field : * DAO+.* : @Persisted;</span></dt><dd><p><a name="d0e1650"></a>
	            	All fields defined in <tt>DAO</tt> or its subtypes have the
	            	<tt>@Persisted</tt> annotation.
	            </p></dd></dl></div></div><div class="sect1"><a name="annotations-itds"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="annotations-itds"></a>Inter-type Declarations</h2></div></div><p>An annotation type may not be the target of an inter-type declaration.</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="generics"></a>Chapter 3. Generics</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#generics-inJava5">Generics in Java 5</a></dt><dd><dl><dt><a href="#d0e1673">Declaring Generic Types</a></dt><dt><a href="#d0e1804">Using Generic and Parameterized Types</a></dt><dt><a href="#d0e1948">Subtypes, Supertypes, and Assignability</a></dt><dt><a href="#d0e2051">Generic Methods and Constructors</a></dt><dt><a href="#d0e2069">Erasure</a></dt></dl></dd><dt><a href="#generics-inAspectJ5">Generics in AspectJ 5</a></dt><dd><dl><dt><a href="#d0e2095">Matching generic and parameterized types in type patterns</a></dt><dt><a href="#d0e2295">Signature patterns</a></dt><dt><a href="#d0e2378">Pointcuts</a></dt><dt><a href="#d0e3065">Inter-type Declarations</a></dt><dt><a href="#d0e3186">Declare Parents</a></dt><dt><a href="#d0e3246">Declare Soft</a></dt><dt><a href="#d0e3254">Parameterized Aspects</a></dt></dl></dd></dl></div><div class="sect1"><a name="generics-inJava5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="generics-inJava5"></a>Generics in Java 5</h2></div></div><p>
		This section provides the essential information about generics in
		Java 5 needed to understand how generics are treated in AspectJ 5.
		For a full introduction to generics in Java, please see the
		documentation for the Java 5 SDK.
	</p><div class="sect2"><a name="d0e1673"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1673"></a>Declaring Generic Types</h3></div></div><p>
            A generic type is declared with one or more type parameters following the type name. 
            By convention formal type parameters are named using a single letter, though this is not required.  
            A simple generic list type
            (that can contain elements of any type <tt>E</tt>) could be declared:
        </p><pre class="programlisting">
		interface List&lt;E&gt; {
		   Iterator&lt;E&gt; iterator();
		   void add(E anItem);
		   E remove(E anItem);  
		}
		</pre><p>
            It is important to understand that unlike template mechanisms there will only be one type, and one class file, corresponding to 
            the <tt>List</tt> interface, regardless of how many different instantiations of the <tt>List</tt> interface a program
            has (each potentially providing a different value for the type parameter <tt>E</tt>). A consequence of this
            is that you cannot refer to the type parameters of a type declaration in a static method or initializer, or in the declaration or 
            initializer of a static variable. 
        </p><p>
             A <span class="emphasis"><i>parameterized type</i></span> 
            is an invocation of a generic type with concrete values supplied for
            all of its type parameters (for example, <tt>List&lt;String&gt;</tt> or <tt>List&lt;Food&gt;</tt>).
        </p><p>A generic type may be declared with multiple type parameters. In addition to simple type parameter names, type
        parameter declarations can also constrain the set of types allowed by using the <tt>extends</tt> 
        keyword. Some examples follow:</p><div class="variablelist"><dl><dt><a name="d0e1711"></a><span class="term">class Foo&lt;T&gt; {...}</span></dt><dd><p><a name="d0e1714"></a>A class <tt>Foo</tt> with one type parameter, <tt>T</tt>.
            </p></dd><dt><a name="d0e1723"></a><span class="term">class Foo&lt;T,S&gt; {...}</span></dt><dd><p><a name="d0e1726"></a>A class <tt>Foo</tt> with two type parameters, <tt>T</tt> and <tt>S</tt>.
            </p></dd><dt><a name="d0e1738"></a><span class="term">class Foo&lt;T extends Number&gt; {...}</span></dt><dd><p><a name="d0e1741"></a>A class <tt>Foo</tt> with one type parameter <tt>T</tt>, where <tt>T</tt> must be
            instantiated as the type <tt>Number</tt> or a subtype of <tt>Number</tt>.
            </p></dd><dt><a name="d0e1759"></a><span class="term">class Foo&lt;T, S extends T&gt; {...}</span></dt><dd><p><a name="d0e1762"></a>A class <tt>Foo</tt> with two type parameters, <tt>T</tt> and <tt>S</tt>. <tt>Foo</tt>
            must be instantiated with a type <tt>S</tt> that is a subtype of the type specified for parameter <tt>T</tt>.
            </p></dd><dt><a name="d0e1783"></a><span class="term">class Foo&lt;T extends Number &amp; Comparable&gt; {...}</span></dt><dd><p><a name="d0e1786"></a>A class <tt>Foo</tt> with one type parameter, <tt>T</tt>. <tt>Foo</tt>
            must be instantiated with a type that is a subtype of <tt>Number</tt> and that implements <tt>Comparable</tt>.
            </p></dd></dl></div></div><div class="sect2"><a name="d0e1804"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1804"></a>Using Generic and Parameterized Types</h3></div></div><p>You declare a variable (or a method/constructor argument) of a parameterized type  by specifying a concrete type specfication for each type parameter in
	        the generic type. The following example declares a list of strings and a list of numbers:</p><pre class="programlisting">
        List&lt;String&gt; strings;
        List&lt;Number&gt; numbers;
		</pre><p>It is also possible to declare a variable of a generic type without specifying any values for the type
	        parameters (a <span class="emphasis"><i>raw</i></span> type). For example, <tt>List strings</tt>. 
	        In this case, unchecked warnings may be issued by the compiler
	        when the referenced object is passed as a parameter to a method expecting a parameterized type such as a 
	        <tt>List&lt;String&gt;</tt>. New code written in the Java 5 language would not be expected to use
	        raw types.</p><p>Parameterized types are instantiated by specifying type parameter values in the constructor call expression as in
	    the following examples:</p><pre class="programlisting">
        List&lt;String&gt; strings = new MyListImpl&lt;String&gt;();
        List&lt;Number&gt; numbers = new MyListImpl&lt;Number&gt;();
		</pre><p>
	     When declaring parameterized types, the <tt>?</tt> wildcard may be used, which stands for "some type".
	     The <tt>extends</tt> and <tt>super</tt> keywords may be used in conjunction with the wildcard
	     to provide upper and lower bounds on the types that may satisfy the type constraints. For example:
	    </p><div class="variablelist"><dl><dt><a name="d0e1838"></a><span class="term">List&lt;?&gt;</span></dt><dd><p><a name="d0e1841"></a>A list containing elements of some type, the type of the elements in the list is unknown.
            </p></dd><dt><a name="d0e1844"></a><span class="term">List&lt;? extends Number&gt;</span></dt><dd><p><a name="d0e1847"></a>A list containing elements of some type that extends Number, the exact type of the elements in the list is unknown.
            </p></dd><dt><a name="d0e1850"></a><span class="term">List&lt;? super Double&gt;</span></dt><dd><p><a name="d0e1853"></a>A list containing elements of some type that is a super-type of Double, the exact type of the elements in the list is unknown.
            </p></dd></dl></div><p>
      	  A generic type may be extended as any other type. Given a generic type <tt>Foo&lt;T&gt;</tt> then
      	  a subtype <tt>Goo</tt> may be declared in one of the following ways:      	
      	</p><div class="variablelist"><dl><dt><a name="d0e1865"></a><span class="term">class Goo extends Foo</span></dt><dd><p><a name="d0e1868"></a>Here <tt>Foo</tt> is used as a raw type, and the appropriate warning messages will be
            issued by the compiler on attempting to invoke methods in <tt>Foo</tt>.
            </p></dd><dt><a name="d0e1877"></a><span class="term">class Goo&lt;E&gt; extends Foo</span></dt><dd><p><a name="d0e1880"></a><tt>Goo</tt> is a generic type, but the super-type <tt>Foo</tt> is used as a raw
            type and the appropriate warning messages will be
            issued by the compiler on attempting to invoke methods defined by <tt>Foo</tt>.            
            </p></dd><dt><a name="d0e1891"></a><span class="term">class Goo&lt;E&gt; extends Foo&lt;E&gt;</span></dt><dd><p><a name="d0e1894"></a>This is the most usual form. <tt>Goo</tt> is a generic type with one parameter that extends
            the generic type <tt>Foo</tt> with that same parameter. So <tt>Goo&lt;String&lt;</tt> is 
            a subclass of <tt>Foo&lt;String&gt;</tt>.
            </p></dd><dt><a name="d0e1909"></a><span class="term">class Goo&lt;E,F&gt; extends Foo&lt;E&gt;</span></dt><dd><p><a name="d0e1912"></a><tt>Goo</tt> is a generic type with two parameters that extends
            the generic type <tt>Foo</tt> with the first type parameter of <tt>Goo</tt> being used
            to parameterize <tt>Foo</tt>. So <tt>Goo&lt;String,Integer&lt;</tt> is 
            a subclass of <tt>Foo&lt;String&gt;</tt>.
            </p></dd><dt><a name="d0e1932"></a><span class="term">class Goo extends Foo&lt;String&gt;</span></dt><dd><p><a name="d0e1935"></a><tt>Goo</tt> is a type that extends
            the parameterized type <tt>Foo&lt;String&gt;</tt>.
            </p></dd></dl></div><p>A generic type may implement one or more generic interfaces, following the type binding
	    rules given above. A type may also implement one or more parameterized interfaces (for example,
	    <tt>class X implements List&lt;String&gt;</tt>, however a type may not at the same time
	    be a subtype of two interface types which are different parameterizations of the same interface.</p></div><div class="sect2"><a name="d0e1948"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1948"></a>Subtypes, Supertypes, and Assignability</h3></div></div><p>
	      The supertype of a generic type <tt>C</tt> is the type given in the extends clause of
	      <tt>C</tt>, or <tt>Object</tt> if no extends clause is present. Given the type declaration
	    </p><pre class="programlisting">
        public interface List&lt;E&gt; extends Collection&lt;E&gt; {... }
		</pre><p>
	      then the supertype of <tt>List&lt;E&gt;</tt> is <tt>Collection&lt;E&gt;</tt>.
	    </p><p>
	      The supertype of a parameterized type <tt>P</tt> is the type given in the extends clause of
	      <tt>P</tt>, or <tt>Object</tt> if no extends clause is present. Any type parameters in
	      the supertype are substituted in accordance with the parameterization of <tt>P</tt>. An example
	      will make this much clearer: Given the type <tt>List&lt;Double&gt;</tt> and the definition of
	      the <tt>List</tt> given above, the direct supertype is
	      <tt>Collection&lt;Double&gt;</tt>. <tt>List&lt;Double&gt;</tt> is <span class="emphasis"><i>not</i></span>
	      considered to be a subtype of <tt>List&lt;Number&gt;</tt>.
	    </p><p>
	      An instance of a parameterized type <tt>P&lt;T1,T2,...Tn&gt;</tt>may be assigned to a variable of 
	      the same type or a supertype
	      without casting. In addition it may be assigned to a variable <tt>R&lt;S1,S2,...Sm&gt;</tt> where
	      <tt>R</tt> is a supertype of <tt>P</tt> (the supertype relationship is reflexive), 
	      <tt>m &lt;= n</tt>, and for all type parameters <tt>S1..m</tt>, <tt>Tm</tt> equals
	      <tt>Sm</tt> <span class="emphasis"><i>or</i></span> <tt>Sm</tt> is a wildcard type specification and 
	      <tt>Tm</tt> falls within the bounds of the wildcard. For example, <tt>List&lt;String&gt;</tt>
	      can be assigned to a variable of type <tt>Collection&lt;?&gt;</tt>, and <tt>List&lt;Double&gt;</tt>
	      can be assigned to a variable of type <tt>List&lt;? extends Number&gt;</tt>. 	      
	    </p></div><div class="sect2"><a name="d0e2051"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2051"></a>Generic Methods and Constructors</h3></div></div><p>
	      A static method may be declared with one or more type parameters as in the following declaration:
	    </p><pre class="programlisting">
          static &lt;T&gt; T first(List&lt;T&gt; ts) { ... }
		</pre><p>
	        Such a definition can appear in any type, the type parameter <tt>T</tt> does not need to
	        be declared as a type parameter of the enclosing type.
	    </p><p>
	      Non-static methods may also be declared with one or more type parameters in a similar fashion:
	    </p><pre class="programlisting">
          &lt;T extends Number&gt; T max(T t1, T t2) { ... }
		</pre><p>The same technique can be used to declare a generic constructor.</p></div><div class="sect2"><a name="d0e2069"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2069"></a>Erasure</h3></div></div><p>Generics in Java are implemented using a technique called <span class="emphasis"><i>erasure</i></span>. All
	  type parameter information is erased from the run-time type system. Asking an object of a parameterized
	  type for its class will return the class object for the raw type (eg. <tt>List</tt> for an object
	  declared to be of type <tt>List&lt;String&gt;</tt>. A consequence of this is that you cannot at
	  runtime ask if an object is an <tt>instanceof</tt> a parameterized type.</p></div></div><div class="sect1"><a name="generics-inAspectJ5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="generics-inAspectJ5"></a>Generics in AspectJ 5</h2></div></div><p>
        AspectJ 5 provides full support for all of the Java 5 language features, including generics. Any legal Java 5 program is a 
        legal AspectJ 5 progam. In addition, AspectJ 5 provides support for generic and parameterized types in pointcuts, inter-type
        declarations, and declare statements.  Parameterized types may freely be used within aspect members, and support is 
        also provided for generic <span class="emphasis"><i>abstract</i></span> aspects.
      </p><div class="sect2"><a name="d0e2095"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2095"></a>Matching generic and parameterized types in type patterns</h3></div></div><p>
        The foundation of AspectJ's support for generic and parameterized types in aspect declarations is the extension of type
        pattern matching to allow matching against generic and parameterized types.
      </p><p>
           The type pattern <tt>"Foo"</tt> matches all types named <tt>Foo</tt>, whether they
           be simple types, generic types, or parameterized types. So for example, <tt>Foo</tt>, 
           <tt>Foo&lt;T&gt;</tt>, and <tt>Foo&lt;String&gt;</tt>will all be matched. 
      </p><p>
          AspectJ 5 also extends the specification of type patterns to allow explicit matching of generic and parameterized
          types by including one or more type parameter patterns inside angle braces (<tt>&lt; &gt;</tt>) immediately
          after the type pattern. For example, <tt>List&lt;String&gt;</tt>
      </p><pre class="programlisting">
  	  	TypePattern := SimpleTypePattern |
  	  	               '!' TypePattern |
  	  	               '(' AnnotationPattern? TypePattern ')'
  	  	               TypePattern '&amp;&amp;' TypePattern |
  	  	               TypePattern '||' TypePattern |
  	  	               TypePattern '&lt;' TypeParameterPatternList '&gt;'
  	  	               
  	  	TypeParameterPatternList ::= TypeParameterPattern (',' TypeParameterPattern)*
  	  	
  	  	TypeParameterPattern ::= TypePattern |
  	  	                                    '?' TypeBoundPattern?
  	  	                                    
  	  	TypeBoundPattern ::= 'extends' TypePattern AdditionalBoundPatternList? |
  	  	                               'super' TypePattern AdditionalBoundPatternList?
  	  	                     
  	  	AdditionalBoundPatternList ::= AdditionalBoundPattern AdditionalBoundPatternList |
  	  	                                         AdditionalBoundPattern
  	  	                               
  	  	AdditionalBoundPattern ::= '&amp;' TypePattern 
  	  	
		</pre><p>
  	  	    A simple identifier (such as <tt>String</tt>) occuring in a type parameter list will be treated as a type name unless
  	  	    a type variable of that name is in scope (declaring type variables is covered later). The type pattern <tt>List&lt;E&gt;</tt>
  	  	    will result in an "invalid absolute type name" warning if no type <tt>E</tt> is in scope (declared in the default package, or
  	  	    imported in the compilation unit) and no declaration of <tt>E</tt> as a type variable is in scope either. 
  	  	</p><p>Some simple examples of type patterns follow:</p><div class="variablelist"><dl><dt><a name="d0e2144"></a><span class="term">List&lt;String&gt;</span></dt><dd><p><a name="d0e2147"></a>Matches the parameterized type <tt>List&lt;String&gt;</tt>
            </p></dd><dt><a name="d0e2153"></a><span class="term">List&lt;? extends Number&gt;</span></dt><dd><p><a name="d0e2156"></a>Matches the parameterized type <tt>List&lt;? extends Number&gt;</tt>
            </p></dd><dt><a name="d0e2162"></a><span class="term">List&lt;E&gt;</span></dt><dd><p><a name="d0e2165"></a>Outside of a scope in which <tt>E</tt>is defined as a type variable, this pattern matches the 
            parameterized type <tt>List&lt;E&gt;</tt>. If <tt>E</tt> is not
            a type then an <tt>invalidAbsoluteTypeName</tt> xlint warning will be issued. 
            </p><p>In a scope in which
            <tt>E</tt> is defined as a type variable, this pattern matches the generic type <tt>List&lt;E&gt;</tt>.
            The type parameter name does not have to match the name used in the declaration of <tt>List</tt>, 
            but the bounds must match. This pattern <span class="emphasis"><i>also</i></span> matches any parameterization of <tt>List</tt> 
            that satisfies the bounds of the type variable (for example, <tt>List&lt;String&gt;</tt>).
            </p></dd></dl></div><p>
  	    The <tt>*</tt>, <tt>+</tt>, and <tt>..</tt> wildcards may be used in type patterns
  	    matching against generic and parameterized types (just as in any other type pattern). The <tt>+</tt>
  	    wildcard matches all subtypes. Recalling the discussion on subtypes and supertypes in the previous section, note
  	    that the pattern <tt>List&lt;Number&gt;+</tt> will match <tt>List&lt;Number&gt;</tt> and
  	    <tt>LinkedList&lt;Number&gt;</tt>, but not <tt>List&lt;Double&gt;</tt>. To match lists of
  	    any number type use the pattern <tt>List&lt;Number+&gt;</tt> which will match 
  	    <tt>List&lt;Number&gt;</tt>, <tt>List&lt;Double&gt;</tt>, <tt>List&lt;Float&gt;</tt>
  	    and so on.  
  	  </p><p>
  	      The generics wildcard <tt>?</tt> is considered part of the signature of a parameterized type, and
  	      is <span class="emphasis"><i>not</i></span> used as an AspectJ wildcard in type matching. For example:
  	  </p><div class="variablelist"><dl><dt><a name="d0e2247"></a><span class="term">List&lt;*&gt;</span></dt><dd><p><a name="d0e2250"></a>Matches any generic or parameterized <tt>List</tt>type (<tt>List&lt;String&gt;</tt>,
              <tt>List&lt;Integer&gt;</tt> and so on) with a single type parameter.
            </p></dd><dt><a name="d0e2262"></a><span class="term">List&lt;?&gt;</span></dt><dd><p><a name="d0e2265"></a>Matches the parameterized type <tt>List&lt;?&gt;</tt> (and does 
              <span class="emphasis"><i>not</i></span> match <tt>List&lt;String&gt;</tt>,
              <tt>List&lt;Integer&gt;</tt> and so on)
            </p></dd><dt><a name="d0e2280"></a><span class="term">List&lt;? extends Number+&gt;</span></dt><dd><p><a name="d0e2283"></a>Matches <tt>List&lt;? extends Number&gt;</tt>, <tt>List&lt;? extends Double&gt;</tt>,
              and so on, but does not match <tt>List&lt;Double&gt;</tt>.
            </p></dd></dl></div></div><div class="sect2"><a name="d0e2295"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2295"></a>Signature patterns</h3></div></div><p>
              Now that we understand how to write type patterns that match generic and parameterized types, it is time to look at
              how these can be utilized to match member declarations by using signature patterns.
           </p><p>To match members declared in generic types and making use of type variables defined in those types (for
          example <tt>interface  Foo&lt;T&gt; { public T doSomething(); }</tt> use a signature pattern of the form:</p><pre class="programlisting">
      	X Foo&lt;X&gt;.doSomething()
		</pre><p>
            This assumes a scope in which <tt>X</tt> is declared as a type variable. As with type patterns, the name
            of the type variable does not have to match the name used in the member declaration, but the bounds must match.
            For example, if the interface was declared as <tt>Foo&lt;T extends Number&gt;</tt> then the signature 
            pattern would be: <tt>X Foo&lt;X extends Number&gt;.doSomething()</tt>.
          </p><div class="variablelist"><dl><dt><a name="d0e2319"></a><span class="term">T Util&lt;T extends Number,S&gt;.someFunction(List&lt;S&gt;)</span></dt><dd><p><a name="d0e2322"></a>Matches the method <tt>someFunction</tt> in a generic type <tt>Util</tt> with
            two type parameters, the first type parameter having an upper bound of <tt>Number</tt>.
            </p></dd><dt><a name="d0e2334"></a><span class="term">LinkedList&lt;E&gt;.new()</span></dt><dd><p><a name="d0e2337"></a>Matches the no-argument constructor of the generic type <tt>LinkedList</tt>. 
            </p></dd></dl></div><p>
            Matching a field with a generic type works in the same way. For example:
          </p><pre class="programlisting">
      	T *&lt;T&gt;.*
		</pre><p>Matches a field of the type of type parameter <tt>T</tt> in any generic type with a single
            unbounded type parameter (the pattern<tt>*&lt;T&gt;</tt>). The field may be of any name.
            </p><p>Matching of members of parameterized types is straightforward. For example, 
          <tt>void List&lt;String&gt;.add(String)</tt> matches the add method in the 
          parameterized type <tt>List&lt;String&gt;</tt>.     
     </p><p>
            To match a generic <span class="emphasis"><i>method</i></span> the generic method type variable
            declarations become part of the signature pattern. For example:          
          </p><pre class="programlisting">
          &lt;T&gt; List&lt;T&gt; *.favourites(List&lt;T&gt;)
		</pre><p>matches a generic method <tt>favourites</tt> declared in any type. To match a 
		static generic method simply include the <tt>static</tt> modifier in the type pattern.</p></div><div class="sect2"><a name="d0e2378"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2378"></a>Pointcuts</h3></div></div><p>
            In this section we discuss how type patterns and signature patterns matching on generic and 
            parameterized types, methods, and constructors can be used in pointcut expressions.  
            We distinguish between pointcuts that match based on static type information, and pointcuts 
            that match based on runtime type information (<tt>this, target, args</tt>).
        </p><p>
            First however we need to address the notion of type variables and scopes. There is a 
            convention in Java, but no requirement, that type variables are named with a single letter. 
            Likewise it is rare, but perfectly legal, to declare a type with a single character name. Given the
            type pattern <tt>List&lt;Strng&gt;</tt>, is this a mis-spelling of the 
            parameterized type pattern <tt>List&lt;String&gt;</tt> or is it a generic type pattern
            with one unbounded type variable <tt>Strng</tt>?. Alternatively, given the
            type pattern <tt>List&lt;E&gt;</tt>, if  the type <tt>E</tt> cannot be found,
            is this a missing import statement or an implied type variable? There is no way for AspectJ
            to disambiguate in these situations without an explicit declaration of type variable names. If 
            <tt>E</tt> is defined as a type variable, and <tt>Strng</tt> is not, then both
            declarations can be correctly interpreted.
         </p><div class="sect3"><a name="d0e2409"></a><div class="titlepage"><div><h4 class="title"><a name="d0e2409"></a>Type Variables in Pointcut Expressions</h4></div></div><p>The type variables in scope for a pointcut primitive are declared in a type variable
         list immediately following the pointcut desginator keyword. For example:</p><pre class="programlisting">
          call&lt;T&gt;(* Foo&lt;T&gt;.*(T))
		</pre><p>matches a call to a method with any name (<tt>*</tt>) declared 
        by a generic type <tt>Foo</tt> with one unbounded type parameter. The method
        takes one argument which is of the type of the type variable.</p><p>In contrast, the pointcut</p><pre class="programlisting">
          call(* Foo&lt;T&gt;.*(T))
		</pre><p>matches a call to a method with any name that takes an argument of
        type <tt>T</tt>, where the target of the call is declared as the parameterized
        type <tt>Foo&lt;T&gt;</tt>. If there is no type <tt>T</tt> in scope, an 
        "invalid absolute type name (T)" warning will be issued.</p><p>
            The type variables declaration following a pointcut designator permits only simple identifiers 
            (e.g. <tt>&lt;S,T&gt;</tt> and not <tt>&lt;S extends Number&gt;</tt>).
        </p><p>A type variable declaration list can appear following any pointcut designator except
        for <tt>handler</tt> (Java 5 does
        not permit a generic class to be a direct or indirect subtype of <tt>Throwable</tt>
         - see JLS 8.1.2), the dynamic pointcuts <tt>this, target, args, if, cflow, cflowbelow</tt>, 
         and the annotation pointcut designators 
        (<tt>@args, @this, @within</tt> and so on).</p></div><div class="sect3"><a name="d0e2461"></a><div class="titlepage"><div><h4 class="title"><a name="d0e2461"></a>Initialization and execution pointcuts</h4></div></div><p>
         Recall that there is only ever one type for a generic type (e.g. <tt>List&lt;E&gt;</tt>)
         regardless of how many different parameterizations of that type (e.g. 
         <tt>List&lt;String&gt;</tt>, <tt>List&lt;Double&gt;</tt>) are used within a
         program. For join points that occur within a type, such as execution join points, it therefore only
         makes sense to talk about execution join points for the generic type. Given the generic type 
         </p><pre class="programlisting">
        public class Foo&lt;T&gt; {
            
          T doSomething(T toSomeT) {
             return T;
          }  
          
        }
		</pre><p>
             then 
         </p><div class="variablelist"><dl><dt><a name="d0e2480"></a><span class="term">execution&lt;T&gt;(T Foo&lt;T&gt;.doSomething(..))</span></dt><dd><p><a name="d0e2483"></a>matches the execution of the <tt>doSomething</tt> method in
            <tt>Foo</tt>.
            </p></dd><dt><a name="d0e2492"></a><span class="term">execution(* Foo.doSomething(..))</span></dt><dd><p><a name="d0e2495"></a>also matches the execution of the <tt>doSomething</tt> method in
            <tt>Foo</tt>.
            </p></dd><dt><a name="d0e2504"></a><span class="term">execution(T Foo.doSomething(..))</span></dt><dd><p><a name="d0e2507"></a>results in an "invalid absolute type name (T)" warning since <tt>T</tt> is 
            interpreted as a type, not a type variable.
            </p></dd><dt><a name="d0e2513"></a><span class="term">execution(String Foo&lt;String&gt;.doSomething(..))</span></dt><dd><p><a name="d0e2516"></a>results in a compilation error "no execution join points for parameterized type
                Foo&lt;String&gt;, use a generic signature instead".
            </p></dd></dl></div><p>
          Given the type declaration
       </p><pre class="programlisting">
        public class Bar&lt;N extends Number&gt; {
            
          N doSomething(N toSomeN) {
             return N;
          }  
          
        }
		</pre><p>
             then 
         </p><div class="variablelist"><dl><dt><a name="d0e2526"></a><span class="term">execution&lt;T&gt;(T Bar&lt;T&gt;.doSomething(..))</span></dt><dd><p><a name="d0e2529"></a>does not match the execution of <tt>Bar.doSomething</tt> since
            the bounds of the type parameter <tt>T</tt> in the pointcut expression do
            not match the bounds of the type parameter <tt>N</tt> in the type declaration.
            </p></dd><dt><a name="d0e2541"></a><span class="term">execution&lt;T&gt;(T Bar&lt;T extends Number&gt;.doSomething(..))</span></dt><dd><p><a name="d0e2544"></a>matches the execution of the <tt>doSomething</tt> method in
            <tt>Bar</tt>.
            </p></dd><dt><a name="d0e2553"></a><span class="term">execution&lt;T extends Number&gt;(T Bar&lt;T&gt;.doSomething(..))</span></dt><dd><p><a name="d0e2556"></a>results in a compilation error, since type variable bounds must be specified as part
                of the declaring type pattern, and not in the type variable list.
            </p></dd></dl></div><p>
          If a type implements a <span class="emphasis"><i>parameterized</i></span> interface, then
          execution join points exist and can be matched for the parameterized interface operations within
          the implementing type. For example, given the pair of types:   
       </p><pre class="programlisting">
        public interface Greatest&lt;T&gt; {
            T greatest(List&lt;T&gt; ts);  
        }
        
        public class  NumberOperations implements Greatest&lt;Number&gt; {
             public Number greatest(List&lt;Number&gt; numbers) {
                //...
             }
        }
		</pre><p>
          then
       </p><pre class="programlisting">
        execution(* Greatest&lt;Number&gt;.*(..))
		</pre><p>
          will match the execution of the <tt>greatest</tt> method declared in 
          <tt>NumberOperations</tt>. However, it <span class="emphasis"><i>does not</i></span>
          match the execution of <tt>greatest</tt> in the program below:
       </p><pre class="programlisting">
        public interface Greatest&lt;T&gt; {
            T greatest(List&lt;T&gt; ts);  
        }
        
        public class  NumberOperations&lt;N extends Number&gt; implements Greatest&lt;N&gt; {
             public N greatest(List&lt;N&gt; numbers) {
                //...
             }
        }
        
        // in some fragment of code...
        NumberOperations&lt;Number&gt; numOps = new NumberOperations&lt;Number&gt;();
        numOps.greatest(numList);
		</pre><p>Since there is only one generic type, <tt>NumberOperations</tt>,
        which implements a generic interface. Either of the pointcut expressions
        <tt>execution&lt;T&gt;(* Greatest&lt;T&gt;&gt;.*(..))</tt> or 
        <tt>execution&lt;T&gt;(* Greatest&lt;T extends Number&gt;&gt;.*(..))</tt> will
        match the execution of <tt>greatest</tt> in this example.  Recall from 
        chapter <a href="#jpsigs">Join Point Signatures</a> that a kinded pointcut primitive matches a join point if
        it exactly matches one of the signatures of the join point. The signatures of the
        execution join point for <tt>greatest</tt> in the example above are:</p><div class="variablelist"><dl><dt><a name="d0e2606"></a><span class="term">public N Greatest&lt;N&gt;.greatest(List&lt;N&gt;)</span></dt><dd><p><a name="d0e2609"></a>from the declaration in the <tt>Greatest</tt> interface, and
            </p></dd><dt><a name="d0e2615"></a><span class="term">public N Greatest&lt;N extends Number&gt;.greatest(List&lt;N&gt;)</span></dt><dd><p><a name="d0e2618"></a>from the additional bounds restriction of <tt>N</tt> in the
            declaration of <tt>NumberOperations</tt>
            </p></dd></dl></div><p>
        Join points for <tt>staticinitialization</tt>,<tt>initialization</tt> and 
        <tt>preinitialization</tt> 
        only ever exist on a generic type (an interface cannot define a constructor). The expression
        <tt>initialization&lt;T&gt;(Foo&lt;T&gt;.new(..))</tt> which match any initialization 
        join point for the generic type <tt>Foo&lt;T&gt;</tt>, and 
        <tt>staticinitialization&lt;T&gt;(Foo&lt;T&gt;)</tt> matches the static initialization 
        of that same type. 
     </p><p>
         The expression <tt>staticinitialization(List&lt;String&gt;)</tt> will result in a 
         compilation error: there is no static initialization join point for the parameterized type
         <tt>List&lt;String&gt;</tt>. However, the expression 
         <tt>staticinitialization(List&lt;String&gt;+)</tt> <span class="emphasis"><i>is</i></span>
         legal, and will match the static initialization of any type that 
         <tt>implements List&lt;String&gt;</tt>.  The expression
         <tt>staticinitialization&lt;T&gt;(List&lt;T&gt;+)</tt> will match the static
         initialization join point of any type that either extends or implements the generic
         type <tt>List&lt;T&gt;</tt> or implements any parameterization of that
         interface. 
      </p></div><div class="sect3"><a name="d0e2670"></a><div class="titlepage"><div><h4 class="title"><a name="d0e2670"></a>Static scoping: within and withincode</h4></div></div><p>The <tt>within</tt> and <tt>withincode</tt> 
         pointcut designators both match the
         execution of join points that occur within a type or a member of a type respectively. Therefore
         the same considerations with respect to there only being <tt>one</tt> type for
         a generic type regardless of how many parameterizations of that type are used in a program 
         apply.
         </p><p>The <tt>within</tt> pointcut designator can never be used in conjunction
         with a simple parameterized type. So
         </p><div class="variablelist"><dl><dt><a name="d0e2690"></a><span class="term">within&lt;T&gt;(Foo&lt;T&gt;)</span></dt><dd><p><a name="d0e2693"></a>matches all join points occurring within the generic type <tt>Foo&lt;T&gt;</tt>,
            and
            </p></dd><dt><a name="d0e2699"></a><span class="term">within(Foo&lt;String&gt;)</span></dt><dd><p><a name="d0e2702"></a>results in a compilation error since there is no concept of a join point within a 
            parameterized type, but 
            </p></dd><dt><a name="d0e2705"></a><span class="term">within(Foo&lt;String&gt;+)</span></dt><dd><p><a name="d0e2708"></a>matches any join point occurring within a type that 
            <tt>implements Foo&lt;String&gt;</tt>.
            </p></dd></dl></div><p>The <tt>withincode</tt> designator is likewise normally used with a 
         generic type, but can be used with a parameterized interface type to match join points
         arising from code lexically within the implementation of the interface methods in a type
         that implements the parameterized interface.
         </p><div class="variablelist"><dl><dt><a name="d0e2720"></a><span class="term">withincode&lt;T&gt;(* Foo&lt;T&gt;.*(..))</span></dt><dd><p><a name="d0e2723"></a>matches all join points arising from code lexically within a method of the 
            generic type <tt>Foo&lt;T&gt;</tt>
            </p></dd><dt><a name="d0e2729"></a><span class="term">withincode(* Foo&lt;String&gt;.*(..))</span></dt><dd><p><a name="d0e2732"></a>results in a compilation error if <tt>Foo</tt> is not an interface. If 
            <tt>Foo</tt> is an interface then it matches all join points arising from
            code lexically within the implementation of the interface methods in a type that
            implements <tt>Foo&lt;String&gt;</tt>.
            </p></dd><dt><a name="d0e2744"></a><span class="term">withincode(* Foo&lt;String&gt;+.*(..))</span></dt><dd><p><a name="d0e2747"></a>matches any join point occurring within a method of a type that 
            <tt>implements Foo&lt;String&gt;</tt>.
            </p></dd></dl></div></div><div class="sect3"><a name="d0e2753"></a><div class="titlepage"><div><h4 class="title"><a name="d0e2753"></a>Call, get and set pointcuts</h4></div></div><p>
         The <tt>call, get,</tt> and <tt>set</tt> join points can occur on the client
         side (ie. outside of the type owning the member being called, accessed, or updated) or 
         within the type that owns the target member. The following short program demonstrates this:
     </p><pre class="programlisting">
        public class Foo&lt;T&gt; {
        
          public T timeFor;  
          
          public Foo&lt;T&gt;(T aCuppa) {
                timeFor = aCuppa;      // set-site A
          }
        
          public void doThis(T t) {
            doThat(t);  // call-site A
          }    
          
          public void doThat(T t) {
             return;
          }
            
        }
        
        public class Main {
          public static void main(String[] args) {
            Foo&lt;String&gt; foos = new Foo&lt;String&gt;();
            foos.doThis("b");  //call-site B  
            foos.doThat("c");  // call-site C
            foos.timeFor = "a cuppa"; // set-site B
          }
        }
		</pre><p>
            We have annotated the three method call sites as call-site A, call-site B, and call-site C. 
            Call-site A is situated within the generic type <tt>Foo&lt;T&gt;</tt> and the call
            join point has signature <tt>public void Foo&lt;T&gt;doThat(T)</tt>. The join point
            arising from call-site B is a client-side call join point and has the signatures
            <tt>public void Foo&lt;String&gt;doThis(String)</tt> (from the static type of 
            <tt>foos</tt>) <span class="emphasis"><i>and</i></span>  
            <tt>public void Foo&lt;T&gt;doThis(T)</tt>. Likewise the call join point arising from
            call-site C has the signatures 
            <tt>public void Foo&lt;String&gt;doThat(String)</tt> (from the static type of 
            <tt>foos</tt>) <span class="emphasis"><i>and</i></span>  
            <tt>public void Foo&lt;T&gt;doThat(T)</tt>. A call pointcut expression matches if the
            signature pattern exactly matches one of the signatures of the call join point.
        </p><p>
            The signatures for get and set join points works in a similar fashion. At set-site A in the above
            example, the set join point has signature <tt>public T Foo&lt;T&gt;.timeFor</tt>. At 
            set-site B the set join point has signatures <tt>public T Foo&lt;T&gt;.timeFor</tt> and
            <tt>public String Foo&lt;String&gt;.timeFor</tt>. A get or set pointcut expression
            matches if the signature pattern exactly matches one of the signatures of the join point.
         </p>
         
         Some examples follow:

      <div class="variablelist"><dl><dt><a name="d0e2811"></a><span class="term">call(* List&lt;?&gt;.*(..))</span></dt><dd><p><a name="d0e2814"></a>matches a call to any method of a <tt>List&lt;?&gt;</tt> (a call where the
            target is declared to be a <tt>List&lt;?&gt;</tt>). For example:
            </p><pre class="programlisting">
        int countItems(List&lt;?&gt; anyList) {
          return anyList.size();   // matched by call(* List&lt;?&gt;.*(..))
        }
		</pre></dd><dt><a name="d0e2825"></a><span class="term">call&lt;T&gt;(* List&lt;T&gt;.*(..))</span></dt><dd><p><a name="d0e2828"></a>matches any call to an operation defined in the generic type 
            <tt>List&lt;E&gt;</tt>. This includes calls made to <tt>List&lt;String&gt;</tt>,
            <tt>List&lt;Number&gt;</tt>, <tt>List&lt;? super Foo&gt;</tt> and so on.
            </p></dd><dt><a name="d0e2843"></a><span class="term">get&lt;T&gt;(T *&lt;T extends Account&gt;.*)</span></dt><dd><p><a name="d0e2846"></a>matches the get of any field defined in a generic type with one type parameter that has 
                an upper bound of <tt>Account</tt>. The field has the type of the type parameter, and
                can be of any name. This pointcut expression matches both gets of the field within the
                declaring type, and also gets on parameterized instances of the type.
            </p></dd><dt><a name="d0e2852"></a><span class="term">set(Account Foo&lt;Account&gt;.*Account)</span></dt><dd><p><a name="d0e2855"></a>matches the set of a field of type <tt>Account</tt>  where the target
            is of type <tt>Foo&lt;Account&gt;</tt> and the field name ends with "Account". Does not
            match sets of any "*Account" field occurring within the <tt>Foo</tt> type itself.
            </p></dd><dt><a name="d0e2867"></a><span class="term">call(* List&lt;? extends Number&gt;.add(..))</span></dt><dd><p><a name="d0e2870"></a>matches any call to add an element to a list of type <tt>List&lt;? extends Number&gt;</tt>.
            Does not match calls to add elements to lists of type <tt>List&lt;Number&gt;</tt> or 
            <tt>List&lt;Double&gt;</tt> as these are distinct types.
            </p></dd><dt><a name="d0e2882"></a><span class="term">call(* List&lt;Number+&gt;.add(..))</span></dt><dd><p><a name="d0e2885"></a>matches any call to add an element to a list of type <tt> Number</tt> or
            any subclass of <tt>Number</tt>. For example, <tt>List&lt;Number&gt;, 
            List&lt;Double&gt; List&lt;Float&gt;</tt>.
            Does not match calls to add elements to lists of type <tt>List&lt;? extends Number&gt;</tt> 
            as this is a distinct type.
            </p></dd></dl></div></div><div class="sect3"><a name="d0e2900"></a><div class="titlepage"><div><h4 class="title"><a name="d0e2900"></a>Handler</h4></div></div><p>
          The Java Language Specification states that a generic class may not be a direct or indirect
          subclass of <tt>Throwable</tt>. Therefore it is a compilation error to use a generic
          or parameterized type pattern in a <tt>handler</tt> pointcut expression.
      </p></div><div class="sect3"><a name="d0e2911"></a><div class="titlepage"><div><h4 class="title"><a name="d0e2911"></a>Runtime type matching: this, target and args</h4></div></div><p>
         Java 5 generics are implemented using a technique known an <span class="emphasis"><i>erasure</i></span>.
         In particular, what gets "erased" is the ability to find out the parameterized runtime type
         of an instance of a generic type. You can ask if something is an <tt>instanceof List</tt>,
         but not if something is an <tt>instanceof List&lt;String&gt;</tt>
     </p><p>
         The <tt>this, target</tt> and <tt>args</tt> pointcut designators all match
         based on the runtime type of the appropriate object (this, target, or argument) at a join point. 
         To match any parameterization of a generic type, simply use the raw type (type variables are
         not permitted with these designators).  For example:
      </p><div class="variablelist"><dl><dt><a name="d0e2934"></a><span class="term">target(List)</span></dt><dd><p><a name="d0e2937"></a>matches any call to an instance of <tt>List</tt> (including 
            <tt>List&lt;String&gt;, List&lt;Number&gt;</tt>, and so on.
            </p></dd><dt><a name="d0e2946"></a><span class="term">args (List)</span></dt><dd><p><a name="d0e2949"></a>matches any join point with a single argument that is an instance of 
            <tt>List</tt>. 
            </p></dd></dl></div><p>
         To match specific parameterizations of a generic type, simply use the type that you require
         the relevant object to be an instance of inside the pointcut expression. For example:
         <tt>target(List&lt;String&gt;)</tt>. 
     </p><p>
         Recall that runtime tests to determine whether an object is an instance of a parameterized
         type are not possible due to erasure. Therefore AspectJ matching behaviour with 
         parameterized types for <tt>this, target</tt> and <tt>args</tt> is as follows. 
     </p><table class="simplelist" border="0" summary="Simple list"><tr><td>If it can be statically determined that a given object will always be an instance
         of the required type, then the pointcut expressions matches. For example, given a variable
         <tt>bankAccounts</tt>
         of type <tt>Set&lt;BankAccount&gt;</tt> and the pointcut expression
         <tt>target(Set&lt;BankAccount&gt;)</tt> then any call made to
         <tt>bankAccounts</tt> will be matched.</td></tr><tr><td>If it can be statically determined that a given object can never be an 
         instance of the required type, then the pointcut expression does not match. The
         expression <tt>target(List&lt;String&gt;)</tt>will never match a call made 
         using a variable of type <tt>List&lt;Number&gt;</tt> (it is not possible for
         a type to implement two different parameterizations of the same interface).</td></tr><tr><td>If an object <span class="emphasis"><i>might</i></span> be an instance of the required
         type in some circumstances but not in others, then since it is not possible to perform
         the runtime test, AspectJ deems the pointcut expression to match, but issues an
         unchecked warning. This is analogous to the behaviour of the Java compiler when
         converting between raw and parameterized types. Given a variable of type
         <tt>List&lt;? extends Number&gt;</tt> and a call join point with 
         target pointcut expression <tt>target(List&lt;Double&gt;)</tt> then 
         the expression matches but with an unchecked warning. The warning can be suppressed
         by annotating the associated advice with either <tt>@SuppressAjWarnings</tt>
         or <tt>@SuppressAjWarnings("unchecked")</tt>.</td></tr></table><p>   
         When using a parameterized type with the
         <tt>this</tt> pointcut designator then a joinpoint is unambiguously 
         matched if and only if one or more of the following conditions hold:
     </p><table class="simplelist" border="0" summary="Simple list"><tr><td>the runtime type of the <tt>this</tt> object extends or
         implements the parameterized type. For example, 
         <tt>class Foo implements List&lt;String&gt;</tt> will match
         <tt>this(List&lt;String&gt;)</tt>.</td></tr><tr><td>
           The parameterized "this" type is given using a generics wildcard in the pointcut 
           expression, and the bounds of
           the generic runtime type of <tt>this</tt> are such that all valid parameterizations
           are matched by the wildcard. For example, the pointcut expression 
           <tt>this(List&lt;? extends Number&gt;)</tt> will match a <tt>this</tt>
           object of type <tt>class Foo&lt;N extends Number&gt; implements List&lt;N&gt;</tt>,
           but not an object of type  <tt>class Foo&lt;N&gt; implements List&lt;N&gt;</tt>.
         </td></tr></table><p>
       You've already seen some examples of using the generic wildcard <tt>?</tt>
        in parameterized type patterns. Since <tt>this, target</tt> and 
       <tt>args</tt> match using an instance of test, the generic wildcard can be useful in
       specifying an acceptable range of parameterized types to match. When used in the binding
       form, the same restrictions on operations permitted on the bound variable apply as when a 
       method declares a parameter with a wildcard type. For example, in the advice below, it is
       a compilation error to attemp to add an element into the list <tt>aList</tt>. 
      </p><pre class="programlisting">
        before(List&lt;? extends Number&gt; aList) : 
          execution(* org.xyz.Foo.*(..)) &amp;&amp; args(aList) {
           aList.add(new Double(5.0d));  // Compilation error on this line
        }
		</pre></div><div class="sect3"><a name="d0e3058"></a><div class="titlepage"><div><h4 class="title"><a name="d0e3058"></a>Declaring pointcuts in generic classes</h4></div></div><p>
        AspectJ permits pointcuts to be declared in classes as well as aspects. A pointcut defined
        inside a generic class may not use the type variables of the class in the pointcut expression
        (just as static members of a generic class may not use type variables). 
        For example:        
     </p><pre class="programlisting">
        public class Foo&lt;T extends Number&gt; {
          
          ...
          
          // Not allowed - uses T in the pointcut expression
          public pointcut fooOperationCall(T t) : 
             call(* Foo&lt;T&gt;.*(T)) &amp;&amp; args(t);   
            
            
          // permitted, but recommended to use an alternate variable name in the local 
          // type variable declaration - e.g. execution&lt;S&gt;(...)
          public pointcut fooExecution(Number n) :
             execution&lt;T&gt;(* Foo&lt;T&gt;.*(T)) &amp;&amp; args(n); 
        }
		</pre></div></div><div class="sect2"><a name="d0e3065"></a><div class="titlepage"><div><h3 class="title"><a name="d0e3065"></a>Inter-type Declarations</h3></div></div><p>
            AspectJ 5 allows type parameters to be used in inter-type declarations - either for declaring generic
            methods and constructors, or for declaring members on generic types. The syntax for declaring generic
            methods and constructors follows the regular AspectJ convention of simply qualifying the member name with
            the target type.
          </p><div class="variablelist"><dl><dt><a name="d0e3071"></a><span class="term">&lt;T extends Number&gt; T Utils.max(T first, T second) {...}</span></dt><dd><p><a name="d0e3074"></a>Declares a generic instance method <tt>max</tt> on the class <tt>Util</tt>.
            The <tt>max</tt> method takes two arguments, <tt>first</tt> and <tt>second</tt> which must
            both be of the same type (and that type must be Number or a subtype of Number) and returns an instance
            of that type.
            </p></dd><dt><a name="d0e3092"></a><span class="term">static &lt;E&gt; E Utils.first(List&lt;E&gt; elements) {...}</span></dt><dd><p><a name="d0e3095"></a>Declares a static generic method <tt>first</tt> on the class <tt>Util</tt>.
            The <tt>first</tt> method takes a list of elements of some type, and returns an instance
            of that type.
            </p></dd><dt><a name="d0e3107"></a><span class="term">&lt;T&gt; Sorter.new(List&lt;T&gt; elements,Comparator&lt;? super T&gt; comparator) {...}</span></dt><dd><p><a name="d0e3110"></a>Declares a constructor on the class <tt>Sorter</tt>.
            The constructor takes a list of elements of some type, and a comparator that can compare instances
            of the element type.
            </p></dd></dl></div><p>
         A generic type may be the target of an inter-type declaration, used either in its raw form or with
         type parameters specified. If type parameters are specified, then the number of type parameters given
          must match the number of type parameters in
         the generic type declaration. Type parameter <span class="emphasis"><i>names</i></span> do not have to match.
         For example, given the generic type <tt>Foo&lt;T,S extends Number&gt;</tt> then:      
      </p><div class="variablelist"><dl><dt><a name="d0e3125"></a><span class="term">String Foo.getName() {...}</span></dt><dd><p><a name="d0e3128"></a>Declares a <tt>getName</tt> method on behalf of the raw type <tt>Foo</tt>. It is
            not possible to refer to the type parameters of Foo in such a declaration.
            </p></dd><dt><a name="d0e3137"></a><span class="term">R Foo&lt;Q, R&gt;.getMagnitude() {...}</span></dt><dd><p><a name="d0e3140"></a>Declares a method <tt>getMagnitude</tt> on the generic class <tt>Foo</tt>.
            The method returns an instance of the type substituted for the second type parameter in an invocation
            of <tt>Foo</tt>.
            </p></dd><dt><a name="d0e3152"></a><span class="term">R Foo&lt;Q, R extends Number&gt;.getMagnitude() {...}</span></dt><dd><p><a name="d0e3155"></a>Results in a compilation error since a bounds specification is not allowed in this
                form of an inter-type declaration (the bounds are determined from the declaration of the
                target type).
            </p></dd></dl></div><p>A parameterized type may not be the target of an inter-type declaration. This is because
      there is only one type (the generic type) regardless of how many different invocations (parameterizations) of
      that generic type are made in a program. Therefore it does not make sense to try and declare a member
      on behalf of (say) <tt>Foo&lt;String&gt;</tt>, you can only declare members on the generic
      type <tt>Foo&lt;T&gt;</tt>. 
      </p><p>
        If an inter-type member is declared inside a generic aspect, then the type parameter names from the
        aspect declaration may be used in the signature specification of the inter-type declaration, but 
        <span class="emphasis"><i>not</i></span> as type parameter names for a generic target type. In other words the example
        that follows is legal:
      </p><pre class="programlisting">
            public abstract aspect A&lt;T&gt; {
              
              private T Foo.data;
              
              public T Foo.getData(T defaultValue) {
                return (this.data != null ? data : defaultValue);
              }   
                
            }
		</pre><p>
       Whereas the following example is not allowed and will report an error that a parameterized type may not be the
       target of an inter-type declaration (since when the type parameter <tt>T</tt> in the aspect is subsituted with
       say, <tt>String</tt>, then the target of the inter-type declaration becomes <tt>Goo&lt;String&gt;</tt>).  
      </p><pre class="programlisting">
            public abstract aspect A&lt;T&gt; {
              
              private T Goo&lt;T&gt;.data;
              
              public T Goo&lt;T&gt;.getData(T defaultValue) {
                return (this.data != null ? data : defaultValue);
              }   
                
            }
		</pre></div><div class="sect2"><a name="d0e3186"></a><div class="titlepage"><div><h3 class="title"><a name="d0e3186"></a>Declare Parents</h3></div></div><p>Both generic and parameterized types can be used as the parent type in a <tt>declare parents</tt>
          statement (as long as the resulting type hierarchy would be well-formed in accordance with Java's sub-typing
          rules). Generic types may also be used as the target type of a <tt>declare parents</tt> statement: 
          a type variable list follows the <tt>parents</tt> keyword in these cases to declare the
          type variables in scope.
          Some examples follow:</p><div class="variablelist"><dl><dt><a name="d0e3201"></a><span class="term">declare parents: Foo implements List&lt;String&gt;</span></dt><dd><p><a name="d0e3204"></a>The <tt>Foo</tt> type implements the <tt>List&lt;String&gt;</tt> interface. If
            <tt>Foo</tt> already implements some other parameterization of the <tt>List</tt>
            interface (for example, <tt>List&lt;Integer&gt;</tt> then a compilation error will result since a 
            type cannot implement multiple parameterizations of the same generic interface type. 
            </p></dd><dt><a name="d0e3222"></a><span class="term">declare parents &lt;T&gt;:  org.xyz..*&lt;T&gt; extends Base&lt;T&gt;</span></dt><dd><p><a name="d0e3225"></a>All generic types declared in a package beginning with <tt>org.xyz</tt> and with a 
            single unbounded type parameter, extend the generic type <tt>Base&lt;T&gt;</tt>.
            </p></dd><dt><a name="d0e3234"></a><span class="term">declare parents &lt;T&gt;:  org.xyz..*&lt;T&gt; extends Base&lt;S&gt;</span></dt><dd><p><a name="d0e3237"></a>Results in a compilation error (unless <tt>S</tt> is a type) since <tt>S</tt> is
            not bound in the type pattern.
            </p></dd></dl></div></div><div class="sect2"><a name="d0e3246"></a><div class="titlepage"><div><h3 class="title"><a name="d0e3246"></a>Declare Soft</h3></div></div><p>It is an error to use a generic or parameterized type as the softened exception type in a declare soft statement. Java 5 does
          not permit a generic class to be a direct or indirect subtype of <tt>Throwable</tt> (JLS 8.1.2).</p></div><div class="sect2"><a name="d0e3254"></a><div class="titlepage"><div><h3 class="title"><a name="d0e3254"></a>Parameterized Aspects</h3></div></div><p>
            AspectJ 5 allows an <span class="emphasis"><i>abstract</i></span> aspect to be declared as a generic type. Any concrete
            aspect extending a generic abstract aspect must extend a parameterized version of the abstract aspect.
            Wildcards are not permitted in this parameterization.     
          </p><p>Given the aspect declaration:</p><pre class="programlisting">
            public abstract aspect ParentChildRelationship&lt;P,C&gt; {
                ...
            }
		</pre><p>then</p><div class="variablelist"><dl><dt><a name="d0e3269"></a><span class="term">public aspect FilesInFolders extends ParentChildRelationship&lt;Folder,File&gt; {...</span></dt><dd><p><a name="d0e3272"></a>declares a concrete sub-aspect, <tt>FilesInFolders</tt> which extends the
            parameterized abstract aspect <tt>ParentChildRelationship&lt;Folder,File&gt;</tt>.
            </p></dd><dt><a name="d0e3281"></a><span class="term">public aspect FilesInFolders extends ParentChildRelationship {...</span></dt><dd><p><a name="d0e3284"></a>results in a compilation error since the <tt>ParentChildRelationship</tt> aspect must
            be fully parameterized.
            </p></dd><dt><a name="d0e3290"></a><span class="term">public aspect ThingsInFolders&lt;T&gt; extends ParentChildRelationship&lt;Folder,T&gt;</span></dt><dd><p><a name="d0e3293"></a>results in a compilation error since concrete aspects may not have type parameters.
            </p></dd><dt><a name="d0e3296"></a><span class="term">public abstract aspect ThingsInFolders&lt;T&gt; extends ParentChildRelationship&lt;Folder,T&gt;</span></dt><dd><p><a name="d0e3299"></a>declares a sub-aspect of <tt>ParentChildRelationship</tt> in which <tt>Folder</tt>
            plays the role of parent (is bound to the type variable <tt>P</tt>).
            </p></dd></dl></div><p>An exception to the rule that concrete aspects may not be generic is a pertypewithin aspect, which
       may be declared with a single unbounded type parameter. This is discussed in the chapter on <a href="#pertypewithin">pertypewithin</a>.</p><p>The type parameter variables from a generic aspect declaration may be used in place of a type within any
        member of the aspect. For example, we can declare a <tt>ParentChildRelationship</tt> aspect to
        manage the bi-directional relationship between parent and child nodes as follows:
        </p><pre class="programlisting">
            public abstract aspect ParentChildRelationship&lt;P,C&gt; {
                
                /**
                 * Parents contain a list of children
                 */
                private List&lt;C&gt; P.children;
                    
                /**
                 * Each child has a parent
                 */
                private P C.parent;

                /**
                  * Parents provide access to their children
                  */
                public List&lt;C&gt; P.getChildren() {
                    return Collections.unmodifiableList(children);  
                }
                
                /**
                 * A child provides access to its parent
                 */
                 public P C.getParent() {
                   return parent;
                 }
                
                /**
                 * ensure bi-directional navigation on adding a child
                 */
                public void P.addChild(C child) {
                   if (child.parent != null) {
                     child.parent.removeChild(child);
                   }
                   children.add(child);
                   child.parent = this;
                }

                /**
                 * ensure bi-directional navigation on removing a child
                 */
                public void P.removeChild(C child) {
                   if (children.remove(child)) {
                     child.parent = null;
                   }
                }

               /**
                 * ensure bi-directional navigation on setting parent
                 */
                public void C.setParent(P parent) {
                   parent.addChild(this);
                }
                
                public pointcut addingChild(P p, C c) :
                  execution(* P.addChild(C)) &amp;&amp; this(p) &amp;&amp; args(c);
                  
                public pointcut removingChild(P p, C c) :
                  execution(* P.removeChild(C)) &amp;&amp; this(p) &amp;&amp; args(c);
            }
		</pre><p>
          Note in the above example how the type parameters <tt>P</tt> and <tt>C</tt> can be
          used in inter-type declarations, pointcut expressions, and any other member of the aspect type. 
        </p><p>
          The example aspect captures the protocol for managing a bi-directional parent-child relationship between
          any two types playing the role of parent and child. In a compiler implementation managing an abstract syntax
          tree (AST) in which AST nodes may contain other AST nodes we could declare the concrete aspect:
        </p><pre class="programlisting">
            public aspect ASTNodeContainment extends ParentChildRelationship&lt;ASTNode,ASTNode&gt; {
                
                before(ASTNode parent, ASTNode child) : addingChild(parent, child) {
                  ...
                }
                
            }
		</pre><p>
           As a result of this declaration, <tt>ASTNode</tt> gains members:
         </p><table class="simplelist" border="0" summary="Simple list"><tr><td><tt>List&lt;ASTNode&gt; children</tt></td></tr><tr><td><tt>ASTNode parent</tt></td></tr><tr><td><tt>List&lt;ASTNode&gt;getChildren()</tt></td></tr><tr><td><tt>ASTNode getParent()</tt></td></tr><tr><td><tt>void addChild(ASTNode child)</tt></td></tr><tr><td><tt>void removeChild(ASTNode child)</tt></td></tr><tr><td><tt>void setParent(ASTNode parent)</tt></td></tr></table><p>
           In a system managing files and folders, we could declare the concrete aspect:
         </p><pre class="programlisting">
            public aspect FilesInFolders extends ParentChildRelationship&lt;Folder,File&gt; {
                                
            }
		</pre><p>
           As a result of this declaration, <tt>Folder</tt> gains members:
         </p><table class="simplelist" border="0" summary="Simple list"><tr><td><tt>List&lt;File&gt; children</tt></td></tr><tr><td><tt>List&lt;File&gt; getChildren()</tt></td></tr><tr><td><tt>void addChild(File child)</tt></td></tr><tr><td><tt>void removeChild(File child)</tt></td></tr></table><p>and <tt>File</tt> gains members:</p><table class="simplelist" border="0" summary="Simple list"><tr><td><tt>Folder parent</tt></td></tr><tr><td><tt>Folder getParent()</tt></td></tr><tr><td><tt>void setParent(Folder parent)</tt></td></tr></table><p>When used in this way, the type parameters in a generic abstract aspect declare
        <span class="emphasis"><i>roles</i></span>, and the parameterization of the abstract aspect in the <tt>extends</tt>
        clause binds types to those roles. This is a case where you may consider departing from the standard practice 
        of using a single letter to represent a type parameter, and instead use a role name. It makes no difference
        to the compiler which option you choose of course.</p><pre class="programlisting">
            public abstract aspect ParentChildRelationship&lt;Parent,Child&gt; {
                
                /**
                 * Parents contain a list of children
                 */
                private List&lt;Child&gt; Parent.children;
                    
                /**
                 * Each child has a parent
                 */
                private Parent Child.parent;
                
                /**
                  * Parents provide access to their children
                  */
                public List&lt;Children&gt; Parent.getChildren() {
                    return Collections.unmodifiableList(children);  
                }
                
                /**
                 * A child provides access to its parent
                 */
                 public Parent Children.getParent() {
                   return parent;
                 }
                                
                /**
                 * ensure bi-directional navigation on adding a child
                 */
                public void Parent.addChild(Child child) {
                   if (child.parent != null) {
                     child.parent.removeChild(child);
                   }
                   children.add(child);
                   child.parent = this;
                }
         
                ...
		</pre></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="autoboxing"></a>Chapter 4. Autoboxing and Unboxing</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#boxing-inJava5">Autoboxing and Unboxing in Java 5</a></dt><dt><a href="#autoboxing-in-aspectj5">Autoboxing and Join Point matching in AspectJ 5</a></dt><dt><a href="#autoboxing-and-method-dispatch">Inter-type method declarations and method dispatch</a></dt></dl></div><div class="sect1"><a name="boxing-inJava5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="boxing-inJava5"></a>Autoboxing and Unboxing in Java 5</h2></div></div><p>
          Java 5 (and hence AspectJ 1.5) supports automatic conversion of 
          primitive types (int, float, double etc.) to their object equivalents
          (Integer, Float, Double,...) in assignments and method and constructor
          invocations. This conversion is know as autoboxing.
        </p><p>Java 5 also supports automatic unboxing, where wrapper types
        are automatically converted into their primitive equivalents if
        needed for assignments or method or constructor invocations.</p><p>For example:</p><pre class="programlisting">
		int i = 0;
		i = new Integer(5); // auto-unboxing
		
		Integer i2 = 5;  // autoboxing
		</pre></div><div class="sect1"><a name="autoboxing-in-aspectj5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="autoboxing-in-aspectj5"></a>Autoboxing and Join Point matching in AspectJ 5</h2></div></div><p>Most of the pointcut designators match based on signatures, and
          hence are unaffected by autoboxing. For example, a call to a method</p><pre class="programlisting">
   		public void foo(Integer i);
   		</pre><p>is <span class="emphasis"><i>not</i></span> matched by a pointcut
         <tt>call(void foo(int))</tt> since the signature declares
         a single <tt>Integer</tt> parameter, not an <tt>int</tt>.
         </p><p>The <tt>args</tt> pointcut designator is affected by
         autoboxing since it matches based on the runtime type of the arguments.
         AspectJ 5 applies autoboxing and unboxing in determining argument matching.
         In other words, <tt>args(Integer)</tt> will match any join
         point at which there is a single argument of type <tt>Integer</tt>
         or of type <tt>int</tt>.</p><div class="itemizedlist"><ul><li><a name="d0e3458"></a>args(Integer) and args(int) are equivalent</li><li><a name="d0e3460"></a>args(Float) and args(float) are equivalent</li><li><a name="d0e3462"></a>args(Double) and args(double) are equivalent</li><li><a name="d0e3464"></a>args(Short) and args(short) are equivalent</li><li><a name="d0e3466"></a>args(Byte) and args(byte) are equivalent</li><li><a name="d0e3468"></a>args(Long) and args(long) are equivalent</li><li><a name="d0e3470"></a>args(Boolean) and args(boolean) are equivalent</li></ul></div><p>
        Autoboxing and unboxing are also applied when binding pointcut or 
        advice parameters, for example:   
      </p><pre class="programlisting">
   		pointcut foo(int i) : args(i);
   		
   		before(Integer i) : foo(i) {
   		  ...
   		}
   		</pre></div><div class="sect1"><a name="autoboxing-and-method-dispatch"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="autoboxing-and-method-dispatch"></a>Inter-type method declarations and method dispatch</h2></div></div><p>Autoboxing, unboxing, and also varargs all affect the method
          dispatch algorithm used in Java 5. In AspectJ 5, the target method
          of a call is selected according to the following algorithm:</p><div class="orderedlist"><ol type="1"><li><a name="d0e3482"></a>Attempt to locate a matching method or inter-type declared
              method without considering
              autoboxing, unboxing, or vararg invocations.</li><li><a name="d0e3484"></a>If no match is found, try again considering autoboxing
              and unboxing.</li><li><a name="d0e3486"></a>Finally try again considering both autoboxing, unboxing,
              and varargs.</li></ol></div><p>One consequence is that a directly matching inter-type declared
          method will take precedence over a method declared locally in the 
          target class but that only matches via autoboxing.</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="covariance"></a>Chapter 5. Covariance</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#covariance-inJava5">Covariance in Java 5</a></dt><dt><a href="#covariance-and-join-point-matching">Covariant methods and Join Point matching</a></dt></dl></div><div class="sect1"><a name="covariance-inJava5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="covariance-inJava5"></a>Covariance in Java 5</h2></div></div><p>
          Java 5 (and hence AspectJ 5) allows you to narrow the return type
          in an overriding method. For example:
        </p><pre class="programlisting">
		class A {
		  public A whoAreYou() {...}
		}
		
		class B extends A {
		  // override A.whoAreYou *and* narrow the return type.
		  public B whoAreYou() {...}
		}
		</pre></div><div class="sect1"><a name="covariance-and-join-point-matching"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="covariance-and-join-point-matching"></a>Covariant methods and Join Point matching</h2></div></div><p>The join point matching rules for <tt>call</tt>
          and <tt>execution</tt> pointcut designators are extended
          to match against covariant methods.</p><p>
              Given the classes <tt>A</tt> and <tt>B</tt>
              as defined in the previous section, and the program fragment
          </p><pre class="programlisting">
		A a = new A();
		B b = new B();
		a.whoAreYou();
		b.whoAreYou();
		</pre><p>The signatures for the call join point <tt>a.whoAreYou()</tt> are
		simply:</p><pre class="programlisting">
		A A.whoAreYou()
		</pre><p>The signatures for the call join point <tt>b.whoAreYou()</tt> are:
		</p><pre class="programlisting">
		A A.whoAreYou()
		B B.whoAreYou()
		</pre><p>Following the join point matching rules given in <a href="#jpsigs">Join Point Signatures</a>,</p><div class="variablelist"><dl><dt><a name="d0e3540"></a><span class="term">call(* whoAreYou())</span></dt><dd><p><a name="d0e3543"></a>Matches both calls, (since each call join point has at least
            one matching signature).
            </p></dd><dt><a name="d0e3546"></a><span class="term">call(* A.whoAreYou())</span></dt><dd><p><a name="d0e3549"></a>Matches both calls, (since each call join point has at least
            one matching signature).
            </p></dd><dt><a name="d0e3552"></a><span class="term">call(A whoAreYou())</span></dt><dd><p><a name="d0e3555"></a>Matches both calls, (since each call join point has at least
            one matching signature).
            </p></dd><dt><a name="d0e3558"></a><span class="term">call(A B.whoAreYou())</span></dt><dd><p><a name="d0e3561"></a>Does not match anything - neither of the call join points
            has a signature matched by this pattern.  A lint warning is
            given for the call <tt>a.whoAreYou()</tt> ("does not match
            because declaring type is A, if match required use target(B)").
            </p></dd><dt><a name="d0e3567"></a><span class="term">call(A+ B.whoAreYou())</span></dt><dd><p><a name="d0e3570"></a>Matches the call to <tt>b.whoAreYou()</tt> since
            the signature pattern matches the signature <tt>B B.whoAreYou()</tt>. 
            A lint warning is given for the call <tt>a.whoAreYou()</tt> ("does not match
            because declaring type is A, if match required use target(B)").
            </p></dd><dt><a name="d0e3582"></a><span class="term">call(B A.whoAreYou())</span></dt><dd><p><a name="d0e3585"></a>Does not match anything since neither join point has a 
            signature matched by this pattern.
            </p></dd><dt><a name="d0e3588"></a><span class="term">call(B whoAreYou())</span></dt><dd><p><a name="d0e3591"></a>Matches the call to <tt>b.whoAreYou()</tt> only.
            </p></dd><dt><a name="d0e3597"></a><span class="term">call(B B.whoAreYou())</span></dt><dd><p><a name="d0e3600"></a>Matches the call to <tt>b.whoAreYou()</tt> only.
            </p></dd></dl></div><p>The rule for signature matching at call and execution join points
		is unchanged from AspectJ 1.2: a call or execution pointcut matches if
		the signature pattern matches at least one of the signatures of the
		join point, and if the modifiers of the method or constructor are matched
		by any modifier pattern or annotation pattern that may be present.</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="varargs"></a>Chapter 6. Varargs</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#varargs-inJava5">Variable-length Argument Lists in Java 5</a></dt><dd><dl><dt><a href="#d0e3620">Calling Methods and Constructors with variable-length arguments</a></dt></dl></dd><dt><a href="#varargs-in-pcds">Using Variable-length arguments in advice and pointcut expressions</a></dt><dd><dl><dt><a href="#d0e3654">Matching signatures based on variable length argument types</a></dt><dt><a href="#d0e3756">Exposing variable-length arguments as context in pointcuts and advice</a></dt></dl></dd></dl></div><div class="sect1"><a name="varargs-inJava5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="varargs-inJava5"></a>Variable-length Argument Lists in Java 5</h2></div></div><p>
          Java 5 (and hence AspectJ 5) allows you to specify methods that take a 
          variable number of arguments of a specified type. This is achieved using
          an ellipsis (...) in the method signature as shown:    
        </p><pre class="programlisting">
		public void foo(int i, String... strings) { 
		}
		</pre><p>
            A method or constructor may take at most one variable length argument, and
            this must always be the last declared argument in the signature.
        </p><div class="sect2"><a name="d0e3620"></a><div class="titlepage"><div><h3 class="title"><a name="d0e3620"></a>Calling Methods and Constructors with variable-length arguments</h3></div></div><p>
             A <span class="emphasis"><i>varargs</i></span> method may be called with zero or more arguments
             in the variable argument position. For example, given the definition of 
             <tt>foo</tt> above, the following calls are all legal:
            </p><pre class="programlisting">
    	foo(5);
    	foo(5,"One String");
    	foo(7,"One String","Two Strings");
    	foo(3,"One String","Two Strings","Three Strings");	
    	</pre><p>A <span class="emphasis"><i>varargs</i></span> parameter is treated as an array within the 
            defining member. So in the body of <tt>foo</tt> we could write for example:
            </p><pre class="programlisting">
    	public void foo(int i, String... strings) {
    	  String[] someStrings = strings;
    	  // rest of method body
    	}
    	</pre><p>One consequence of this treatment of a varargs parameter as an array
            is that you can also call a varargs method with an array:</p><pre class="programlisting">
    	foo(7,new String[] {"One String","Two Strings"});
    	</pre></div></div><div class="sect1"><a name="varargs-in-pcds"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="varargs-in-pcds"></a>Using Variable-length arguments in advice and pointcut expressions</h2></div></div><p>AspectJ 5 allows variable-length arguments to be used for methods declared within
        aspects, and for inter-type declared methods and constructors, in accordance with the rules
        outlined in the previous section.</p><p>
        AspectJ 5 also allows variable length arguments to be matched by pointcut expressions and
        bound as formals in advice.
        </p><div class="sect2"><a name="d0e3654"></a><div class="titlepage"><div><h3 class="title"><a name="d0e3654"></a>Matching signatures based on variable length argument types</h3></div></div><p>
            Recall from the definition of signature patterns given in the chapter on
            annotations (<a href="#signaturePatterns">Signature Patterns</a>), that <tt>MethodPattern</tt>
            and <tt>ConstructorPattern</tt> are extended to allow a <tt>varargs</tt>
            pattern in the last argument position of a method or constructor signature.
            </p><pre class="programlisting">  	
 		FormalsPattern := '..' (',' FormalsPatternAfterDotDot)? |
		                  OptionalParensTypePattern (',' FormalsPattern)* |
		                  TypePattern '...'
		                  
		FormalsPatternAfterDotDot := 
		        OptionalParensTypePattern (',' FormalsPatternAfterDotDot)* |
		        TypePattern '...'

    	</pre><p>
                Method and constructor patterns are used in the <tt>call</tt>,
                <tt>execution</tt>, <tt>initialization</tt>,
                <tt>preinitialization</tt>, and <tt>withincode</tt>
                pointcut designators. Some examples of usage follow:
            </p><div class="variablelist"><dl><dt><a name="d0e3690"></a><span class="term">call(* org.xyz.*.*(int, String...))</span></dt><dd><p><a name="d0e3693"></a>
            	Matches a call join point for a call to a method defined in the
            	<tt>org.xyz</tt> package, taking an <tt>int</tt>
            	and a <tt>String vararg</tt>.
            </p></dd><dt><a name="d0e3705"></a><span class="term">execution(* org.xyz.*.*(Integer...))</span></dt><dd><p><a name="d0e3708"></a>
            	Matches an execution join point for the execution of a method defined in the
            	<tt>org.xyz</tt> package, taking an <tt>Integer vararg</tt>.
            </p></dd><dt><a name="d0e3717"></a><span class="term">initialization(org.xyz.*.new((Foo || Goo)...))</span></dt><dd><p><a name="d0e3720"></a>
            	Matches the initialization join point for the construction of an
            	object in the <tt>org.xyz</tt> package via a constructor
            	taking either a variable number of <tt>Foo</tt> parameters or
            	a variable number of <tt>Goo</tt> parameters. (This example
            	illustrating the use of a type pattern with ...).
            </p></dd></dl></div><p>A variable argument parameter and an array parameter are treated as distinct
        signature elements, so given the method definitions:
        </p><pre class="programlisting">
    	void foo(String...);
    	void bar(String[]);
    	</pre><p>
            The pointcut <tt>execution(* *.*(String...))</tt> matches the execution join point
            for <tt>foo</tt>, but not <tt>bar</tt>. The pointcut 
            <tt>execution(* *.*(String[]))</tt> matches the execution join point
            for <tt>bar</tt> but not <tt>foo</tt>.
        </p></div><div class="sect2"><a name="d0e3756"></a><div class="titlepage"><div><h3 class="title"><a name="d0e3756"></a>Exposing variable-length arguments as context in pointcuts and advice</h3></div></div><p>
            When a varargs parameter is used within the body of a method, it has
            an array type, as discussed in the introduction to this section. We follow the
            same convention when binding a varargs parameter via the <tt>args</tt>
            pointcut designator. Given a method
            </p><pre class="programlisting">
		public void foo(int i, String... strings) { 
		}
		</pre><p>
            The call or execution join points for <tt>foo</tt> will be matched
            by the pointcut <tt>args(int,String[])</tt>. It is not permitted
            to use the varargs syntax within an args pointcut designator - so you
            <span class="emphasis"><i>cannot</i></span> write <tt>args(int,String...)</tt>.
            </p><p>
            Binding of a varargs parameter in an advice statement is straightforward:
            </p><pre class="programlisting">
		before(int i, String[] ss) : call(* foo(int,String...)) &amp;&amp; args(i,ss) {
		  // varargs String... argument is accessible in advice body through ss
		  // ...
		}
		</pre><p>Since you cannot use the varargs syntax in the <tt>args</tt>
             pointcut designator, you also cannot use the varargs syntax to declare
             advice parameters.</p><p>Note: the proposal in this section does not allow you to 
            distinguish between a join point with a signature (int, String...)
            and a join point with a signature (int, String[]) based 
            <span class="emphasis"><i>solely</i></span> on the use of the <tt>args</tt>
            pointcut designator. If this distinction is required, <tt>args</tt>
            can always be coupled with <tt>call</tt> or 
            <tt>execution</tt>.</p></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="enumeratedtypes"></a>Chapter 7. Enumerated Types</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#enums-in-java5">Enumerated Types in Java 5</a></dt><dt><a href="#enums-in-aspectj5">Enumerated Types in AspectJ 5</a></dt></dl></div><div class="sect1"><a name="enums-in-java5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="enums-in-java5"></a>Enumerated Types in Java 5</h2></div></div><p>Java 5 (and hence AspectJ 5) provides explicit support for
      enumerated types. In the simplest case, you can declare an enumerated
      type as follows:</p><pre class="programlisting">
      public enum ProgrammingLanguages {
       COBOL,C,JAVA,ASPECTJ
      }
      </pre><p>Enumerated types are just classes, and they can contain method
      and field declarations, and may implement interfaces. Enums may only
      have private constructors, and may not be extended.</p><p>Enumerated types in Java 5 all implicitly extend the type
      <tt>java.lang.Enum</tt>. It is illegal to explicitly
      declare a subtype of this class.</p></div><div class="sect1"><a name="enums-in-aspectj5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="enums-in-aspectj5"></a>Enumerated Types in AspectJ 5</h2></div></div><p>
      AspectJ 5 supports the declaration of enumerated types just as Java 5
      does. Because of the special restrictions Java 5 places around enumerated
      types, AspectJ makes the following additional restrictions:
      </p><div class="itemizedlist"><ul><li><a name="d0e3829"></a>You cannot use declare parents to change the super type of
          an enum.</li><li><a name="d0e3831"></a>You cannot use declare parents to declare java.lang.Enum as
          the parent of any type.</li><li><a name="d0e3833"></a>You cannot make inter-type constructor declarations on an
          enum.</li><li><a name="d0e3835"></a>You cannot extend the set of values in an enum via any
          ITD-like construct.</li><li><a name="d0e3837"></a>You cannot make inter-type method or field declarations on 
          an enum.</li><li><a name="d0e3839"></a>You cannot use declare parents to make an enum type implement
          an interface.</li></ul></div><p>In theory, the last of these two items <span class="emphasis"><i>could</i></span>
      be supported. However, AspectJ 5 follows the simple rule that <span class="emphasis"><i>
      an enum type cannot be the target of an inter-type declaration or declare
      parents statement</i></span>. This position may be relaxed in a future
      version of AspectJ.</p><p>If an enum is named explicitly as the target of a
    declare parents statement, a compilation error will result. If an enumerated
    type is matched by a non-explicit type pattern used in a declare parents
    statement it will be ignored (and an XLint warning issued).</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="pertypewithin"></a>Chapter 8. The pertypewithin Aspect Instantiation Model</h2></div></div><p>
    AspectJ 5 defines a new per-clause type for aspect instantiation: 
    <tt>pertypewithin</tt>. Unlike the other per-clauses,
    <tt>pertypewithin</tt> takes a type pattern:  
  </p><pre class="programlisting">
  	PerTypeWithin := 'pertypewithin' '(' OptionalParensTypePattern ')'
	</pre><p>
      When an aspect is declared using the <tt>pertypewithin</tt>
      instantiation model, one new aspect instance will be created for each
      type matched by the associated type pattern.
  </p><p>
      Pertypewithin aspects have <tt>aspectOf</tt> and 
      <tt>hasAspect</tt> methods with the following signatures:
  </p><pre class="programlisting">
  	/**
  	 * return true if this aspect has an instance associated with
  	 * the given type.
  	 */
  	public static boolean hasAspect(Class clazz)
  	
  	/**
  	 * return the instance associated with the given type.
  	 * Throws NoAspectBoundException if there is no such
  	 * aspect.
  	 */
  	 public static P aspectOf(Class clazz)
	</pre><p>
       Where <tt>P</tt> is the type of the <tt>pertypewithin</tt>
       aspect.
   </p><p>
       In common with the other per-clause instantiation models, the execution
       of any advice declared within a <tt>pertypewithin</tt> aspect
       is conditional upon an implicit pointcut condition. In this case, that
       any join point be <tt>within</tt> the type that the executing
       aspect is an <tt>aspectOf</tt>. For example, given the aspect
       definition
   </p><pre class="programlisting">
     import java.util.*;
     
     public aspect InstanceTracking pertypewithin(org.xyz..*) {
     
       // use WeakHashMap for auto-garbage collection of keys  	 
       private Map&lt;Object,Boolean&gt; instances = new WeakHashMap&lt;Object,Boolean&gt;();

       after(Object o) returning() : execution(new(..)) &amp;&amp; this(o) {
         instances.put(o,true);
       }

       public Set&lt;?&gt; getInstances() {
         return instances.keySet();
       }
       
     } 
	</pre><p>
	    Then one aspect instance will be created for each type within
	    <tt>org.xyz..*</tt>. For each aspect instance, the
	    after returning advice will match only the execution of constructors
	    in the type that the aspect is an instance of. The net result is that
	    the aspect tracks all known instances of each type within
	    <tt>org.xyz..*</tt>. To get access to the instances, a
	    programmer can simply write 
	    <tt>InstanceTracking.aspectOf(org.xyz.SomeType.class).getInstances()</tt>.
	</p><p>
        A <tt>pertypewithin</tt> aspect may optionally be declared
        with a single generic type parameter. In this case, for each type 
        <tt>T</tt> matched by the type pattern, the aspect instance
        created will be of type <tt>PerTypeWithinAspect&lt;T&gt;</tt>. 
        So the previous example could also be written as:
    </p><pre class="programlisting">
  	 public aspect InstanceTracking&lt;T&gt; pertypewithin(org.xyz..*) {
  	 
	   // use WeakHashMap for auto-garbage collection of keys  	 
  	   private Map&lt;T, Boolean&gt; instances = new WeakHashMap&lt;T, Boolean&gt;();
  	   
  	   after(T t) returning : execution(new(..)) &amp;&amp; this(t) {
  	     instances.put(t, true);
  	   }
  	 
  	   public Set&lt;T&gt; getInstances() {
  	   	  return instances.keySet();
  	   }
  	   
  	 }
	</pre><p>
        The <tt>pertypewithin</tt> aspect instantiation model should
        be used when the implementation of a crosscutting concern requires that
        some state be maintained for each type in a set of types. To maintain
        state for a single type, it is easier to use a static inter-type declared
        field. Examples of usage include instance tracking, profiling, and the
        implementation of a common tracing idiom that uses one Logger per 
        traced class.
    </p></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="ataspectj"></a>Chapter 9. An Annotation Based Development Style</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#ataspectj-intro">Introduction</a></dt><dt><a href="#ataspectj-aspects">Aspect Declarations</a></dt><dt><a href="#ataspectj-pcadvice">Pointcuts and Advice</a></dt><dd><dl><dt><a href="#d0e3980">Pointcuts</a></dt><dt><a href="#d0e4101">Advice</a></dt></dl></dd><dt><a href="#ataspectj-itds">Inter-type Declarations</a></dt><dt><a href="#ataspectj-declare">Declare statements</a></dt><dt><a href="#ataspectj-aspectof">aspectOf() and hasAspect() methods</a></dt></dl></div><div class="sect1"><a name="ataspectj-intro"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ataspectj-intro"></a>Introduction</h2></div></div><p>In addition to the familiar AspectJ code-based style of aspect
      declaration, AspectJ 5 also supports an annotation-based style of 
      aspect declaration. We informally call the set of annotations that
      support this development style the "@AspectJ" annotations.</p><p>
          AspectJ 5 allows aspects and their members to be specified using
          either the code style or the annotation style. Whichever style you
          use, the AspectJ weaver ensures that your program has exactly the
          same semantics. It is, to quote a famous advertising campaign, 
          "a choice, not a compromise". The two styles can be mixed within
          a single application, and even within a single source file, though
          we doubt this latter mix will be recommended in practice.
        </p><p>
          The use of the @AspectJ annotations means that there are large 
          classes of AspectJ applications that can be compiled by a regular
          Java 5 compiler, and subsequently woven by the AspectJ weaver (for
          example, as an additional build stage, or as late as class load-time).
          In this chapter we introduce the @AspectJ annotations and show how
          they can be used to declare aspects and aspect members.
        </p></div><div class="sect1"><a name="ataspectj-aspects"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ataspectj-aspects"></a>Aspect Declarations</h2></div></div><p>
      Aspect declarations are supported by the
            <tt>org.aspectj.lang.annotation.Aspect</tt> annotation.
      The declaration:
        </p><pre class="programlisting">
     @Aspect
     public class Foo {}
         </pre><p>Is equivalent to:</p><pre class="programlisting">
     public aspect Foo {}
         </pre><p>And since issingleton() is the default aspect instantiation model it is equivalent to:</p><pre class="programlisting">
      @Aspect("issingleton()")
      public class Foo {}
         </pre><p>Privileged aspects are not supported by the annotation style</p><p>To specify an aspect an aspect instantiation model (the default is
    singleton), provide the perclause as the
            <tt>@Aspect</tt> value.
    For example:
        </p><pre class="programlisting">
     @Aspect("perthis(execution(* abc..*(..)))")
     public class Foo {}

     is equivalent to...

     public aspect Foo perthis(execution(* abc..*(..))) {}
         </pre></div><div class="sect1"><a name="ataspectj-pcadvice"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ataspectj-pcadvice"></a>Pointcuts and Advice</h2></div></div><p>
          Pointcut and advice declarations can be made using the
            <tt>Pointcut, Before, After, AfterReturning, AfterThrowing,</tt>
          and
            <tt>Around</tt> annotations.
        </p><div class="sect2"><a name="d0e3980"></a><div class="titlepage"><div><h3 class="title"><a name="d0e3980"></a>Pointcuts</h3></div></div><p>
              Pointcuts are specified using the
                <tt>org.aspectj.lang.annotation.Pointcut</tt> annotation
              on a method declaration. The method should have a
                <tt>void</tt>
              return type. The parameters of the method correspond to the parameters
              of the pointcut. The modifiers of the method correspond to the modifiers
              of the pointcut.
            </p><p>
              As a general rule, the
                <tt>@Pointcut</tt> annotated method must have an empty method body
              and must not have any
                <tt>throws</tt> clause. If formal are bound (using
                <tt>args(), target(), this(), @args(), @target(), @this(), @annotation())</tt> in the
              pointcut, then they must appear in the method signature.
            </p><p>
            There is one special case to the general rule for when you use
                <tt>if()</tt> pointcut
            as detailled in the next section.
            </p><p>A simple example:</p><pre class="programlisting">
     @Pointcut("call(* *.*(..))")
     void anyCall() {}

     is equivalent to...

     pointcut anyCall() : call(* *.*(..));
             </pre><p>An example with formal bindings:</p><pre class="programlisting">
     @Pointcut("call(* *.*(int)) &amp;&amp; args(i) &amp;&amp; target(callee)")
     void someCall(int i, Foo callee) {}

     is equivalent to...

     pointcut anyCall(int i, Foo callee) : call(* *.*(int)) &amp;&amp; args(i) &amp;&amp; target(callee);
             </pre><p>An example with modifiers (it is also good to remember that Java 5 annotations are not inherited):</p><pre class="programlisting">
     @Pointcut("")
     protected abstract void anyCall();

     is equivalent to...

     protected abstract pointcut anyCall();
             </pre><p>
          Using the code style, types referenced in pointcut expressions are 
          resolved with respect to the imported types in the compilation unit.
          When using the annotation style, types referenced in pointcut 
          expressions are resolved in the absence of any imports and so have
          to be fully qualified if they are not by default visible to the
          declaring type (outside of the declaring package and
                <tt>java.lang</tt>). This
          to not apply to type patterns with wildcards, which are always resolved
          in a global scope.
            </p><p>
          Consider the following compilation unit:
            </p><pre class="programlisting">
     package org.aspectprogrammer.examples;

     import java.util.List;

     public aspect Foo {

       pointcut listOperation() : call(* List.*(..));

       pointcut anyUtilityCall() : call(* java.util..*(..));

     }
             </pre><p>
      Using the annotation style this would be written as:
            </p><pre class="programlisting">
     package org.aspectprogrammer.examples;

     import java.util.List; // redundant but harmless

     @Aspect
     public class Foo {

       @Pointcut("call(* java.util.List.*(..))") // must qualify
       void listOperation() {}

       @Pointcut("call(* java.util..*(..))")
       void anyUtilityCall() {}

     }
             </pre><p>The
                <tt>value</tt> attribute of the
                <tt>Pointcut</tt> declaration may contain any valid
                AspectJ pointcut declaration - though <tt>if()</tt> pointcut is a special case explained below.
            </p><p>The special case for the <tt>if()</tt> pointcut.</p><p>In code style, it is possible to use the <tt>if(...)</tt> poincut to implement
                conditional pointcut whose residual if form will be evaluated at runtime. The <tt>if(...)</tt>
                body can be any valid Java boolean expression, and can use any exposed formal, as well as the join point forms
                <tt>thisJoinPoint, thisJoinPointStaticPart and thisJoinPointEnclosingStaticPart</tt>.
             </p><p>
                When using the annotation style, it would be really a pain to write a valid Java expression within
                the annotation value so the syntax differs sligthly, whilst providing the very same
                semantics and runtime behaviour. Take the following examples:
            </p><pre class="programlisting">
     @Pointcut("call(* *.*(int)) &amp;&amp; args(i) &amp;&amp; if()")
     public static boolean someCallWithIfTest(int i) {
        return i &gt; 0;
     }

     is equivalent to...

     pointcut someCallWithIfTest(int i) : call(* *.*(int)) &amp;&amp; args(i) &amp;&amp; if(i &gt; 0);
             </pre><p> and the following is also a valid form:</p><pre class="programlisting">
     static int COUNT = 0;

     @Pointcut("call(* *.*(int)) &amp;&amp; args(i) &amp;&amp; if()")
     public static boolean someCallWithIfTest(int i, JoinPoint jp, JoinPoint.EnclosingStaticPart esjp) {
        // can call any kind of method (though this method is a static one)
        return i &gt; 0
               &amp;&amp; jp.getSignature().getName.startsWith("doo")
               &amp;&amp; esjp.getSignature().getName().startsWith("test")
               &amp;&amp; COUNT++ &lt; 10;
     }

     @Before("someCallWithIfTest(arg0, jp, enc)") // see how the pointcut is referenced: we obey its exact signature
     public void beforeAdviceWithRuntimeTest(int arg0, JoinPoint jp, JoinPoint.EnclosingStaticPart enc) {
        //...
     }

     // Note that the following is NOT valid
     /*
     @Before("call(* *.*(int)) &amp;&amp; args(i) &amp;&amp; if()")
     public void advice(int i) {
        // so you were writing an advice or an if body ?
     }
     */
             </pre><p>
                It is thus possible with the annotation style to use the <tt>if()</tt> pointcut
                only within an <tt>@Pointcut</tt> expression. The <tt>if()</tt> must not contain any
                body. The so annotated <tt>@Pointcut</tt> method must then be of the form <tt>public static boolean</tt>
                and can use formal bindings as usual.
                Extra <span class="emphasis"><i>implicit</i></span> (thus unbound) arguments of type JoinPoint, JoinPoint.StaticPart and JoinPoint.EnclosingStaticPart can also be used
                (they can't for regular pointcut without <tt>if()</tt> form).
            </p><p>
                The special forms <tt>if(true)</tt> and <tt>if(false)</tt> can be used in a more
                general way and don't imply that the pointcut method must have a body.
                You can thus write <tt>@Before("somePoincut() &amp;&amp; if(false)")</tt>.
            </p></div><div class="sect2"><a name="d0e4101"></a><div class="titlepage"><div><h3 class="title"><a name="d0e4101"></a>Advice</h3></div></div><p>In this section we first discuss the use of annotations for
          simple advice declarations. Then we show how
                <tt>thisJoinPoint</tt>
          and its siblings are handled in the body of advice and discuss the 
          treatment of
                <tt>proceed</tt> in around advice.
            </p><p>Using the annotation style, an advice declaration is written as
          a regular Java method with one of the
                <tt>Before, After, AfterReturning,
          AfterThrowing,</tt> or
                <tt>Around</tt> annotations. Except in
          the case of around advice, the method should return void. The method should 
          be declared public.
            </p><p>A method that has an advice annotation is treated exactly as an
          advice declaration by AspectJ's weaver. This includes the join points that
          arise when the advice is executed (an adviceexecution join point, not a 
          method execution join point), and the restriction that advice cannot be
          invoked explicitly (the weaver will issue an error if an advice method
          is explicitly invoked).</p><p>The following example shows a simple before advice declaration in
          both styles:</p><pre class="programlisting">
     before() : call(* org.aspectprogrammer..*(..)) &amp;&amp; this(Foo) {
       System.out.println("Call from Foo");
     }

     is equivalent to...

     @Before("call(* org.aspectprogrammer..*(..)) &amp;&amp; this(Foo)")
     public void callFromFoo() {
       System.out.println("Call from Foo");
     }
             </pre><p>Notice one slight difference between the two advice declarations: in
          the annotation style, the advice has a name, "callFromFoo". Even though
          advice cannot be invoked explicitly, this name is useful in join point
          matching when advising advice execution. For this reason, and to preserve
          exact semantic equivalence between the two styles, we also support the
                <tt>org.aspectj.lang.annotation.AdviceName</tt> annotation.
          The exact equivalent declarations are:
            </p><pre class="programlisting">
     @AdviceName("callFromFoo")
     before() : call(* org.aspectprogrammer..*(..)) &amp;&amp; this(Foo) {
       System.out.println("Call from Foo");
     }

     is equivalent to...

     @Before("call(* org.aspectprogrammer..*(..)) &amp;&amp; this(Foo)")
     public void callFromFoo() {
       System.out.println("Call from Foo");
     }
             </pre><p>If the advice body needs to know which particular
                <tt>Foo</tt>
          was doing the calling, just add a parameter to the advice declaration.
            </p><pre class="programlisting">
     @AdviceName("callFromFoo")
     before(Foo foo) : call(* org.aspectprogrammer..*(..)) &amp;&amp; this(foo) {
       System.out.println("Call from Foo: " + foo);
     }

     is equivalent to...

     @Before("call(* org.aspectprogrammer..*(..)) &amp;&amp; this(foo)")
     public void callFromFoo(Foo foo) {
       System.out.println("Call from Foo: " + foo);
     }
             </pre><p>If the advice body needs access to
                <tt>thisJoinPoint</tt>,
                <tt>thisJoinPointStaticPart</tt>,
                <tt>thisEnclosingJoinPointStaticPart</tt> then these need to
          be declared as additional method parameters when using the annotation
          style. 
            </p><pre class="programlisting">
     @AdviceName("callFromFoo")
     before(Foo foo) : call(* org.aspectprogrammer..*(..)) &amp;&amp; this(foo) {
       System.out.println("Call from Foo: " + foo + " at "
                          + thisJoinPoint);
     }

     is equivalent to...

     @Before("call(* org.aspectprogrammer..*(..)) &amp;&amp; this(foo)")
     public void callFromFoo(JoinPoint thisJoinPoint, Foo foo) {
       System.out.println("Call from Foo: " + foo + " at "
                          + thisJoinPoint);
     }
             </pre><p>Advice that needs all three variables would be declared:</p><pre class="programlisting">
     @Before("call(* org.aspectprogrammer..*(..)) &amp;&amp; this(Foo)")
     public void callFromFoo(JoinPoint thisJoinPoint,
                             JoinPoint.StaticPart thisJoinPointStaticPart,
                             JoinPoint.EnclosingStaticPart thisEnclosingJoinPointStaticPart) {
         // ...
     }
             </pre><p>
                <tt>JoinPoint.EnclosingStaticPart</tt> is a new (empty) sub-interface
          of
                <tt>JoinPoint.StaticPart</tt> which allows the AspectJ weaver to
          distinguish based on type which of
                <tt>thisJoinPointStaticPart</tt> and
                <tt>thisEnclosingJoinPointStaticPart</tt> should be passed in a given
          parameter position.
            </p><p>
                <tt>After</tt> advice declarations take exactly the same form
      as
                <tt>Before</tt>, as do the forms of
                <tt>AfterReturning</tt>
      and
                <tt>AfterThrowing</tt> that do not expose the return type or
      thrown exception respectively.
            </p><p>
      To expose a return value with after returning advice simply declare the returning
      parameter as a parameter in the method body and bind it with the "returning"
      attribute:
            </p><pre class="programlisting">
      after() returning : criticalOperation() {
        System.out.println("phew");
      }

      after() returning(Foo f) : call(Foo+.new(..)) {
        System.out.println("It's a Foo: " + f);
      }

      can be written as...

      @AfterReturning("criticalOperation()")
      public void phew() {
        System.out.println("phew");
      }

      @AfterReturning(pointcut="call(Foo+.new(..))",returning="f")
      public void itsAFoo(Foo f) {
        System.out.println("It's a Foo: " + f);
      }
            </pre><p>(Note the use of the "pointcut=" prefix in front of the pointcut
      expression in the returning case).</p><p>After throwing advice works in a similar fashion, using the
                <tt>throwing</tt> attribute when needing to expose a
      thrown exception.
            </p><p>For around advice, we have to tackle the problem of
                <tt>proceed</tt>.
      One of the design goals for the annotation style is that a large class of
      AspectJ applications should be compilable with a standard Java 5 compiler.
      A straight call to
                <tt>proceed</tt> inside a method body:
            </p><pre class="programlisting">
     @Around("call(* org.aspectprogrammer..*(..))")
     public Object doNothing() {
       return proceed(); // CE on this line
     }
             </pre><p>will result in a "No such method" compilation error. For this
      reason AspectJ 5 defines a new sub-interface of
                <tt>JoinPoint</tt>,
                <tt>ProceedingJoinPoint</tt>.
            </p><pre class="programlisting">
     public interface ProceedingJoinPoint extends JoinPoint {
       public Object proceed(Object[] args);
     }
             </pre><p>The around advice given above can now be written as:</p><pre class="programlisting">
     @Around("call(* org.aspectprogrammer..*(..))")
     public Object doNothing(ProceedingJoinPoint thisJoinPoint) {
       return thisJoinPoint.proceed();
     }
             </pre><p>Here's an example that uses parameters for the proceed call:</p><pre class="programlisting">
     public aspect ProceedAspect {
       pointcut setAge(int i): call(* setAge(..)) &amp;&amp; args(i);

       Object around(int i): setAge(i) {
         return proceed(i*2);
       }
     }

     can be written as...

     @Aspect
     public class ProceedAspect {

       @Pointcut("call(* setAge(..)) &amp;&amp; args(i)")
       void setAge(int i) {}

       @Around("setAge(i)")
       public Object twiceAsOld(ProceedingJoinPoint thisJoinPoint, int i) {
         return thisJoinPoint.proceed(new Object[]{i*2}); //using Java 5 autoboxing
       }

     }

     Note that the ProceedingJoinPoint does not need to be passed as the proceed(..) arguments.
             </pre></div></div><div class="sect1"><a name="ataspectj-itds"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ataspectj-itds"></a>Inter-type Declarations</h2></div></div><p>
      Inter-type declarations are challenging to support using an annotation style.
      It's very important to preserve the exact same semantics between the code style
      and the annotation style. We also want to support compilation of a large set
      of AspectJ applications using a standard Java 5 compiler. For these reasons, in
      the initial release of AspectJ 5 we will only support inter-type declarations
      on interfaces using the annotation style.
        </p><p>
      Consider the following aspect:
        </p><pre class="programlisting">
     public aspect MoodIndicator {

        public interface Moody {};

        private Mood Moody.mood = Mood.HAPPY;

        public Mood Moody.getMood() {
          return mood;
        }

        declare parents : org.xyz..* implements Moody;

        before(Moody m) : execution(* *.*(..)) &amp;&amp; this(m) {
           System.out.println("I'm feeling " + m.getMood());
        }
     }
         </pre><p>
      This declares an interface
            <tt>Moody</tt>, and then makes two
      inter-type declarations on the interface - a field that is private to the
      aspect, and a method that returns the mood. Within the body of the inter-type
      declared method
            <tt>getMoody</tt>, the type of
            <tt>this</tt>
      is
            <tt>Moody</tt> (the target type of the inter-type declaration).
        </p><p>Using the annotation style this aspect can be written:
        </p><pre class="programlisting">
     @Aspect
     public class MoodIndicator {

        public interface Moody {
          Mood getMood();
        };

        @DeclareParents("org.xzy..*")
        class MoodyImpl implements Moody {
           private Mood mood = Mood.HAPPY;

           public Mood getMood() {
             return mood;
           }
        }

        @Before("execution(* *.*(..)) &amp;&amp; this(m)")
        void feelingMoody(Moody m) {
           System.out.println("I'm feeling " + m.getMood());
        }
     }
         </pre><p>
      This is very similar to the mixin mechanism supported by AspectWerkz. The 
      effect of the
            <tt>@DeclareParents</tt> annotation is equivalent to
      a declare parents statement that all types matching the type pattern implement
      the interface implemented by the annotated class. In addition, the member
      declarations within the annotated class are treated as inter-type declarations
      on the implemented interface. Note how this scheme operates within the constraints
      of Java type checking and ensures that
            <tt>this</tt> has access
      to the exact same set of members as in the code style example.
        </p><p>The annotated class may only extend
            <tt>Object</tt>, and may
      only implement a single interface. The interface implemented by the class may
      itself extend other interfaces.
        </p></div><div class="sect1"><a name="ataspectj-declare"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ataspectj-declare"></a>Declare statements</h2></div></div><p>The previous section on inter-type declarations covered the case
      of declare parents ... implements. The 1.5.0 release of AspectJ 5 will
      not support annotation style declarations for declare parents ... extends
      and declare soft (programs with these declarations would not in general
      be compilable by a regular Java 5 compiler, reducing the priority of
      their implementation). These may be supported in a future release.</p><p>Declare precedence and declare annotation
            <span class="emphasis"><i>will</i></span>
       be supported. For declare precedence, use the
            <tt>@DeclarePrecedence</tt>
       annotation as in the following example:
        </p><pre class="programlisting">
     public aspect SystemArchitecture {
       declare precedence : Security*, TransactionSupport, Persistence;

       // ...
     }

     can be written as:

     @Aspect
     @DeclarePrecedence("Security*,org.xyz.TransactionSupport,org.xyz.Persistence")
     public class SystemArchitecture {

       // ...
     }
         </pre><p>
     Declare annotation is supported via annotations on a dummy type member. If the
            <tt>Target</tt> specification of the annotation allows it, use a field,
     otherwise declare a member of the type required by the
            <tt>Target</tt>.
     For example:
        </p><pre class="programlisting">
     public aspect DeclareAnnotationExamples {
       declare annotation : org.xyz.model..* : @BusinessDomain;

       declare annotation : public * BankAccount+.*(..) : @Secured(role="supervisor");

       declare anotation : * DAO+.* : @Persisted;

     }

     can be written as...

     @Aspect
     public class DeclareAnnotationExamples {

       @DeclareAnnotation("org.xyz.model..*)
       @BusinessDomain Object modelClass;

       // this example assumes that the @Secured annotation has a Target
       // annotation with value ElementType.METHOD
       @DeclareAnnotation("public * org.xyz.banking.BankAccount+.*(..)")
       @Secured(role="supervisor) void bankAccountMethod();

       @DeclareAnnotation("* DAO+.*")
       @Persisted Object daoFields;
     }
         </pre><p>We also support annotation style declarations for declare warning and
     declare error - any corresponding warnings and errors will be emitted at
     weave time, not when the aspects containing the declarations are compiled.
     (This is the same behaviour as when using declare warning or error with the
     code style). Declare warning and error declarations are made by annotating
     a string constant whose value is the message to be issued.</p><p>Note that the String must be a constant and not the result of the invocation
     of a static method for example.</p><pre class="programlisting">
       declare warning : call(* javax.sql..*(..)) &amp;&amp; !within(org.xyz.daos..*)
                       : "Only DAOs should be calling JDBC.";

       declare error : execution(* IFoo+.*(..)) &amp;&amp; !within(org.foo..*)
                     : "Only foo types can implement IFoo";

       can be written as...

       @DeclareWarning("call(* javax.sql..*(..)) &amp;&amp; !within(org.xyz.daos..*)")
       static final String aMessage = "Only DAOs should be calling JDBC.";

       @DeclareError("execution(* IFoo+.*(..)) &amp;&amp; !within(org.foo..*)")
       static final String badIFooImplementors = "Only foo types can implement IFoo";

       // the following is not valid since the message is not a String constant
       @DeclareError("execution(* IFoo+.*(..)) &amp;&amp; !within(org.foo..*)")
       static final String badIFooImplementorsCorrupted = getMessage();
       static String getMessage() {
           return "Only foo types can implement IFoo " + System.currentTimeMillis();
       }

         </pre></div><div class="sect1"><a name="ataspectj-aspectof"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ataspectj-aspectof"></a>aspectOf() and hasAspect() methods</h2></div></div><p>A central part of AspectJ's programming model is that aspects
      written using the code style and compiled using ajc support
            <tt>aspectOf</tt> and
            <tt>hasAspect</tt> static
      methods. When developing an aspect using the annotation style and compiling
      using a regular Java 5 compiler, these methods will not be visible to the 
      compiler and will result in a compilation error if another part of the
      program tries to call them.
        </p><p>To provide equivalent support for AspectJ applications compiled with
          a standard Java 5 compiler, AspectJ 5 defines the
            <tt>Aspects</tt>
          utility class:
        </p><pre class="programlisting">
      public class Aspects {

        /* variation used for singleton, percflow, percflowbelow */
        static&lt;T&gt; public static T aspectOf(T aspectType) {...}

        /* variation used for perthis, pertarget */
        static&lt;T&gt; public static T aspectOf(T aspectType, Object forObject) {...}

        /* variation used for pertypewithin */
        static&lt;T&gt; public static T aspectOf(T aspectType, Class forType) {...}

        /* variation used for singleton, percflow, percflowbelow */
        public static boolean hasAspect(Object anAspect) {...}

        /* variation used for perthis, pertarget */
        public static boolean hasAspect(Object anAspect, Object forObject) {...}

        /* variation used for pertypewithin */
        public static boolean hasAspect(Object anAspect, Class forType) {...}
      }
        </pre></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="reflection"></a>Chapter 10. New Reflection Interfaces</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#reflection_api">The Aspect Class</a></dt></dl></div><p>
      AspectJ 5 provides support for runtime reflection of aspect types. The class <tt>Aspect</tt> is
      analogous to the Java class <tt>Class</tt> and provides access to the members of an aspect. 
  </p><div class="sect1"><a name="reflection_api"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="reflection_api"></a>The Aspect Class</h2></div></div><p>
	    
	</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="miscellaneous"></a>Chapter 11. Other Changes in AspectJ 5</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#d0e4336">Pointcuts</a></dt><dd><dl><dt><a href="#d0e4339">Binding of formals</a></dt><dt><a href="#d0e4348">Additional lint warnings</a></dt></dl></dd><dt><a href="#declare-soft">Declare Soft</a></dt><dt><a href="#d0e4390">Tools</a></dt><dd><dl><dt><a href="#d0e4393">Aspectpath</a></dt></dl></dd></dl></div><div class="sect1"><a name="d0e4336"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="d0e4336"></a>Pointcuts</h2></div></div><div class="sect2"><a name="d0e4339"></a><div class="titlepage"><div><h3 class="title"><a name="d0e4339"></a>Binding of formals</h3></div></div><p>
           AspectJ 5 is more liberal than AspectJ 1.2.1 in accepting pointcut expressions
           that bind context variables in more than one location. For example, AspectJ
           1.2.1 does not allow:
           </p><pre class="programlisting">
       	pointcut foo(Foo foo) : (execution(* *(..)) &amp;&amp; this(foo) ) ||
       	                                (set(* *) &amp;&amp; target(foo));
		</pre><p>
		     whereas this expression is permitted in AspectJ 5. Each context variable must
		     be bound exactly once in each branch of a disjunction, and the disjunctive branches
		     must be mutually exclusive. In the above example for instance, no join point
		     can be both an execution join point and a set join point so the two branches
		     are mutually exclusive.
		  </p></div><div class="sect2"><a name="d0e4348"></a><div class="titlepage"><div><h3 class="title"><a name="d0e4348"></a>Additional lint warnings</h3></div></div><p>
            Discuss detection of common errors -&gt; warning/error, eg. conjunction of more than one
            kind of join point. Differing numbers of args in method signature / args / @args /
            @parameters.
          </p></div></div><div class="sect1"><a name="declare-soft"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="declare-soft"></a>Declare Soft</h2></div></div><p>
          The semantics of the <tt>declare soft</tt> statement have been 
          refined in AspectJ 5 to only soften exceptions that are not already runtime 
          exceptions. If the exception type specified in a declare soft statement is <tt>RuntimeException</tt>
          or a subtype of <tt>RuntimeException</tt> then a new XLint warning will be issued:</p><pre class="programlisting">
       	  declare soft : SomeRuntimeException : execution(* *(..));
       	  
       	  &amp;gt;&amp;gt; "SomeRuntimeException will not be softened as it is already a RuntimeException" [XLint:runtimeExceptionNotSoftened]
		</pre><p>
	       This XLint message can be controlled by setting the <tt>runtimeExceptionNotSoftened</tt> XLint parameter.
 	   </p><p>
	      If the exception type specified in a declare soft statement is a super type of <tt>RuntimeException</tt>
	      (such as <tt>Exception</tt> for example) then any <font color="red">&lt;i&gt;checked&lt;/i&gt;</font> exception thrown at a matched join point, 
	      where the exception is an instance of the softened exception, will be softened to an 
	      <tt>org.aspectj.lang.SoftException</tt>. 
      </p><pre class="programlisting">
       	public aspect SoftenExample {
       	
       	  declare soft : Exception : execution(* Foo.*(..));
       	
       	}
       	
       	class Foo {
       	
       	  public static void main(String[] args) {
       	    Foo foo = new Foo();
       	    foo.foo();   
       	    foo.bar();
       	  }
       	
       	  void foo() throws Exception {
       	    throw new Exception();        // this will be converted to a SoftException
       	  }
       	  
       	  void bar() throws Exception {
       	    throw new RuntimeException();  // this will remain a RuntimeException
       	  }
       	
       	}
		</pre></div><div class="sect1"><a name="d0e4390"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="d0e4390"></a>Tools</h2></div></div><div class="sect2"><a name="d0e4393"></a><div class="titlepage"><div><h3 class="title"><a name="d0e4393"></a>Aspectpath</h3></div></div><p>AspectJ 5 allows the specification of directories (containing .class files) on the aspectpath in
              addition to jar/zip files.</p></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="ltw"></a>Chapter 12. Load-Time Weaving</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#ltw-introduction">Introduction</a></dt><dd><dl><dt><a href="#d0e4415">Weaving class files more than once</a></dt></dl></dd><dt><a href="#ltw-rules">Load-time Weaving Requirements</a></dt><dt><a href="#ltw-configuration">Configuration</a></dt><dd><dl><dt><a href="#d0e4443">Enabling Load-time Weaving</a></dt><dt><a href="#d0e4471">Configuring Load-time Weaving with aop.xml files</a></dt><dt><a href="#d0e4535">Configuring Load-time Weaving with Properties Files</a></dt><dt><a href="#d0e4545">Weaver Options</a></dt></dl></dd><dt><a href="#ltw-packaging">Runtime Requirements for Load-time Weaving</a></dt><dt><a href="#ltw-agents">Supported Agents</a></dt><dd><dl><dt><a href="#d0e4637">JVMTI</a></dt><dt><a href="#d0e4644">JRockit</a></dt></dl></dd></dl></div><div class="sect1"><a name="ltw-introduction"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ltw-introduction"></a>Introduction</h2></div></div><p> The AspectJ 5 weaver takes class files as input and produces class files as output.
            The weaving process itself can take place at one of three different times: compile-time,
            post-compile time, and load-time. The class files produced by the weaving process (and
            hence the run-time behaviour of an application) are the same regardless of the approach
            chosen. </p><div class="itemizedlist"><ul><li><a name="d0e4407"></a> Compile-time weaving is the simplest approach. When you have the source code
                for an application, ajc will compile from source and produce woven class files as
                output. The invocation of the weaver is integral to the ajc compilation process. The
                aspects themselves may be in source or binary form. </li><li><a name="d0e4409"></a> Post-compile weaving (also sometimes called binary weaving) is used to weave
                existing class files and JAR files. As with compile-time weaving,
                the aspects used for weaving may be in source or binary form. </li><li><a name="d0e4411"></a> Load-time weaving (LTW) is simply binary weaving defered until the point that
                a class loader loads a class file and defines the class to the JVM. To support this,
                one or more "weaving class loaders", either provided explicitly by the run-time
                environment or enabled through a "weaving agent" are required. </li></ul></div><p> You may also hear the term "run-time weaving". We define this as the weaving of
            classes that have already been defined to the JVM (without reloading those
            classes). AspectJ 5 does not provide explicit support for run-time weaving although
            simple coding patterns can support dynamically enabling and disabling advice in aspects. </p><div class="sect2"><a name="d0e4415"></a><div class="titlepage"><div><h3 class="title"><a name="d0e4415"></a>Weaving class files more than once</h3></div></div><p> By default a class file that has been woven by the AspectJ compiler cannot
                subsequently be rewoven (passed as input to the weaver). If you are developing
                AspectJ applications that are to be used in a load-time weaving environment, you
                need to specify the <tt>-Xreweavable</tt> compiler option when building
                them. This causes AspectJ to save additional state in the class files that is used
                to support subsequent reweaving. </p><p>As per AspectJ 1.5.0 M3 aspects (code style or annotation style) are
            reweavable by default, and weaved classes may be as well in 1.5.0 final.</p></div></div><div class="sect1"><a name="ltw-rules"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ltw-rules"></a>Load-time Weaving Requirements</h2></div></div><p> All load-time weaving is done in the context of a class loader, and hence the set of
            aspects used for weaving and the types that can be woven are affected by the class
            loader delegation model. This ensures that LTW complies with the Java 2 security model.
            The following rules govern the interaction of load-time weaving with class loading: </p><div class="orderedlist"><ol type="1"><li><a name="d0e4432"></a> All aspects to be used for weaving must be defined to the weaver before any
                types to be woven are loaded.</li><li><a name="d0e4434"></a> All abstract and concrete aspects visible to the weaver
                are available for extending (abstract aspects) and using for weaving. 
                A visible aspect is one defined by the
                weaving class loader or one of its parent class loaders.</li><li><a name="d0e4436"></a>A class loader may only weave classes that it defines. It may not weave
                classes loaded by a delegate or parent class loader.</li></ol></div></div><div class="sect1"><a name="ltw-configuration"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ltw-configuration"></a>Configuration</h2></div></div><p>AspectJ 5 supports a number of mechanisms designed to make load-time weaving as
        easy to use as possibe. The load-time weaving mechanism is chosen through JVM startup options. 
        Configuration files determine the set of aspects to be used for weaving and which 
        types will be woven. Additional diagnostic options allow the user to debug the configuration and 
        weaving process. </p><div class="sect2"><a name="d0e4443"></a><div class="titlepage"><div><h3 class="title"><a name="d0e4443"></a>Enabling Load-time Weaving</h3></div></div><p> AspectJ 5 supports three different ways of enabling load-time weaving for
            an application: agents, a command-line launch script, and a set of interfaces for
            integration of AspectJ load-time weaving in custom environments. </p><div class="variablelist"><dl><dt><a name="d0e4449"></a><span class="term">Agents</span></dt><dd><p><a name="d0e4452"></a>AspectJ 5 ships with a number of load-time weaving agents that
                            enable load-time weaving. These agents and their configuration
                            are execution environment dependent.
                            Using Java 5 for example, you can specify the "-javaagent" option
                            to the JVM. Configuration for the supported environments is discussed
                            later in this chapter. AspectJ 5
                            has several agents including those that use JVMTI, and the 
                            JRockit MAPI. </p></dd><dt><a name="d0e4455"></a><span class="term">Command line</span></dt><dd><p> AspectJ includes a script "aj" that allows programs executed at
                            the command line to take advantage of load-time weaving. 
                            The script is customized when AspectJ is installed depending on the chosen 
                            JDK. For example, for JDK 1.4 the script uses the
                            <tt>-Djava.system.class.loader</tt> system property to replace
                            the system class loader with a weaving class loader allowing classes 
                            loaded from the CLASSPATH to be woven. 
                            For JDK 1.5 the JVMTI weaving agent is used allowing classes loaded by all
                            class loaders to be woven. Versions of the JDK prior to 1.3 are not
                            supported by the "aj" mechanism. </p></dd><dt><a name="d0e4465"></a><span class="term">Custom Integration</span></dt><dd><p><a name="d0e4468"></a> A public interface is provided to allow a user written class loader
                            to instantiate a weaver and weave classes after loading and before
                            defining them in the JVM. This enables load-time weaving to be supported in
                            environments where no weaving agent is available. It also allows the
                            user to explicity restrict by class loader which classes can be woven. </p></dd></dl></div></div><div class="sect2"><a name="d0e4471"></a><div class="titlepage"><div><h3 class="title"><a name="d0e4471"></a>Configuring Load-time Weaving with aop.xml files</h3></div></div><p>The weaver is configured using one or more <tt>META-INF/aop.xml</tt>
                files located on the class loader search path. Each file may define a list of
                concrete aspects to be used for weaving, type patterns describing which types
                should woven, and a set of options to be passed to the weaver. In addition AspectJ 5
                supports the definition of concrete aspects in XML. Aspects defined in this way
                must extend an abstract aspect visible to the weaver. The abstract aspect
                may define abstract pointcuts (but not abstract
                methods). The following example shows a simple aop.xml file: </p><pre class="programlisting">
          &lt;aspectj&gt;
          
            &lt;aspects&gt;
              &lt;!-- declare two existing aspects to the weaver --&gt;
              &lt;aspect name="com.MyAspect"/&gt;
              &lt;aspect name="com.MyAspect.Inner"/&gt;

              &lt;!-- define a concrete aspect inline --&gt;
              &lt;concrete-aspect name="com.xyz.tracing.MyTracing" extends="tracing.AbstractTracing"&gt;
                &lt;pointcut name="tracingScope" expression="within(org.maw.*)"/&gt;
              &lt;/concrete-aspect&gt;
		  	  
              &lt;!-- Of the set of aspects known to the weaver, use aspects matching
                   the type pattern "com..*" for weaving. --&gt;
              &lt;include within="com..*"/&gt;
			  
              &lt;!-- Do not use any aspects with the @CoolAspect annotation for weaving --&gt;
              &lt;exclude within="@CoolAspect *"/&gt;    	
			  
            &lt;/aspects&gt;

            &lt;weaver options="-verbose -XlazyTjp"&gt;
              &lt;!-- Weave types that are within the javax.* or org.aspectj.*
                   packages. Also weave all types in the foo package that do
                   not have the @NoWeave annotation. --&gt;
              &lt;include within="javax.*"/&gt;
              &lt;include within="org.aspectj.*"/&gt;
              &lt;include within="(!@NoWeave foo.*) AND foo.*"/&gt;
            &lt;/weaver&gt;
          
          &lt;/aspectj&gt;
          
		  </pre><p>
                An aop.xml file contains two key sections: "aspects" defines one
                or more aspects to the weaver and controls which aspects are to be
                used in the weaving process; "weaver" defines weaver options and which
                types should be woven.
            </p><p>
                The simplest way to define an aspect to the weaver is to 
                specify the fully-qualified name of the aspect type in an aspect element. 
                You can also
                declare (and define to the weaver) aspects inline in the aop.xml file.
                This is done using the "concrete-aspect" element. A concrete-aspect
                declaration must provide a pointcut definition for every abstract 
                pointcut in the abstract aspect it extends. This mechanism is a 
                useful way of externalizing configuration for infrastructure and
                auxiliary aspects where the pointcut definitions themselves can be
                considered part of the configuration of the service.
            </p><p>
                The aspects element may optionally contain one or more include and
                exclude elements (by default, all defined aspects are used for weaving).
                Specifying include or exclude elements restricts the set of defined
                aspects to be used for weaving to those that are matched by an include
                pattern, but not by an exclude pattern. The 'within' attribute accepts
                a type pattern of the same form as a within pcd, except that &amp;&amp;
                and || are replaced by 'AND' and 'OR'.
            </p><p>
                The weaver element is used to pass options to the weaver and to specify
                the set of types that should be woven. If no include elements are specified
                then all types seen by the weaver will be woven.
            </p><p> When several configuration files are visible from a given weaving class loader
                their contents are conceptually merged (this applies to both aop.xml files
                and to aop.properties files as described in the next section). 
                The files are merged in the order they are
                found on the search path (regular <tt>getResourceAsStream</tt> lookup)
                according to the following rules: </p><div class="itemizedlist"><ul><li><a name="d0e4496"></a> The set of available aspects is the set of all
                    declared and defined aspects (<tt>aspect</tt> and
                    <tt>concrete-aspect</tt> elements of the <tt>aspects</tt>
                    section).</li><li><a name="d0e4507"></a>The set of aspects used for weaving is the subset of the available
                    aspects that are matched by at least one include statement and are not matched
                    by any exclude statements. If there are no include statements then all non-excluded
                    aspects are included.</li><li><a name="d0e4509"></a> The set of types to be woven are those types matched by at
                    least one weaver <tt>include</tt> element and not matched by any 
                    weaver <tt>exclude</tt> element. If there are no weaver include
                    statements then all non-excluded types are included.</li><li><a name="d0e4517"></a> The weaver options are derived by taking the union of the
                    options specified in each of the weaver options attribute specifications. Where an
                    option takes a value e.g. <tt>-warn:none</tt> the most recently defined value
                    will be used.</li></ul></div><p>It is not an error for the same aspect to be defined to the weaver in 
                more than one visible <tt>META-INF/aop.xml</tt> file. 
                However, if a declarative concrete aspect
                is declared in more than aop.xml file then an error will be issued.
                 A concrete aspect 
                defined in this way will be used to weave types loaded by the
                class loader that loaded the aop.xml file in which it was defined. 
                </p><p> A <tt>META-INF/aop.xml</tt> file will automatically be generated when
                using the <tt>-outjar</tt> option of the AspectJ compiler. 
                It will simply contain a (possibly empty) set of aspect elements, one for
                each concrete aspect included in the JAR. </p></div><div class="sect2"><a name="d0e4535"></a><div class="titlepage"><div><h3 class="title"><a name="d0e4535"></a>Configuring Load-time Weaving with Properties Files</h3></div></div><p> For memory constrained environments or those without support for XML a simple
                Java Properties file can be used to configure LTW. Just like XML files,
                <tt>META-INF/aop.properties</tt> files are loaded from the class loader
                search path. Everything that can be configured through XML can be configured using a
                Properties file, with the exception of declarative concrete aspects. For example: </p><pre class="programlisting">
          aspects.names=com.MyAspect,com.MyAspect.Inner
          aspects.include=com..*
          aspects.exclude=@CoolAspect

          weaver.options=-verbose -XlazyTjp
          weaver.include=javax.* OR org.aspectj.*
		  </pre></div><div class="sect2"><a name="d0e4545"></a><div class="titlepage"><div><h3 class="title"><a name="d0e4545"></a>Weaver Options</h3></div></div><p> The table below lists the AspectJ options supported by LTW. All other options
                will be ignored and a warning issued. </p><div class="informaltable" id="d0e4550"><a name="d0e4550"></a><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Purpose</th></tr></thead><tbody><tr><td><tt>-1.5</tt></td><td>Run the weaver in 1.5 mode (supports autoboxing in
                            join point matching)</td></tr><tr><td><tt>-XlazyTjp</tt></td><td>Performance optimization for aspects making use
                            of thisJoinPoint (non-static parts)</td></tr><tr><td><tt>-Xlint, -Xlint:ignore, ...</tt></td><td>Configure lint messages</td></tr><tr><td><tt>-nowarn, -warn:none</tt></td><td>Suppress warning messages</td></tr><tr><td><tt>-proceedOnError</tt></td><td>Continue weaving even if errors occur (for example,
                             "... already woven" errors)</td></tr><tr><td><tt>-verbose</tt></td><td>Issue informational messages about the weaving process</td></tr><tr><td><tt>-Xreweavable</tt></td><td>Produce class files that can subsequently be rewoven</td></tr><tr><td><tt>-XnoInline</tt></td><td>Don't inline around advice.</td></tr><tr><td><tt>-showWeaveInfo</tt></td><td>Issue informational messages whenever the weaver touches a class file</td></tr><tr><td><tt>-XmessageHolderClass:...</tt></td><td>Provide alternative output destination to stdout/stderr for all weaver messages.
                            The given value must be the full qualified class name of a class that implements
                            <tt>org.aspectj.weaver.loadtime</tt>
                            and that is visible from where the <tt>aop.xml</tt> is packed.
                            If more than one such options are used,
                            the first occurence only is taken into account.</td></tr></tbody></table></div></div></div><div class="sect1"><a name="ltw-packaging"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ltw-packaging"></a>Runtime Requirements for Load-time Weaving</h2></div></div><p> To use LTW the <tt>aspectjweaver.jar</tt> library must be added to the
            classpath. This contains the AspectJ 5 runtime, weaver, weaving class loader and
            weaving agents. It also contains the DTD for parsing XML weaving configuration files. </p></div><div class="sect1"><a name="ltw-agents"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ltw-agents"></a>Supported Agents</h2></div></div><div class="sect2"><a name="d0e4637"></a><div class="titlepage"><div><h3 class="title"><a name="d0e4637"></a>JVMTI</h3></div></div><p> When using JDK 1.5 the JVMTI agent can be used by starting the JVM with the
                following option (adapt according to the path to aspectjweaver.jar): </p><pre class="programlisting">
			-javaagent=aspectjweaver.jar          
		  </pre></div><div class="sect2"><a name="d0e4644"></a><div class="titlepage"><div><h3 class="title"><a name="d0e4644"></a>JRockit</h3></div></div><p> The JRockit agent is configured with the following JVM option: </p><pre class="programlisting">
			-Xmanagement:class=org.aspectj.weaver.tools.JRockitWeavingAgent
		  </pre></div></div></div><div class="appendix"><div class="titlepage"><div><h2 class="title"><a name="grammar"></a>Appendix A. A Grammar for the AspectJ 5 Language</h2></div></div><pre class="programlisting">
        === type patterns ===
      
        TypePattern := SimpleTypePattern |
  	                   '!' TypePattern |
  	                   '(' AnnotationPattern? TypePattern ')'
  	                   TypePattern '&amp;&amp;' TypePattern |
  	                   TypePattern '||' TypePattern
  	  	
        SimpleTypePattern := DottedNamePattern '+'? '[]'*
  	  	
        DottedNamePattern := FullyQualifiedName RestOfNamePattern? |
  		                     '*' NotStarNamePattern?
  		
        RestOfNamePattern := '..' DottedNamePattern |
  		                     '*' NotStarNamePattern?
  		                     
        NotStarNamePattern := FullyQualifiedName RestOfNamePattern? |
  		                      '..' DottedNamePattern               

        FullyQualifiedName := JavaIdentifierCharacter+ ('.' JavaIdentifierCharacter+)*  				  		  		  		               									 				  		             
 
        === annotation patterns ===
 
        AnnotationPattern := '!'? '@' AnnotationTypePattern AnnotationPattern* 

        
        AnnotationTypePattern := FullyQualifiedName |
                                 '(' TypePattern ')'
 
        === signature patterns ===
        
        -- field --
        
        FieldPattern := 
  		    AnnotationPattern? FieldModifiersPattern? 
  		    TypePattern (TypePattern DotOrDotDot)? SimpleNamePattern

        FieldModifiersPattern := '!'? FieldModifier FieldModifiersPattern*
		                         		
        FieldModifier := 'public' | 'private' | 'protected' | 'static' | 
		                 'transient' | 'final' 
		            			
        DotOrDotDot := '.' | '..'
		
        SimpleNamePattern := JavaIdentifierChar+ ('*' SimpleNamePattern)?		            
        
        -- method --
        
        MethodPattern := 
  		    AnnotationPattern? MethodModifiersPattern? TypePattern 
  		                       (TypePattern DotOrDotDot)? SimpleNamePattern 
  		                       '(' FormalsPattern ')' ThrowsPattern?

        MethodModifiersPattern := '!'? MethodModifier MethodModifiersPattern*
		
        MethodModifier := 'public' | 'private' | 'protected' | 'static' | 
		                  'synchronized' | 'final' 
		            		      
        FormalsPattern := '..' (',' FormalsPatternAfterDotDot)? |
		                  OptionalParensTypePattern (',' FormalsPattern)* |
		                  TypePattern '...'
		                  
        FormalsPatternAfterDotDot := 
		        OptionalParensTypePattern (',' FormalsPatternAfterDotDot)* |
		        TypePattern '...'
		                  
        ThrowsPattern := 'throws' TypePatternList
		
        TypePatternList := TypePattern (',' TypePattern)*
		
        -- constructor --
		            					            
        ConstructorPattern := 
  		    AnnotationPattern? ConstructorModifiersPattern?  
  		                       (TypePattern DotOrDotDot)? 'new' '(' FormalsPattern ')'
  		                       ThrowsPattern?
	
        ConstructorModifiersPattern := '!'? ConstructorModifier ConstructorModifiersPattern*
		
        ConstructorModifier := 'public' | 'private' | 'protected'
        
        === Pointcuts ===
        
        PointcutPrimitive := 
                    Call | Execution | Get | Set | Handler | 
                    Initialization | PreInitialization |
                    StaticInitialization | AdviceExecution |
                    This | Target | Args | CFlow | CFlowBelow |
                    Within | WithinCode | If |
                    AnnotationPointcut
                    
        AnnotationPointcut := AtAnnotation | AtThis | AtTarget |
                              AtWithin | AtWithinCode | AtArgs
                    
        
        Call := 'call' '(' MethodOrConstructorPattern ')'
        
        MethodOrConstructorPattern := MethodPattern | ConstructorPattern
        
        Execution := 'execution' '(' MethodOrConstructorPattern ')'
        
        Get := 'get' '(' FieldPattern ')'        
        Set := 'set' '(' FieldPattern ')'
        Handler := 'handler' '(' OptionalParensTypePattern ')'
        Initialization := 'initialization' '(' ConstructorPattern ')'
        PreInitialization := 'preinitialization' '(' ConstructorPattern ')'
        StaticInitialization := 'staticinitialization' '(' OptionalParensTypePattern ')'
        AdviceExecution := 'adviceexecution' '(' ')'
        This := 'this' '(' TypeOrIdentifier ')'
        Target := 'target' '(' TypeOrIdentifier ')'
        Args := 'args' '(' FormalsOrIdentifiersPattern ')'
        CFlow := 'cflow' '(' Pointcut ')'
        CFlowBelow := 'cflowbelow' '(' Pointcut ')'
        Within := 'within' '(' OptionalParensTypePattern ')'
        WithinCode := 'withincode' '(' OptionalParensTypePattern ')'
        If := 'if' '(' BooleanJavaExpression ')'
        
        TypeOrIdentifier := FullyQualifiedName ('[' ']')* | Identifier
        Identifier := JavaIdentifierChar+
        
        FormalsOrIdentifiersPattern :=
                          '..' (',' FormalsOrIdentifiersPatternAfterDotDot)? |
		                  TypeOrIdentifier (',' FormalsOrIdentifiersPattern)* |
		                  '*' (',' FormalsOrIdentifiersPattern)* 
		                  
        FormalsOrIdentifiersPatternAfterDotDot := 
		                  TypeOrIdentifier (',' FormalsOrIdentifiersPatternAfterDotDot)* |
		                  '*' (',' FormalsOrIdentifiersPatternAfterDotDot)*
        
        AtAnnotation := '@annotation' '(' AnnotationOrIdentifier ')'
        AtThis := '@this' '(' AnnotationOrIdentifer ')'
        AtTarget := '@target' '(' AnnotationOrIdentifier ')'
        AtWithin := '@within' '(' AnnotationOrIdentifier ')'
        AtWithinCode := '@withincode' '(' AnnotationOrIdentifier ')'        
        
        AnnotationOrIdentifier := FullyQualifiedName | Identifier
        
        AtArgs := '@args' '(' AnnotationsOrIdentifiersPattern ')'
        
        AnnotationsOrIdentifiersPattern :=
                          '..' (',' AnnotationsOrIdentifiersPatternAfterDotDot)? |
                          AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPattern)* |
                          '*' (',' AnnotationsOrIdentifiersPattern)*
		                  
        AnnotationsOrIdentifiersPatternAfterDotDot := 
		                  AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPatternAfterDotDot)* |
		                  '*' (',' AnnotationsOrIdentifiersPatternAfterDotDot)*
        
        PointcutDeclaration := PointcutModifiers? 'pointcut' Identifier Formals
                               ':' PointcutExpression
                               
        PointcutModifiers := PointcutModifier*
        
        PointcutModifier :=  'public' | 'private' | 'protected' | 'abstract'
        
        Formals := '(' ParamList? ')'        
        ParamList := FullyQualifiedName Identifier (',' ParamList)*
        
        ReferencePointcut := (FullyQualifiedName '.')? Identifier Formals
        
        PointcutExpression := (PointcutPrimitive | ReferencePointcut) |
                              '!' PointcutExpression |
                              '(' PointcutExpression ')' |
                              PointcutExpression '&amp;&amp;' PointcutExpression |
                              PointcutExpression '||' PointcutExpression 
        
        === Advice ===
        
        to be written...
        
        === Inter-type Declarations ===
        
        to be written...
        
        === Declare Statements ===
        
        to be written...
        
        === Aspects ===
        
        to be written...
        
      </pre></div></div></body></html>