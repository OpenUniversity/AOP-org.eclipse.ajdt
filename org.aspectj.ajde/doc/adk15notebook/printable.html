<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>The AspectJTM 5 Development Kit Developer's Notebook</title><meta name="generator" content="DocBook XSL Stylesheets V1.44"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" id="d0e1"><div class="titlepage"><div><h1 class="title"><a name="d0e1"></a>The AspectJ<sup>TM</sup> 5 Development Kit Developer's Notebook</h1></div><div><h3 class="author">the AspectJ Team</h3></div><div><div class="legalnotice"><p>
        Copyright (c) 2004 Contributors,  
        All rights reserved.
      </p></div></div><div><div class="abstract"><p><a name="d0e15"></a><b>Abstract</b></p><p>
        This guide describes the changes to the AspectJ language
        and tools in AspectJ 5. These changes are primarily, but not exclusively,
        to support Java 5 (Tiger) features.
        If you are new to AspectJ, we recommend you start 
        by reading the programming guide.
      </p><p>
         This is a draft document and is <span class="emphasis"><i>subject to change</i></span> before
         the design and implementation is complete. There is also no guarantee that all
         of the features in this document will be implemented in a 1.5.0 release - some
         may be deferred until 1.5.1 or even later. In general, features in which we
         have more confidence in the design will be implemented earlier, providing a 
         framework for user feedback and direction setting on features for which the
         use cases are less obvious at time of writing.
      </p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt>1. <a href="#jpsigs">Join Point Signatures</a></dt><dd><dl><dt><a href="#join-point-matching">Join Point Matching</a></dt><dt><a href="#join-point-signatures">Join Point Signatures</a></dt><dd><dl><dt><a href="#d0e246">Method call join point signatures</a></dt><dt><a href="#d0e351">Method execution join point signatures</a></dt><dt><a href="#d0e373">Field get and set join point signatures</a></dt></dl></dd><dt><a href="#join-point-modifiers">Join Point Modifiers</a></dt><dt><a href="#join-point-matching-summary">Summary of Join Point Matching</a></dt></dl></dd><dt>2. <a href="#annotations">Annotations</a></dt><dd><dl><dt><a href="#annotations-inJava5">Annotations in Java 5</a></dt><dd><dl><dt><a href="#d0e578">Using Annotations</a></dt><dt><a href="#d0e624">Retention Policies</a></dt><dt><a href="#d0e659">Accessing Annotations at Runtime</a></dt><dt><a href="#d0e694">Annotation Inheritance</a></dt></dl></dd><dt><a href="#annotations-aspectmembers">Annotating Aspects</a></dt><dt><a href="#annotations-pointcuts-and-advice">Join Point Matching based on Annotations</a></dt><dd><dl><dt><a href="#d0e783">Annotation Patterns</a></dt><dt><a href="#d0e857">Type Patterns</a></dt><dt><a href="#signaturePatterns">Signature Patterns</a></dt><dt><a href="#d0e1096">Example Pointcuts</a></dt><dt><a href="#d0e1169">Runtime type matching and context exposure</a></dt><dt><a href="#d0e1390">Package and Parameter Annotations</a></dt><dt><a href="#d0e1400">Annotation Inheritance and pointcut matching</a></dt><dt><a href="#d0e1432">Limitations</a></dt></dl></dd><dt><a href="#annotations-decp">Using Annotations with declare statements</a></dt><dd><dl><dt><a href="#d0e1447">Declare error and declare warning</a></dt><dt><a href="#d0e1462">declare parents</a></dt><dt><a href="#d0e1510">declare precedence</a></dt></dl></dd><dt><a href="#annotations-declare">Declare Annotation</a></dt><dt><a href="#annotations-itds">Inter-type Declarations</a></dt></dl></dd><dt>3. <a href="#generics">Generics</a></dt><dd><dl><dt><a href="#generics-inJava5">Generics in Java 5</a></dt><dd><dl><dt><a href="#d0e1615">Declaring Parameterized Types</a></dt><dt><a href="#d0e1618">Using Parameterized Types</a></dt><dt><a href="#d0e1621">Assignments and Wildcards</a></dt><dt><a href="#d0e1624">Generic Methods</a></dt></dl></dd><dt><a href="#generics-inAspectJ5"></a></dt><dd><dl><dt><a href="#d0e1628">Parameterized Aspect Types</a></dt><dt><a href="#d0e1631"></a></dt><dt><a href="#d0e1633"></a></dt><dt><a href="#d0e1635"></a></dt></dl></dd></dl></dd><dt>4. <a href="#autoboxing">Autoboxing and Unboxing</a></dt><dd><dl><dt><a href="#boxing-inJava5">Autoboxing and Unboxing in Java 5</a></dt><dt><a href="#autoboxing-in-aspectj5">Autoboxing and Join Point matching in AspectJ 5</a></dt><dt><a href="#autoboxing-and-method-dispatch">Inter-type method declarations and method dispatch</a></dt></dl></dd><dt>5. <a href="#covariance">Covariance</a></dt><dd><dl><dt><a href="#covariance-inJava5">Covariance in Java 5</a></dt><dt><a href="#covariance-and-join-point-matching">Covariant methods and Join Point matching</a></dt></dl></dd><dt>6. <a href="#varargs">Varargs</a></dt><dd><dl><dt><a href="#varargs-inJava5">Variable-length Argument Lists in Java 5</a></dt><dd><dl><dt><a href="#d0e1849">Calling Methods and Constructors with variable-length arguments</a></dt></dl></dd><dt><a href="#varargs-in-pcds">Using Variable-length arguments in advice and pointcut expressions</a></dt><dd><dl><dt><a href="#d0e1883">Matching signatures based on variable length argument types</a></dt><dt><a href="#d0e1985">Exposing variable-length arguments as context in pointcuts and advice</a></dt></dl></dd></dl></dd><dt>7. <a href="#enumeratedtypes">Enumerated Types</a></dt><dd><dl><dt><a href="#enums-in-java5">Enumerated Types in Java 5</a></dt><dt><a href="#enums-in-aspectj5">Enumerated Types in AspectJ 5</a></dt></dl></dd><dt>8. <a href="#pertypewithin">The pertypewithin Aspect Instantiation Model</a></dt><dt>9. <a href="#reflection">New Reflection Interfaces</a></dt><dt>10. <a href="#miscellaneous">Other Changes in AspectJ 5</a></dt><dd><dl><dt><a href="#d0e2164">Pointcuts</a></dt><dd><dl><dt><a href="#d0e2167">Binding of formals</a></dt><dt><a href="#d0e2172">Additional lint warnings</a></dt></dl></dd><dt><a href="#declare-soft">Declare Soft</a></dt></dl></dd><dt>A. <a href="#grammar">A Grammar for the AspectJ 5 Language</a></dt></dl></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="jpsigs"></a>Chapter 1. Join Point Signatures</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#join-point-matching">Join Point Matching</a></dt><dt><a href="#join-point-signatures">Join Point Signatures</a></dt><dd><dl><dt><a href="#d0e246">Method call join point signatures</a></dt><dt><a href="#d0e351">Method execution join point signatures</a></dt><dt><a href="#d0e373">Field get and set join point signatures</a></dt></dl></dd><dt><a href="#join-point-modifiers">Join Point Modifiers</a></dt><dt><a href="#join-point-matching-summary">Summary of Join Point Matching</a></dt></dl></div><p>
        Many of the extensions to the AspectJ language to address the new features of
        Java 5 are derived from a simple set of principles for join point
        matching. In this section, we outline these principles as a foundation
        for understanding the matching rules in the presence of annotations,
        generics, covariance, varargs, and autoboxing.
    </p><div class="sect1"><a name="join-point-matching"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="join-point-matching"></a>Join Point Matching</h2></div></div><p>AspectJ supports 11 different kinds of join points. These are
        the <tt>method call, method execution, constructor call,
        constructor execution, field get, field set, pre-initialization,
        initialization, static initialization, handler,</tt> and
        <tt>advice execution</tt> join points.</p><p>The <span class="emphasis"><i>kinded</i></span> pointcut designators match
        based on the kind of a join point. These are the <tt>call,
        execution, get, set, preinitialization, initialization, 
        staticinitialization, handler,</tt> and <tt>adviceexecution</tt>
        designators.</p><p>A kinded pointcut is written using patterns, some of which 
        match based on <span class="emphasis"><i>signature</i></span>, and some of which
        match based on <span class="emphasis"><i>modifiers</i></span>. For example, in 
        the <tt>call</tt> pointcut designator:</p><pre class="programlisting">
        call(ModifierPattern TypePattern TypePattern.IdPattern(TypePatternList) ThrowsPattern)
		</pre><p>the modifiers matching patterns are <tt>ModifierPattern</tt>
		and <tt>ThrowsPattern</tt>, and the signature matching patterns
		are <tt>TypePattern TypePattern.IdPattern(TypePatternList)</tt>.
		</p><p>
		A join point has potentially multiple signatures, but only one set of
		modifiers. <span class="emphasis"><i>A kinded primitive pointcut matches a particular join point 
		if and only if</i></span>:
		</p><div class="orderedlist"><ol type="1"><li><a name="d0e80"></a>They are of the same kind</li><li><a name="d0e82"></a>The signature pattern (exactly) matches at least one 
		    signature of the join point</li><li><a name="d0e84"></a>The modifiers pattern matches the modifiers of the
		    subject of the join point</li></ol></div><p>These rules make it very easily to quickly determine whether a 
        given pointcut matches a given join point. In the next two sections,
        we describe what the signature(s) of a join point are, and what the
        subjects of join points are.</p></div><div class="sect1"><a name="join-point-signatures"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="join-point-signatures"></a>Join Point Signatures</h2></div></div><p>Call, execution, get, and set join points may potentially have multiple
        signatures. All other join points have exactly one signature. The
        following table summarizes the constituent parts of a join point
        signature for the different kinds of join point.</p><div class="informaltable" id="d0e93"><a name="d0e93"></a><table border="1"><colgroup><col><col><col><col><col><col><col></colgroup><thead><tr><th>Join Point Kind</th><th>Return Type</th><th>Declaring Type</th><th>Id</th><th>Parameter Types</th><th>Field Type</th><th>Exception Type</th></tr></thead><tbody><tr><td>Method call</td><td>+</td><td>+</td><td>+</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Method execution</td><td>+</td><td>+</td><td>+</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Constructor call</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Constructor execution</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Field get</td><td>&nbsp;</td><td>+</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td></tr><tr><td>Field set</td><td>&nbsp;</td><td>+</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td></tr><tr><td>Pre-initialization</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Initialization</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Static initialization</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Handler</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>+</td></tr><tr><td>Advice execution</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>+</td><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></div><p>Note that whilst an advice excetution join point has a
        signature comprising the declaring type of the advice and the
        advice parameter types, the <tt>adviceexecution</tt>
        pointcut designator does not support matching based on this
        signature.</p><p>The signatures for most of the join point kinds should be
        self-explanatory, except for field get and set, and method call and execution
        join points, which can have multiple signatures. Each signature of 
        a method call or execution join point has the same id and parameter
        types, but the declaring type and return type (with covariance) may vary.
        Each signature of a field get or set join point has the same id and field
        type, but the declaring type may vary.
        </p><p>The following sections examine signatures for these join points 
        in more detail.</p><div class="sect2"><a name="d0e246"></a><div class="titlepage"><div><h3 class="title"><a name="d0e246"></a>Method call join point signatures</h3></div></div><p>
          For a call join point where a call is made to a method
          <tt>m(parameter_types)</tt> on a target type <tt>T</tt> (where
          <tt>T</tt> is the static type of the target):
        </p><pre class="programlisting">
		T t = new T(); 
		t.m("hello");  &lt;= call join point occurs when this line is executed
		</pre><p>
            Then the signature <tt>R(T) T.m(parameter_types)</tt> is a signature
            of the call join point, where <tt>R(T)</tt> is the return
            type of <tt>id</tt> in <tt>T</tt>, and 
            <tt>parameter_types</tt> are the parameter types of
            <tt>m</tt>. If <tt>T</tt> itself does not
            declare a definition of <tt>m(parameter_types)</tt>, then 
            <tt>R(T)</tt> is the return type in the definition of 
            <tt>m</tt> that <tt>T</tt> inherits. Given the
            call above, and the definition of <tt>T.m</tt>:                      
        </p><pre class="programlisting">
        interface Q {
          R m(String s);
        }
        
        class P implements Q {
          R m(String s) {...}        
        }
        
        class S extends P {
          R' m(String s) {...}
        }
        
        class T extends S {} 
		
		</pre><p>Then <tt>R' T.m(String)</tt> is a signature of the
        call join point for <tt>t.m("hello")</tt>.</p><p>
            For each ancestor (super-type) <tt>A</tt> of <tt>T</tt>, 
            if <tt>m(parameter_types)</tt> is defined for that super-type, then
            <tt>R(A) A.m(parameter_types)</tt> is a signature of the call join
            point, where <tt>R(A)</tt> is the return type of <tt>
            m(parameter_types)</tt> as defined in <tt>A</tt>, or as inherited
            by <tt>A</tt> if <tt>A</tt> itself does not
            provide a definition of <tt>m(parameter_types)</tt>.            
        </p><p>
            Continuing the example from above,we can deduce that
        </p><pre class="programlisting">
        R' S.m(String)
        R  P.m(String)
        R  Q.m(String)
		</pre><p>are all additional signatures for the call join point arising
        from the call <tt>t.m("hello")</tt>. Thus this call
        join point has four signatures in total. Every signature has the same
        id and parameter types, and a different declaring type.</p></div><div class="sect2"><a name="d0e351"></a><div class="titlepage"><div><h3 class="title"><a name="d0e351"></a>Method execution join point signatures</h3></div></div><p>Join point signatures for execution join points are defined
          in a similar manner to signatures for call join points. Given the
          hierarchy:
          </p><pre class="programlisting">
        interface Q {
          R m(String s);
        }
        
        class P implements Q {
          R m(String s) {...}        
        }
        
        class S extends P {
          R' m(String s) {...}
        }
        
        class T extends S { }
        
        class U extends T {
          R' m(String s) {...}
        }
		
		</pre><p>Then the execution join point signatures arising as a result
        of the call to <tt>u.m("hello")</tt> are: </p><pre class="programlisting">
        R' U.m(String)
        R' S.m(String)
        R  P.m(String)
        R  Q.m(String)
		</pre><p>Each signature has the same id and parameter types, and a 
        different declaring type. There is one signature for each type
        that provides its own declaration of the method. Hence in this 
        example there is no signature <tt>R' T.m(String)</tt>
        as <tt>T</tt> does not provide its own declaration of
        the method.</p></div><div class="sect2"><a name="d0e373"></a><div class="titlepage"><div><h3 class="title"><a name="d0e373"></a>Field get and set join point signatures</h3></div></div><p>
            For a field get join point where an access is made to a field
            <tt>f</tt> of type <tt>F</tt> 
            on a object with declared type <tt>T</tt>, then
            <tt>F T.f</tt> is a signature of the get join point.  
        </p><p>
            If <tt>T</tt> does not directly declare a member
            <tt>f</tt>, then for each super type <tt>S</tt>
            of <tt>T</tt>, up to and including the most specific
            super type of <tt>T</tt> that does declare the member
            <tt>f</tt>, <tt>F S.f</tt> is a signature
            of the join point. For example, given the hierarchy:
        </p><pre class="programlisting">        
        class P  {
          F f;        
        }
        
        class S extends P {
          F f;
        }
        
        class T extends S { }                
		</pre><p>
		    Then the join point signatures for a field get join point of
		    the field <tt>f</tt> on an object with declared type
		    <tt>T</tt> are:
		</p><pre class="programlisting">
        F S.f
        F T.f
		</pre><p>The signatures for a field set join point are derived in an
            identical manner.</p></div></div><div class="sect1"><a name="join-point-modifiers"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="join-point-modifiers"></a>Join Point Modifiers</h2></div></div><p>Every join point has a single set of modifiers - these include
          the standard Java modifiers such as <tt>public, private,
          static, abstract</tt> etc., any annotations, and the throws
          clauses of methods and constructors. These modifiers are the
          modifiers of the <span class="emphasis"><i>subject</i></span> of the join point.</p><p>
          The following table defines the join point subject for each kind
          of join point.
          </p><div class="informaltable" id="d0e440"><a name="d0e440"></a><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Join Point Kind</th><th>Subject</th></tr></thead><tbody><tr><td>Method call</td><td>The method picked out by Java as
                       the static target of the method call.</td></tr><tr><td>Method execution</td><td>The method that is executing.</td></tr><tr><td>Constructor call</td><td>The constructor being called.</td></tr><tr><td>Constructor execution</td><td>The constructor executing.</td></tr><tr><td>Field get</td><td>The field being accessed.</td></tr><tr><td>Field set</td><td>The field being set.</td></tr><tr><td>Pre-initialization</td><td>The first constructor executing in
                       this constructor chain.</td></tr><tr><td>Initialization</td><td>The first constructor executing in
                       this constructor chain.</td></tr><tr><td>Static initialization</td><td>The type being initialized.</td></tr><tr><td>Handler</td><td>The declared type of the
                       exception being handled.</td></tr><tr><td>Advice execution</td><td>The advice being executed.</td></tr></tbody></table></div><p>For example, given the following types</p><pre class="programlisting">
        public class X {        
          @Foo
          protected void doIt() {...} 
        }
        
        public class Y extends X {        
          public void doIt() {...}        
        }
		</pre><p>Then the modifiers for a call to <tt>(Y y) y.doIt()</tt>
         are simply <tt>{public}</tt>. The modifiers for a call to
         <tt>(X x) x.doIt()</tt> are <tt>{@Foo,protected}</tt>.
         </p></div><div class="sect1"><a name="join-point-matching-summary"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="join-point-matching-summary"></a>Summary of Join Point Matching</h2></div></div><p>
		A join point has potentially multiple signatures, but only one set of
		modifiers. <span class="emphasis"><i>A kinded primitive pointcut matches a particular join point 
		if and only if</i></span>:
		</p><div class="orderedlist"><ol type="1"><li><a name="d0e531"></a>They are of the same kind</li><li><a name="d0e533"></a>The signature pattern (exactly) matches at least one 
		    signature of the join point</li><li><a name="d0e535"></a>The modifiers pattern matches the modifiers of the
		    subject of the join point</li></ol></div><p>Given the hierarchy</p><pre class="programlisting">
        interface Q {
          R m(String s);
        }
        
        class P implements Q {
          @Foo
          public R m(String s) {...}        
        }
        
        class S extends P {
          @Bar
          public R' m(String s) {...}
        }
        
        class T extends S {} 
		
		</pre><p>and the program fragment:</p><pre class="programlisting">
        P p = new P();
        S s = new S();
        T t = new T();
        ...
        p.m("hello");
        s.m("hello");
        t.m("hello");
		</pre><p>
        The the pointcut <tt>call(@Foo R P.m(String))</tt> matches the
        call <tt>p.m("hello")</tt> since both the signature and the 
        modifiers match. It does not match the call <tt>s.m("hello")</tt>
        because even though the signature pattern matches one of the signatures
        of the join point, the modifiers pattern does not match the modifiers of
        the method m in S which is the static target of the call.
        </p><p>The pointcut <tt>call(R' m(String))</tt> matches the
        calls <tt>t.m("hello")</tt> and <tt>s.m("hello")</tt>.
        It does not match the call <tt>p.m("hello")</tt> since the
        signature pattern does not match any signature for the call join point
        of m in P.</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="annotations"></a>Chapter 2. Annotations</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#annotations-inJava5">Annotations in Java 5</a></dt><dd><dl><dt><a href="#d0e578">Using Annotations</a></dt><dt><a href="#d0e624">Retention Policies</a></dt><dt><a href="#d0e659">Accessing Annotations at Runtime</a></dt><dt><a href="#d0e694">Annotation Inheritance</a></dt></dl></dd><dt><a href="#annotations-aspectmembers">Annotating Aspects</a></dt><dt><a href="#annotations-pointcuts-and-advice">Join Point Matching based on Annotations</a></dt><dd><dl><dt><a href="#d0e783">Annotation Patterns</a></dt><dt><a href="#d0e857">Type Patterns</a></dt><dt><a href="#signaturePatterns">Signature Patterns</a></dt><dt><a href="#d0e1096">Example Pointcuts</a></dt><dt><a href="#d0e1169">Runtime type matching and context exposure</a></dt><dt><a href="#d0e1390">Package and Parameter Annotations</a></dt><dt><a href="#d0e1400">Annotation Inheritance and pointcut matching</a></dt><dt><a href="#d0e1432">Limitations</a></dt></dl></dd><dt><a href="#annotations-decp">Using Annotations with declare statements</a></dt><dd><dl><dt><a href="#d0e1447">Declare error and declare warning</a></dt><dt><a href="#d0e1462">declare parents</a></dt><dt><a href="#d0e1510">declare precedence</a></dt></dl></dd><dt><a href="#annotations-declare">Declare Annotation</a></dt><dt><a href="#annotations-itds">Inter-type Declarations</a></dt></dl></div><div class="sect1"><a name="annotations-inJava5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="annotations-inJava5"></a>Annotations in Java 5</h2></div></div><p>
		This section provides the essential information about annotations in
		Java 5 needed to understand how annotations are treated in AspectJ 5.
		For a full introduction to annotations in Java, please see the
		documentation for the Java 5 SDK.
	</p><div class="sect2"><a name="d0e578"></a><div class="titlepage"><div><h3 class="title"><a name="d0e578"></a>Using Annotations</h3></div></div><p>
	      Java 5 introduces <span class="emphasis"><i>annotation types</i></span> which can
	      be used to express metadata relating to program members in the
	      form of <span class="emphasis"><i>annotations</i></span>. Annotations in Java 5 
	      can be applied to package and type declarations (classes,
	      interfaces, enums, and annotations), constructors, methods, 
	      fields, parameters, and variables. Annotations are specified in the
	      program source by using the <tt>@</tt> symbol. For example,
	      the following piece of code uses the <tt>@Deprecated</tt>
	      annotation to indicate that the <tt>obsoleteMethod()</tt>
	      has been deprecated:
	    </p><pre class="programlisting">
		@Deprecated
		public void obsoleteMethod() { ... }
		</pre><p>
			Annotations may be <span class="emphasis"><i>marker annotations</i></span>,
			<span class="emphasis"><i>single-valued annotations</i></span>, or 
			<span class="emphasis"><i>multi-valued annotations</i></span>.
			Annotation types with no members or that provide default values
			for all members may be used simply as marker annotations, as in
			the deprecation example above. Single-value annotation types have
			a single member, and the annotation may be written in one of
			two equivalent forms:
		</p><pre class="programlisting">
		@SuppressWarnings({"unchecked"})
		public void someMethod() {...}
		</pre><p>
			or
		</p><pre class="programlisting">
		@SuppressWarnings(value={"unchecked"})
		public void someMethod() {...}
		</pre><p>
			Multi-value annotations must use the <tt>member-name=value
			</tt> syntax to specify annotation values. For example:
		</p><pre class="programlisting">
		@Authenticated(role="supervisor",clearanceLevel=5)
		public void someMethod() {...}
		</pre></div><div class="sect2"><a name="d0e624"></a><div class="titlepage"><div><h3 class="title"><a name="d0e624"></a>Retention Policies</h3></div></div><p>
	      Annotations can have one of three retention policies:
	    </p><div class="variablelist"><dl><dt><a name="d0e630"></a><span class="term">Source-file retention</span></dt><dd><p><a name="d0e633"></a>
	            	Annotations with source-file retention are read by the 
	            	compiler during the compilation process, but are not
	            	rendered in the generated <tt>.class</tt> files.
	            </p></dd><dt><a name="d0e639"></a><span class="term">Class-file retention</span></dt><dd><p><a name="d0e642"></a>
	        			This is the default retention policy. Annotations
	        			with class-file retention are read by the compiler
	        			and also retained in the generated <tt>
	        			.class</tt> files.
	        		</p></dd><dt><a name="d0e648"></a><span class="term">Runtime retention</span></dt><dd><p><a name="d0e651"></a>
	        			Annotations with runtime retention are read by the
	        			compiler, retained in the generated <tt>
	        			.class</tt> files, and also made available
	        			at runtime.
	        		</p></dd></dl></div><p>Local variable annotations are not retained in class files (or at runtime)
	    regardless of the retention policy set on the annotation type. See JLS 9.6.1.2.</p></div><div class="sect2"><a name="d0e659"></a><div class="titlepage"><div><h3 class="title"><a name="d0e659"></a>Accessing Annotations at Runtime</h3></div></div><p>
    		Java 5 supports a new interface, 
    		<tt>java.lang.reflect.AnnotatedElement</tt>, that is
    		implemented by the reflection classes in Java (<tt>Class</tt>, 
    		<tt>Constructor</tt>,
    		<tt>Field</tt>, <tt>Method</tt>, and 
    		<tt>Package</tt>). This interface gives you access
    		to annotations <span class="emphasis"><i>that have runtime retention</i></span> via
    		the <tt>getAnnotation</tt>, <tt>getAnnotations</tt>, 
    		and <tt>isAnnotationPresent</tt>. Because annotation types are
    		just regular Java classes, the annotations returned by these methods
    		can be queried just like any regular Java object.
    	</p></div><div class="sect2"><a name="d0e694"></a><div class="titlepage"><div><h3 class="title"><a name="d0e694"></a>Annotation Inheritance</h3></div></div><p>
    		It is important to understand the rules relating to inheritance of
    		annotations, as these have a bearing on join point matching
    		based on the presence or absence of annotations.
    	</p><p>
    		By default annotations are <span class="emphasis"><i>not</i></span> inherited. Given
    		the following program
    	</p><pre class="programlisting">
			@MyAnnotation
			class Super {
			  @Oneway public void foo() {}
			}
			
			class Sub extends Super {
			  public void foo() {}
			}
			</pre><p>
    		Then <tt>Sub</tt> <span class="emphasis"><i>does not</i></span> have
    		the <tt>MyAnnotation</tt> annotation, and 
    		<tt>Sub.foo()</tt> is not an <tt>@Oneway</tt>
    		method, despite the fact that it overrides 
    		<tt>Super.foo()</tt> which is.
    	</p><p>
    		If an annotation type has the meta-annotation <tt>@Inherited</tt>
    		then an annotation of that type on a <span class="emphasis"><i>class</i></span> will cause
    		the annotation to be inherited by sub-classes. So, in the example
    		above, if the <tt>MyAnnotation</tt> type had the
    		<tt>@Inherited</tt> attribute, then <tt>Sub</tt>
    		would have the <tt>MyAnnotation</tt> annotation.    		
    	</p><p>
    		<tt>@Inherited</tt> annotations are not inherited when used to
    		annotate anything other than a type. A type
    		that implements one or more interfaces never inherits any annotations from
    		the interfaces it implements.
    	</p></div></div><div class="sect1"><a name="annotations-aspectmembers"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="annotations-aspectmembers"></a>Annotating Aspects</h2></div></div><p>
    	AspectJ 5 supports annotations on aspects, and on method, field,
    	constructor, advice, and inter-type declarations within aspects. 
    	Method and advice parameters may also be annotated.
    	Annotations are not permitted on pointcut declarations or on 
    	<tt>declare</tt> statements.
    </p><p>
    	The following example illustrates the use of annotations in aspects:
    </p><pre class="programlisting">
		@AspectAnnotation
		public abstract aspect ObserverProtocol {
		
			@InterfaceAnnotation
			interface Subject {}
		
			@ITDFieldAnnotation
			private List Subject.observers;  
				
			@ITDMethodAnnotation
			public void Subject.addObserver() { ... }
			
			@ITDMethodAnnotation
			public void Subject.removeObserver() { ... }
			
			@MethodAnnotation
			private void notifyObservers(Subject subject) { ... }
			
			/**
			 * Delegate to concrete sub-aspect the actual form of
			 * notification for a given type of Subject.
			 */
			@MethodAnnotation
			protected abstract void notifySubject(Subject s);
			
			/* no annotations on pointcuts */
			abstract pointcut observedEvent(Subject subject);
			
			@AdviceAnnotation
			after(Subject subject) returning : observedEvent(subject) {
				notifyObservers(subject);  
			} 
		}
	</pre><p>
    An annotation on an aspect will be inherited by sub-aspects, iff it has
    the <tt>@Inherited</tt> meta-annotation.
    </p><p>
        AspectJ 5 supports a new XLint warning, "the pointcut associated with this
        advice does not match any join points". The warning is enabled by default and
        will be emitted by the compiler if the pointcut expression associated with an 
        advice statement can be statically determined to not match any join points. The
        warning can be suppressed for an individual advice statement by using the 
        <tt>@SuppressWarnings({"unmatched"})</tt> annotation. (See JLS 9.6.1.5).
    </p></div><div class="sect1"><a name="annotations-pointcuts-and-advice"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="annotations-pointcuts-and-advice"></a>Join Point Matching based on Annotations</h2></div></div><p><span class="emphasis"><i>Note: compared to the previous version, this version restricts the
    use of annotations in type patterns (package annotations and outer type annotations
    cannot be specified inline), and requires parenthesis more often. These changes were
    made to make pointcut expressions easier to read and interpret.</i></span></p><p>
  	This section discusses changes to type pattern and signature pattern matching in
  	AspectJ 5 that support matching join points based on the presence or absence of
  	annotations. We then discuss means of exposing annotation values within the body
  	of advice.
  </p><div class="sect2"><a name="d0e783"></a><div class="titlepage"><div><h3 class="title"><a name="d0e783"></a>Annotation Patterns</h3></div></div><p>
          For any kind of annotated element (type, method, constructor, package, etc.), 
          an annotation pattern can be used to match against the set of annotations
          on the annotated element. Annotation patterns are defined by the following
          grammar.
      </p><pre class="programlisting">
		AnnotationPattern := '!'? '@' AnnotationTypePattern AnnotationPattern* 
        
		AnnotationTypePattern := FullyQualifiedName |
		                         '(' TypePattern ')'
  		                     
  		FullyQualifiedName := JavaIdentifierCharacter+ ('.' JavaIdentifierCharacter+)*  		
      </pre><p>In simple terms, an annotation pattern element has one of two basic
      forms:</p><div class="itemizedlist"><ul><li><a name="d0e793"></a>@&lt;qualified-name&gt;, for example, @Foo, or 
          @org.xyz.Foo.</li><li><a name="d0e795"></a>@(&lt;type-pattern&gt;), for example, @(org.xzy..*), or
          @(Foo || Boo)</li></ul></div><p>These simple elements may be negated using <tt>!</tt>, and
      combined by simple concatentation. The pattern <tt>@Foo @Boo</tt>
      matches an annotated element that has both an annotation of type <tt>Foo</tt>
      and an annotation of type <tt>Boo</tt>.</p><p>Some examples of annotation patterns follow:</p><pre class="programlisting">
      @Immutable
      </pre><p>Matches any annotated element which has an annotation of 
      type <tt>Immutable</tt>.</p><pre class="programlisting">
      !@Persistent
      </pre><p>Matches any annotated element which does not have an annotation of 
      type <tt>Persistent</tt>.</p><pre class="programlisting">
      @Foo @Goo
      </pre><p>Matches any annotated element which has both an annotation of type <tt>Foo</tt> and
      an annotation of type <tt>Goo</tt>.</p><pre class="programlisting">
      @(Foo || Goo)
      </pre><p>Matches any annotated element which has either an annotation of a type matching
      the type pattern <tt>(Foo || Goo)</tt>. 
      In other words, an annotated element with either an
      annotation of type <tt>Foo</tt> or
      an annotation of type <tt>Goo</tt> (or both). (The parenthesis are required in this example).
      </p><pre class="programlisting">
      @(org.xyz..*)
      </pre><p>Matches any annotated element which has either an annotation of a type matching
      the type pattern <tt>(org.xyz..*)</tt>. 
      In other words, an annotated element with an annotation that is declared in the
      org.xyz package or a sub-package. (The parenthesis are required in this example).</p></div><div class="sect2"><a name="d0e857"></a><div class="titlepage"><div><h3 class="title"><a name="d0e857"></a>Type Patterns</h3></div></div><p>AspectJ 1.5 extends type patterns to allow an optional <tt>AnnotationPattern</tt>
	prefix. (Extensions to this definition for generics are shown in the next chapter).</p><pre class="programlisting">
  	  	TypePattern := SimpleTypePattern |
  	  	               '!' TypePattern |
  	  	               '(' AnnotationPattern? TypePattern ')'
  	  	               TypePattern '&amp;&amp;' TypePattern |
  	  	               TypePattern '||' TypePattern |
  	  	
  	  	SimpleTypePattern := DottedNamePattern '+'? '[]'*
  	  	
  		DottedNamePattern := FullyQualifiedName RestOfNamePattern? |
  		                     '*' NotStarNamePattern?
  		
  		RestOfNamePattern := '..' DottedNamePattern |
  		                     '*' NotStarNamePattern?
  		                     
  		NotStarNamePattern := FullyQualifiedName RestOfNamePattern? |
  		                      '..' DottedNamePattern               

  		FullyQualifiedName := JavaIdentifierCharacter+ ('.' JavaIdentifierCharacter+)*  				  		  		  		               									 				  		             
	</pre><p>Note that in most cases when annotations are used as part of a type pattern,
        the parenthesis are required (as in <tt>(@Foo Hello+)</tt>). In
        some cases (such as a type pattern used within a <tt>this</tt>
        pointcut expression, the parenthesis are optional:</p><pre class="programlisting">
        OptionalParensTypePattern := AnnotationPattern? TypePattern
      </pre><p>
		The following examples illustrate the use of annotations in type
		patterns:
	</p><pre class="programlisting">
     (@Immutable *)
     </pre><p>Matches any type with an <tt>@Immutable</tt> annotation.</p><pre class="programlisting">
     (!@Immutable *)
     </pre><p>Matches any type which does not have an <tt>@Immutable</tt> annotation.</p><pre class="programlisting">
     (@Immutable (org.xyz.* || org.abc.*))
     </pre><p>Matches any type in the <tt>org.xyz</tt> or <tt>org.abc</tt>
     packages with the <tt>@Immutable</tt> annotation.</p><pre class="programlisting">
     ((@Immutable Foo+) || Goo)
     </pre><p>Matches a type <tt>Foo</tt> or any of its subtypes, which have the <tt>@Immutable</tt>
     annotation, or a type <tt>Goo</tt>.</p><pre class="programlisting">
     ((@(Immutable || NonPersistent) org.xyz..*)
     </pre><p>
     Matches any type in a package beginning with the prefix <tt>org.xyz</tt>,
     which has either the <tt>@Immutable</tt> annotation or the
     <tt>@NonPersistent</tt> annotation.
     </p><pre class="programlisting">
     (@Immutable @NonPersistent org.xyz..*)
     </pre><p>
     Matches any type in a package beginning with the prefix <tt>org.xyz</tt>,
     which has both an <tt>@Immutable</tt> annotation and an
     <tt>@NonPersistent</tt> annotation.
     </p><pre class="programlisting">
     (@(@Inherited *) org.xyz..*)
     </pre><p>
     Matches any type in a package beginning with the prefix <tt>org.xyz</tt>,
     which has an inheritable annotation. The annotation pattern 
     <tt>@(@Inherited *)</tt> matches any annotation of a type matching the
     type pattern <tt>@Inherited *</tt>, which in turn matches any type with the
     <tt>@Inherited</tt> annotation.
     </p></div><div class="sect2"><a name="signaturePatterns"></a><div class="titlepage"><div><h3 class="title"><a name="signaturePatterns"></a>Signature Patterns</h3></div></div><p>A <tt>FieldPattern</tt> is described by the following
  	grammar:</p><pre class="programlisting">  	
  		FieldPattern := 
  		    AnnotationPattern? FieldModifiersPattern? 
  		    TypePattern (TypePattern DotOrDotDot)? SimpleNamePattern

		FieldModifiersPattern := '!'? FieldModifier FieldModifiersPattern*
		                         		
		FieldModifier := 'public' | 'private' | 'protected' | 'static' | 
		                 'transient' | 'final' 

		DotOrDotDot := '.' | '..'		            		      
		            		      		            			
		SimpleNamePattern := JavaIdentifierChar+ ('*' SimpleNamePattern)?		            
	</pre><p>
  	    The optional <tt>AnnotationPattern</tt> restricts matches to fields with
  	    annotations that match the pattern. For example:
  	</p><div class="variablelist"><dl><dt><a name="d0e977"></a><span class="term">@SensitiveData * *</span></dt><dd><p><a name="d0e980"></a>
            	Matches a field of any type and any name, that has an annotation of
            	type <tt>@SensitiveData</tt>
            </p></dd><dt><a name="d0e986"></a><span class="term">@SensitiveData List org.xyz..*.*</span></dt><dd><p><a name="d0e989"></a>
            	Matches a member field of a type in a package with prefix <tt>org.xzy</tt>,
            	where the field is of type <tt>List</tt>, and has an annotation of type
            	<tt>@SensitiveData</tt>
            </p></dd><dt><a name="d0e1001"></a><span class="term">(@SensitiveData *) org.xyz..*.*</span></dt><dd><p><a name="d0e1004"></a>
            	Matches a member field of a type in a package with prefix <tt>org.xzy</tt>,
            	where the field is of a type which has a <tt>@SensitiveData</tt> annotation.
            </p></dd><dt><a name="d0e1013"></a><span class="term">@Foo (@Goo *) (@Hoo *).*</span></dt><dd><p><a name="d0e1016"></a>
            	Matches a field with an annotation <tt>@Foo</tt>, of a type with an 
            	annotation <tt>@Goo</tt>, declared in a type with annotation
            	<tt>@Hoo</tt>.
            </p></dd><dt><a name="d0e1028"></a><span class="term">@Persisted @Classified * *</span></dt><dd><p><a name="d0e1031"></a>
            	Matches a field with an annotation <tt>@Persisted</tt> and
            	an annotation <tt>@Classified</tt>.
            </p></dd></dl></div><p>A <tt>MethodPattern</tt> is of the form</p><pre class="programlisting">  	
  		MethodPattern := 
  		    AnnotationPattern? MethodModifiersPattern? TypePattern 
  		                       (TypePattern DotOrDotDot)? SimpleNamePattern 
  		                       '(' FormalsPattern ')'ThrowsPattern?

		MethodModifiersPattern := '!'? MethodModifier MethodModifiersPattern*
		
		MethodModifier := 'public' | 'private' | 'protected' | 'static' | 
		                  'synchronized' | 'final' 
		            		      
		FormalsPattern := '..' (',' FormalsPatternAfterDotDot)* |
		                  OptionalParensTypePattern (',' FormalsPattern)* |
		                  TypePattern '...'
		                  
		FormalsPatternAfterDotDot := 
		        OptionalParensTypePattern (',' FormalsPatternAfterDotDot)* |
		        TypePattern '...'
		                                               		                  
		ThrowsPattern := 'throws' TypePatternList
		
		TypePatternList := TypePattern (',' TypePattern)*
		            					            
	</pre><p><span class="emphasis"><i>Note: compared to the previous version, this definition of MethodPattern does
  	not allow parameter annotation matching (only matching on annotations of parameter types).</i></span></p><p>A <tt>ConstructorPattern</tt> has the form</p><pre class="programlisting">  	
  		ConstructorPattern := 
  		    AnnotationPattern? ConstructorModifiersPattern?  
  		                       (TypePattern DotOrDotDot)? 'new' '(' FormalsPattern ')'
  		                       ThrowsPattern?
	
		ConstructorModifiersPattern := '!'? ConstructorModifier ConstructorModifiersPattern*
		
		ConstructorModifier := 'public' | 'private' | 'protected'
		
	</pre><p>
  	    The optional <tt>AnnotationPattern</tt> at the beginning of a 
  	    method or constructor pattern restricts matches to methods/constructors with
  	    annotations that match the pattern. For example:
  	</p><div class="variablelist"><dl><dt><a name="d0e1063"></a><span class="term">@Oneway * *(..)</span></dt><dd><p><a name="d0e1066"></a>
            	Matches a method with any return type and any name, that has an annotation of
            	type <tt>@Oneway</tt>.
            </p></dd><dt><a name="d0e1072"></a><span class="term">@Transaction * (@Persistent org.xyz..*).*(..)</span></dt><dd><p><a name="d0e1075"></a>
            	Matches a method with the <tt>@Transaction</tt> annotation,
            	declared in a type with the <tt>@Persistent</tt> annotation, and
            	in a package beginning with the <tt>org.xyz</tt> prefix.
            </p></dd><dt><a name="d0e1087"></a><span class="term">* *.*(@Immutable *,..)</span></dt><dd><p><a name="d0e1090"></a>
            	Matches any method taking at least one parameter, where the parameter
            	type has an annotation <tt>@Immutable</tt>.
            </p></dd></dl></div></div><div class="sect2"><a name="d0e1096"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1096"></a>Example Pointcuts</h3></div></div><div class="variablelist"><dl><dt><a name="d0e1100"></a><span class="term">within(@Secure *)</span></dt><dd><p><a name="d0e1103"></a>
            	Matches any join point where the code executing is declared in a 
            	type with an <tt>@Secure</tt>
            	annotation. The format of the <tt>within</tt> pointcut designator
            	in AspectJ 5 is <tt>'within' '(' OptionalParensTypePattern ')'</tt>.
            </p></dd><dt><a name="d0e1115"></a><span class="term">staticinitialization(@Persistent *)</span></dt><dd><p><a name="d0e1118"></a>
            	Matches the staticinitialization join point of any type with the
            	<tt>@Persistent</tt> annotation. The format of the 
            	<tt>staticinitialization</tt> pointcut designator
            	in AspectJ 5 is <tt>'staticinitialization' '(' OptionalParensTypePattern ')'</tt>.
            </p></dd><dt><a name="d0e1130"></a><span class="term">call(@Oneway * *(..))</span></dt><dd><p><a name="d0e1133"></a>
            	Matches a call to a method with a <tt>@Oneway</tt> annotation.
            </p></dd><dt><a name="d0e1139"></a><span class="term">execution(public (@Immutable *) org.xyz..*.*(..)</span></dt><dd><p><a name="d0e1142"></a>
                The execution of any public method in a package with prefix 
                <tt>org.xyz</tt>, where the method returns an 
                immutable result.
            </p></dd><dt><a name="d0e1148"></a><span class="term">set(@Cachable * *)</span></dt><dd><p><a name="d0e1151"></a>
                Matches the set of any cachable field.
            </p></dd><dt><a name="d0e1154"></a><span class="term">handler(!@Catastrophic *)</span></dt><dd><p><a name="d0e1157"></a>
                Matches the handler join point for the handling of any exception that is
                not <tt>Catastrophic</tt>. The format of the <tt>handler</tt>
                pointcut designator in AspectJ 5 is <tt>'handler' '(' OptionalParensTypePattern ')'</tt>.
            </p></dd></dl></div></div><div class="sect2"><a name="d0e1169"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1169"></a>Runtime type matching and context exposure</h3></div></div><p>AspectJ 5 supports a set of "@" pointcut designators which
    can be used both to match based on the presence of an annotation at
    runtime, and to expose the annotation value as context in a pointcut or
    advice definition. These designators are <tt>@args, @this, @target,
    @within, @withincode</tt>, and <tt>@annotation</tt>
    </p><p>It is a compilation error to attempt to match on an annotation type 
    that does not have runtime retention using <tt>@this, @target</tt>
    or <tt>@args</tt>. It is a compilation error to attempt to use
    any of these designators to expose an annotation value that does not
    have runtime retention.</p><p>
        The <tt>this()</tt>, <tt>target()</tt>, and
        <tt>args()</tt> pointcut designators allow matching based
        on the runtime type of an object, as opposed to the statically 
        declared type. In AspectJ 5, these designators are supplemented
        with three new designators : <tt>@this()</tt> (read, "this
        annotation"), <tt>@target()</tt>, and <tt>@args()</tt>.    
    </p><p>
        Like their counterparts, these pointcut designators can be used 
        both for join point matching, and to expose context. The format of 
        these new designators is:
    </p><pre class="programlisting">  	
  	    AtThis := '@this' '(' AnnotationOrIdentifer ')'
    
  	    AtTarget := '@target' '(' AnnotationOrIdentifier ')'
  	
  	    AnnotationOrIdentifier := '@' FullyQualifiedName | Identifier
        
  	    AtArgs := '@args' '(' AnnotationsOrIdentifiersPattern ')'
        
  	    AnnotationsOrIdentifiersPattern :=
  	                      '..' (',' AnnotationsOrIdentifiersPatternAfterDotDot)? |
  	                      AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPattern)* |
  	                      '*' (',' AnnotationsOrIdentifiersPattern)*
		                  
  	    AnnotationsOrIdentifiersPatternAfterDotDot := 
		                  AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPatternAfterDotDot)* |
		                  '*' (',' AnnotationsOrIdentifiersPatternAfterDotDot)*
  	
	</pre><p>
        The forms of <tt>@this()</tt> and <tt>@target()</tt> that
        take a single annotation name are analogous to their counterparts that take
        a single type name. They match at join points where the object bound to 
        <tt>this</tt> (or <tt>target</tt>, respectively) has an
        annotation of the specified type. For example: 
    </p><div class="variablelist"><dl><dt><a name="d0e1227"></a><span class="term">@this(@Foo)</span></dt><dd><p><a name="d0e1230"></a>
            	Matches any join point where the object currently bound to 'this'
            	has an annotation of type <tt>Foo</tt>.
            </p></dd><dt><a name="d0e1236"></a><span class="term">call(* *(..)) &amp;&amp; @target(@Classified)</span></dt><dd><p><a name="d0e1239"></a>
            	Matches a call to any object where the target of the call has
            	a <tt>@Classified</tt> annotation.
            </p></dd></dl></div><p>
        Annotations can be exposed as context in the body of advice by 
        using the forms of <tt>@this(), @target()</tt> and
        <tt>@args()</tt> that use bound variables in the place
        of annotation names. For example:
    </p><pre class="programlisting">
  	pointcut callToClassifiedObject(Classified classificationInfo) :
  	    call(* *(..)) &amp;&amp; @target(classificationInfo);

  	pointcut txRequiredMethod(Tx transactionAnnotation) :
  	    execution(* *(..)) &amp;&amp; @this(transactionAnnotation) 
  	    &amp;&amp; if(transactionAnnotation.policy == Tx.Policy.REQUIRED);
	</pre><p>
        The <tt>@args</tt> pointcut designator behaves as its <tt>args</tt>
        counterpart, matching join points based on number and position of arguments, and 
        supporting the <tt>*</tt> wildcard and at most one <tt>..</tt>
        wildcard. An annotation at a given position in an <tt>@args</tt> expression
        indicates that the runtime type of the argument in that position at a join point must
        have an annotation of the indicated type. For example:
    </p><pre class="programlisting">
  	/**
  	 * matches any join point with at least one argument, and where the
  	 * type of the first argument has the @Classified annotation
  	 */
  	pointcut classifiedArgument() : @args(@Classified,..);
  	
  	/**
  	 * matches any join point with three arguments, where the third
  	 * argument has an annotation of type @Untrusted.
  	 */
  	pointcut untrustedData(Untrusted untrustedDataSource) : 
  	    @args(*,*,untrustedDataSource);
	</pre><p>
        <span class="emphasis"><i>Note: an alternative design would be to allow both annotation
        patterns and type patterns to be specified in the existing args pcd.
        This works well for matching, but is more awkward when it comes to
        exposing context.</i></span>
    </p><p>Access to <tt>AnnotatedElement</tt> information is available
    reflectively with the body of advice through the <tt>thisJoinPoint</tt>,
    <tt>thisJoinPointStaticPart</tt>, and 
    <tt>thisEnclosingJoinPointStaticPart</tt> variables. To access 
    annotations on the arguments, or object bound to this or target at a join
    point you can use the following code fragments:</p><pre class="programlisting">
  	Annotation[] thisAnnotations = thisJoinPoint.getThis().getClass().getAnnotations();
  	Annotation[] targetAnnotations = thisJoinPoint.getTarget().getClass().getAnnotations();
  	Annotation[] firstParamAnnotations = thisJoinPoint.getArgs()[0].getClass().getAnnotations();
	</pre><p>
        <span class="emphasis"><i>Note: it would be nicer to provide direct helper methods in
        the JoinPoint interface or a sub-interface that provide the annotations
        directly, something like "AnnotatedElement getThisAnnotationInfo()".
        The problem here is that the "AnnotatedElement" type is only in the
        Java 5 runtime libraries, and we don't want to tie the AspectJ runtime
        library to Java 5. A sub-interface and downcast solution could be used
        if these helpers were felt to be sufficiently important.</i></span>
    </p><p>
    The <tt>@within</tt> and <tt>@withincode</tt> pointcut designators
    match any join point where the executing code is defined within a type (<tt>@within</tt>),
     or a method/constructor (<tt>@withincode</tt>) that has an annotation of the specified 
    type. The form of these designators is:
    </p><pre class="programlisting">  	
        AtWithin := '@within' '(' AnnotationOrIdentifier ')'
        AtWithinCode := '@withincode' '(' AnnotationOrIdentifier ')'        
    </pre><p>Some examples of using these designators follow:</p><div class="variablelist"><dl><dt><a name="d0e1319"></a><span class="term">@within(@Foo)</span></dt><dd><p><a name="d0e1322"></a>
            	Matches any join point where the executing code is defined 
            	within a type which has an annotation of type <tt>Foo</tt>.
            </p></dd><dt><a name="d0e1328"></a><span class="term">pointcut insideCriticalMethod(Critical c) : 
                  @withincode(c);</span></dt><dd><p><a name="d0e1331"></a>
            	Matches any join point where the executing code is defined
            	in a method or constructor which has an annotation of type <tt>@Critical</tt>,
            	and exposes the value of the annotation in the parameter 
            	<tt>c</tt>.
            </p></dd></dl></div><p>The <tt>@annotation</tt> pointcut designator matches any
    join point where the <span class="emphasis"><i>subject</i></span> of the join point has 
    an annotation of the given type. Like the other @pcds, it can also be
    used for context exposure.</p><pre class="programlisting">  	
        AtAnnotation := '@annotation' '(' AnnotationOrIdentifier ')'
    </pre><p>The subject of a join point is defined in the table in chapter one of
    this guide.</p><p>
      Access to annotation information on members at a matched join point is also available
      through the <tt>getSignature</tt> method of the <tt>JoinPoint</tt>
      and <tt>JoinPoint.StaticPart</tt> interfaces. The <tt>MemberSignature</tt>
      interface is extended with the additional operation 
      <tt>java.lang.reflect.AccessibleObject getAccessibleObject()</tt>. The following fragment
      illustrates an example use of this interface to access annotation information.
    </p><pre class="programlisting">
  	Signature sig = thisJoinPointStaticPart.getSignature();
  	AnnotatedElement declaringTypeAnnotationInfo = sig.getDeclaringType();
  	if (sig instanceof MemberSignature) {
  	  // this must be an initialization, pre-initialization, call, execution, get, or
  	  // set join point.
  	  AnnotatedElement memberAnnotationInfo = ((MemberSignature)sig).getAccessibleObject();
  	}
	</pre><p>
        <span class="emphasis"><i>Note again that it would be nicer to add the method getAnnotationInfo
        directly to MemberSignature, but this would once more couple the runtime library
        to Java 5.</i></span>
    </p><p>
        The <tt>@this,@target</tt> and <tt>@args</tt> 
        pointcut designators can only be used to match against annotations 
        that have runtime retention. The <tt>@within, @withincode</tt>
        and <tt>@annotation</tt> pointcut designators can only be used
        to match against annotations that have at least class-file retention, and
        if used in the binding form the annotation must have runtime retention. 
    </p></div><div class="sect2"><a name="d0e1390"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1390"></a>Package and Parameter Annotations</h3></div></div><p>
          <span class="emphasis"><i>Note: A previous design allowed package annotation patterns to be specified
          directly in type patterns, and parameter annotation patterns to be
          specified directly in method and constructor signature patterns. Because
          this made some pointcut expressions hard to read and understand, we moved
          in favour of the design presented below, which also has its drawbacks. 
          Matching on package and parameter annotations will be
          deferred until after the 1.5.0 release so that we can gain more understanding
          of the kinds of uses AspectJ users are making of annotations in pointcut
          expressions before commiting to any one approach.</i></span>
      </p></div><div class="sect2"><a name="d0e1400"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1400"></a>Annotation Inheritance and pointcut matching</h3></div></div><p>
  	    According to the Java 5 specification, non-type annotations are not
  	    inherited, and annotations on types are only inherited if they have the 
  	    <tt>@Inherited</tt> meta-annotation.
  	    
  	    Given the following program:
  	</p><pre class="programlisting">
  	class C1 {
  	  @SomeAnnotation
  	  public void aMethod() {...}
  	}
  	
  	class C2 extends C1 {
  	  public void aMethod() {...}
  	}
  	
  	class Main {
  	  public static void main(String[] args) {
  	    C1 c1 = new C1();
  	    C2 c2 = new C2();
  	    c1.aMethod();
  	    c2.aMethod();
  	  }
  	}
  	
  	aspect X {
  	
  	  pointcut annotatedMethodCall() : 
  	    call(@SomeAnnotation * C1.aMethod());
  	
  	  pointcut c1MethodCall() :
  	    call(* C1.aMethod());
  	}
	</pre><p>
  	    The pointcut <tt>annotatedMethodCall</tt> will match the call
  	    to <tt>c1.aMethod()</tt>, but not the call to 
  	    <tt>c2.aMethod()</tt>.
  	</p><p>
  	    The pointcut <tt>c1MethodCall</tt> matches both 
  	    <tt>c1.aMethod()</tt> and <tt>c2.aMethod()</tt>.
  	</p></div><div class="sect2"><a name="d0e1432"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1432"></a>Limitations</h3></div></div><p>
        It would be useful to be able to match join points based on  
        annotation values, rather than merely the presence of a
        class-file retention annotation of a given type. This facility may be supported in a future version of AspectJ, by expanding the
        definition of <tt>AnnotationPattern</tt>. Matching annotation values for
        annotations with runtime retention can be done by exposing the annotation value
        as a pointcut parameter and then using an <tt>if</tt> pointcut expression
        to test the value. 
    </p></div></div><div class="sect1"><a name="annotations-decp"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="annotations-decp"></a>Using Annotations with declare statements</h2></div></div><div class="sect2"><a name="d0e1447"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1447"></a>Declare error and declare warning</h3></div></div><p>
  	    Since pointcut expressions in AspectJ 5 support join point matching based
  	    on annotations, this facility can be exploited when writing
  	    <tt>declare warning</tt> and <tt>declare error</tt>
  	    statements. For example:
  	</p><pre class="programlisting">
  	declare warning : withincode(@PerformanceCritical * *(..)) &amp;&amp;
  	                  call(@ExpensiveOperation * *(..))
  	                : "Expensive operation called from within performance critical section";
	</pre><pre class="programlisting">
  	declare error : call(* org.xyz.model.*.*(..)) &amp;&amp;
  	                !@within(@Trusted *)
  	                : "Untrusted code should not call the model classes directly";
	</pre></div><div class="sect2"><a name="d0e1462"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1462"></a>declare parents</h3></div></div><p>
  		The general form of a <tt>declare parents</tt> statement is:
  	</p><pre class="programlisting">
  	declare parents : TypePattern extends Type;
  	declare parents : TypePattern implements TypeList;
	</pre><p>
		Since AspectJ 5 supports annotations as part of a type pattern
		specification, it is now possible to match types based on the presence
		of annotations <span class="emphasis"><i>with either class-file or runtime retention</i></span>.
		For example:
	</p><div class="variablelist"><dl><dt><a name="d0e1478"></a><span class="term">declare parents : (@Secured *) implements SecuredObject;</span></dt><dd><p><a name="d0e1481"></a>
	            	All types with the <tt>@Secured</tt> annotation
	            	implement the <tt>SecuredObject</tt> inteface.
	            </p></dd><dt><a name="d0e1490"></a><span class="term">declare parents : (@Secured BankAccount+) implements SecuredObject;</span></dt><dd><p><a name="d0e1493"></a>
	            	The subset of types drawn from the <tt>BankAccount</tt> type and any subtype of
	            	<tt>BankAccount</tt>, where the 
	            	<tt>@Secured</tt> annotation is present, implement the
	            	<tt>SecuredObject</tt> interface.
	            </p></dd></dl></div><p>An annotation type may not be used as the target of a declare parents
    statement. If an annotation type is named explicitly as the target of a
    declare parents statement, a compilation error will result. If an annotation
    type is matched by a non-explicit type pattern used in a declare parents
    statement it will be ignored (and an XLint warning issued).</p></div><div class="sect2"><a name="d0e1510"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1510"></a>declare precedence</h3></div></div><p>
		The general form of a declare precedence statement is:
	</p><pre class="programlisting">
  	declare precedence : TypePatList;
	</pre><p>
		AspectJ 5 allows the type patterns in the list to include annotation information
		as part of the pattern specification. For example:
	</p><div class="variablelist"><dl><dt><a name="d0e1520"></a><span class="term">declare precedence : (@Security *),*;</span></dt><dd><p><a name="d0e1523"></a>
            	All aspects with the <tt>@Security</tt> annotation
            	take precedence over any other aspects in the system. (Or, more
            	informally, all security-related aspects take precedence).
            </p></dd></dl></div></div></div><div class="sect1"><a name="annotations-declare"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="annotations-declare"></a>Declare Annotation</h2></div></div><p>AspectJ 5 supports a new kind of declare statement, <tt>declare annotation</tt>.
      The general form of a <tt>declare annotation</tt> statement is:
      </p><pre class="programlisting">
  	declare annotation : ElementPattern : Annotation ;
	</pre><p>Where annotation is a regular annotation expression as defined in the Java 5 language. If the annotation has 
    the <tt>@Target</tt> meta-annotation, then the elements matched by <tt>ElementPattern</tt>
    must be of the kind specified by the <tt>@Target</tt> annotation.</p><p><tt>ElementPattern</tt> is defined as follows:</p><pre class="programlisting">
  	        ElementPattern := TypePattern |
  	                          MethodPattern |
  	                          ConstructorPattern |
  	                          FieldPattern
	</pre><p>The following examples illustrate the use of <tt>declare annotation</tt>.</p><div class="variablelist"><dl><dt><a name="d0e1566"></a><span class="term">declare annotation : org.xyz.model..* : @BusinessDomain ;</span></dt><dd><p><a name="d0e1569"></a>
                    All types defined in a package with the prefix <tt>org.xyz.model</tt>
                    have the <tt>@BusinessDomain</tt> annotation.
	            </p></dd><dt><a name="d0e1578"></a><span class="term">declare annotation : public * BankAccount+.*(..) : @Secured(role="supervisor")</span></dt><dd><p><a name="d0e1581"></a>
	                All public methods in <tt>BankAccount</tt> and its subtypes have the
	                annotation <tt>@Secured(role="supervisor")</tt>.
	            </p></dd><dt><a name="d0e1590"></a><span class="term">declare annotation : * DAO+.* : @Persisted;</span></dt><dd><p><a name="d0e1593"></a>
	            	All fields defined in <tt>DAO</tt> or its subtypes have the
	            	<tt>@Persisted</tt> annotation.
	            </p></dd></dl></div></div><div class="sect1"><a name="annotations-itds"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="annotations-itds"></a>Inter-type Declarations</h2></div></div><p>An annotation type may not be the target of an inter-type declaration.</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="generics"></a>Chapter 3. Generics</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#generics-inJava5">Generics in Java 5</a></dt><dd><dl><dt><a href="#d0e1615">Declaring Parameterized Types</a></dt><dt><a href="#d0e1618">Using Parameterized Types</a></dt><dt><a href="#d0e1621">Assignments and Wildcards</a></dt><dt><a href="#d0e1624">Generic Methods</a></dt></dl></dd><dt><a href="#generics-inAspectJ5"></a></dt><dd><dl><dt><a href="#d0e1628">Parameterized Aspect Types</a></dt><dt><a href="#d0e1631"></a></dt><dt><a href="#d0e1633"></a></dt><dt><a href="#d0e1635"></a></dt></dl></dd></dl></div><div class="sect1"><a name="generics-inJava5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="generics-inJava5"></a>Generics in Java 5</h2></div></div><p>
		This section provides the essential information about generics in
		Java 5 needed to understand how generics are treated in AspectJ 5.
		For a full introduction to generics in Java, please see the
		documentation for the Java 5 SDK.
	</p><div class="sect2"><a name="d0e1615"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1615"></a>Declaring Parameterized Types</h3></div></div></div><div class="sect2"><a name="d0e1618"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1618"></a>Using Parameterized Types</h3></div></div></div><div class="sect2"><a name="d0e1621"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1621"></a>Assignments and Wildcards</h3></div></div></div><div class="sect2"><a name="d0e1624"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1624"></a>Generic Methods</h3></div></div></div></div><div class="sect1"><a name="generics-inAspectJ5"></a><div class="titlepage"></div><div class="sect2"><a name="d0e1628"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1628"></a>Parameterized Aspect Types</h3></div></div></div><div class="sect2"><a name="d0e1631"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1631"></a></h3></div></div></div><div class="sect2"><a name="d0e1633"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1633"></a></h3></div></div></div><div class="sect2"><a name="d0e1635"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1635"></a></h3></div></div></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="autoboxing"></a>Chapter 4. Autoboxing and Unboxing</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#boxing-inJava5">Autoboxing and Unboxing in Java 5</a></dt><dt><a href="#autoboxing-in-aspectj5">Autoboxing and Join Point matching in AspectJ 5</a></dt><dt><a href="#autoboxing-and-method-dispatch">Inter-type method declarations and method dispatch</a></dt></dl></div><div class="sect1"><a name="boxing-inJava5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="boxing-inJava5"></a>Autoboxing and Unboxing in Java 5</h2></div></div><p>
          Java 5 (and hence AspectJ 1.5) supports automatic conversion of 
          primitive types (int, float, double etc.) to their object equivalents
          (Integer, Float, Double,...) in assignments and method and constructor
          invocations. This conversion is know as autoboxing.
        </p><p>Java 5 also supports automatic unboxing, where wrapper types
        are automatically converted into their primitive equivalents if
        needed for assignments or method or constructor invocations.</p><p>For example:</p><pre class="programlisting">
		int i = 0;
		i = new Integer(5); // auto-unboxing
		
		Integer i2 = 5;  // autoboxing
		</pre></div><div class="sect1"><a name="autoboxing-in-aspectj5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="autoboxing-in-aspectj5"></a>Autoboxing and Join Point matching in AspectJ 5</h2></div></div><p>Most of the pointcut designators match based on signatures, and
          hence are unaffected by autoboxing. For example, a call to a method</p><pre class="programlisting">
   		public void foo(Integer i);
   		</pre><p>is <span class="emphasis"><i>not</i></span> matched by a pointcut
         <tt>call(void foo(int))</tt> since the signature declares
         a single <tt>Integer</tt> parameter, not an <tt>int</tt>.
         </p><p>The <tt>args</tt> pointcut designator is affected by
         autoboxing since it matches based on the runtime type of the arguments.
         AspectJ 5 applies autoboxing and unboxing in determining argument matching.
         In other words, <tt>args(Integer)</tt> will match any join
         point at which there is a single argument of type <tt>Integer</tt>
         or of type <tt>int</tt>.</p><div class="itemizedlist"><ul><li><a name="d0e1687"></a>args(Integer) and args(int) are equivalent</li><li><a name="d0e1689"></a>args(Float) and args(float) are equivalent</li><li><a name="d0e1691"></a>args(Double) and args(double) are equivalent</li><li><a name="d0e1693"></a>args(Short) and args(short) are equivalent</li><li><a name="d0e1695"></a>args(Byte) and args(byte) are equivalent</li><li><a name="d0e1697"></a>args(Long) and args(long) are equivalent</li><li><a name="d0e1699"></a>args(Boolean) and args(boolean) are equivalent</li></ul></div><p>
        Autoboxing and unboxing are also applied when binding pointcut or 
        advice parameters, for example:   
      </p><pre class="programlisting">
   		pointcut foo(int i) : args(i);
   		
   		before(Integer i) : foo(i) {
   		  ...
   		}
   		</pre></div><div class="sect1"><a name="autoboxing-and-method-dispatch"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="autoboxing-and-method-dispatch"></a>Inter-type method declarations and method dispatch</h2></div></div><p>Autoboxing, unboxing, and also varargs all affect the method
          dispatch algorithm used in Java 5. In AspectJ 5, the target method
          of a call is selected according to the following algorithm:</p><div class="orderedlist"><ol type="1"><li><a name="d0e1711"></a>Attempt to locate a matching method or inter-type declared
              method without considering
              autoboxing, unboxing, or vararg invocations.</li><li><a name="d0e1713"></a>If no match is found, try again considering autoboxing
              and unboxing.</li><li><a name="d0e1715"></a>Finally try again considering both autoboxing, unboxing,
              and varargs.</li></ol></div><p>One consequence is that a directly matching inter-type declared
          method will take precedence over a method declared locally in the 
          target class but that only matches via autoboxing.</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="covariance"></a>Chapter 5. Covariance</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#covariance-inJava5">Covariance in Java 5</a></dt><dt><a href="#covariance-and-join-point-matching">Covariant methods and Join Point matching</a></dt></dl></div><div class="sect1"><a name="covariance-inJava5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="covariance-inJava5"></a>Covariance in Java 5</h2></div></div><p>
          Java 5 (and hence AspectJ 5) allows you to narrow the return type
          in an overriding method. For example:
        </p><pre class="programlisting">
		class A {
		  public A whoAreYou() {...}
		}
		
		class B extends A {
		  // override A.whoAreYou *and* narrow the return type.
		  public B whoAreYou() {...}
		}
		</pre></div><div class="sect1"><a name="covariance-and-join-point-matching"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="covariance-and-join-point-matching"></a>Covariant methods and Join Point matching</h2></div></div><p>The join point matching rules for <tt>call</tt>
          and <tt>execution</tt> pointcut designators are extended
          to match against covariant methods.</p><p>
              Given the classes <tt>A</tt> and <tt>B</tt>
              as defined in the previous section, and the program fragment
          </p><pre class="programlisting">
		A a = new A();
		B b = new B();
		a.whoAreYou();
		b.whoAreYou();
		</pre><p>The signatures for the call join point <tt>a.whoAreYou()</tt> are
		simply:</p><pre class="programlisting">
		A A.whoAreYou()
		</pre><p>The signatures for the call join point <tt>b.whoAreYou()</tt> are:
		</p><pre class="programlisting">
		A A.whoAreYou()
		B B.whoAreYou()
		</pre><p>Following the join point matching rules given in <a href="#jpsigs">Join Point Signatures</a>,</p><div class="variablelist"><dl><dt><a name="d0e1769"></a><span class="term">call(* whoAreYou())</span></dt><dd><p><a name="d0e1772"></a>Matches both calls, (since each call join point has at least
            one matching signature).
            </p></dd><dt><a name="d0e1775"></a><span class="term">call(* A.whoAreYou())</span></dt><dd><p><a name="d0e1778"></a>Matches both calls, (since each call join point has at least
            one matching signature).
            </p></dd><dt><a name="d0e1781"></a><span class="term">call(A whoAreYou())</span></dt><dd><p><a name="d0e1784"></a>Matches both calls, (since each call join point has at least
            one matching signature).
            </p></dd><dt><a name="d0e1787"></a><span class="term">call(A B.whoAreYou())</span></dt><dd><p><a name="d0e1790"></a>Does not match anything - neither of the call join points
            has a signature matched by this pattern.  A lint warning is
            given for the call <tt>a.whoAreYou()</tt> ("does not match
            because declaring type is A, if match required use target(B)").
            </p></dd><dt><a name="d0e1796"></a><span class="term">call(A+ B.whoAreYou())</span></dt><dd><p><a name="d0e1799"></a>Matches the call to <tt>b.whoAreYou()</tt> since
            the signature pattern matches the signature <tt>B B.whoAreYou()</tt>. 
            A lint warning is given for the call <tt>a.whoAreYou()</tt> ("does not match
            because declaring type is A, if match required use target(B)").
            </p></dd><dt><a name="d0e1811"></a><span class="term">call(B A.whoAreYou())</span></dt><dd><p><a name="d0e1814"></a>Does not match anything since neither join point has a 
            signature matched by this pattern.
            </p></dd><dt><a name="d0e1817"></a><span class="term">call(B whoAreYou())</span></dt><dd><p><a name="d0e1820"></a>Matches the call to <tt>b.whoAreYou()</tt> only.
            </p></dd><dt><a name="d0e1826"></a><span class="term">call(B B.whoAreYou())</span></dt><dd><p><a name="d0e1829"></a>Matches the call to <tt>b.whoAreYou()</tt> only.
            </p></dd></dl></div><p>The rule for signature matching at call and execution join points
		is unchanged from AspectJ 1.2: a call or execution pointcut matches if
		the signature pattern matches at least one of the signatures of the
		join point, and if the modifiers of the method or constructor are matched
		by any modifier pattern or annotation pattern that may be present.</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="varargs"></a>Chapter 6. Varargs</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#varargs-inJava5">Variable-length Argument Lists in Java 5</a></dt><dd><dl><dt><a href="#d0e1849">Calling Methods and Constructors with variable-length arguments</a></dt></dl></dd><dt><a href="#varargs-in-pcds">Using Variable-length arguments in advice and pointcut expressions</a></dt><dd><dl><dt><a href="#d0e1883">Matching signatures based on variable length argument types</a></dt><dt><a href="#d0e1985">Exposing variable-length arguments as context in pointcuts and advice</a></dt></dl></dd></dl></div><div class="sect1"><a name="varargs-inJava5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="varargs-inJava5"></a>Variable-length Argument Lists in Java 5</h2></div></div><p>
          Java 5 (and hence AspectJ 5) allows you to specify methods that take a 
          variable number of arguments of a specified type. This is achieved using
          an ellipsis (...) in the method signature as shown:    
        </p><pre class="programlisting">
		public void foo(int i, String... strings) { 
		}
		</pre><p>
            A method or constructor may take at most one variable length argument, and
            this must always be the last declared argument in the signature.
        </p><div class="sect2"><a name="d0e1849"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1849"></a>Calling Methods and Constructors with variable-length arguments</h3></div></div><p>
             A <span class="emphasis"><i>varargs</i></span> method may be called with zero or more arguments
             in the variable argument position. For example, given the definition of 
             <tt>foo</tt> above, the following calls are all legal:
            </p><pre class="programlisting">
    	foo(5);
    	foo(5,"One String");
    	foo(7,"One String","Two Strings");
    	foo(3,"One String","Two Strings","Three Strings");	
    	</pre><p>A <span class="emphasis"><i>varargs</i></span> parameter is treated as an array within the 
            defining member. So in the body of <tt>foo</tt> we could write for example:
            </p><pre class="programlisting">
    	public void foo(int i, String... strings) {
    	  String[] someStrings = strings;
    	  // rest of method body
    	}
    	</pre><p>One consequence of this treatment of a varargs parameter as an array
            is that you can also call a varargs method with an array:</p><pre class="programlisting">
    	foo(7,new String[] {"One String","Two Strings"});
    	</pre></div></div><div class="sect1"><a name="varargs-in-pcds"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="varargs-in-pcds"></a>Using Variable-length arguments in advice and pointcut expressions</h2></div></div><p>AspectJ 5 allows variable-length arguments to be used for methods declared within
        aspects, and for inter-type declared methods and constructors, in accordance with the rules
        outlined in the previous section.</p><p>
        AspectJ 5 also allows variable length arguments to be matched by pointcut expressions and
        bound as formals in advice.
        </p><div class="sect2"><a name="d0e1883"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1883"></a>Matching signatures based on variable length argument types</h3></div></div><p>
            Recall from the definition of signature patterns given in the chapter on
            annotations (<a href="#signaturePatterns">Signature Patterns</a>), that <tt>MethodPattern</tt>
            and <tt>ConstructorPattern</tt> are extended to allow a <tt>varargs</tt>
            pattern in the last argument position of a method or constructor signature.
            </p><pre class="programlisting">  	
 		FormalsPattern := '..' (',' FormalsPatternAfterDotDot)? |
		                  OptionalParensTypePattern (',' FormalsPattern)* |
		                  TypePattern '...'
		                  
		FormalsPatternAfterDotDot := 
		        OptionalParensTypePattern (',' FormalsPatternAfterDotDot)* |
		        TypePattern '...'

    	</pre><p>
                Method and constructor patterns are used in the <tt>call</tt>,
                <tt>execution</tt>, <tt>initialization</tt>,
                <tt>preinitialization</tt>, and <tt>withincode</tt>
                pointcut designators. Some examples of usage follow:
            </p><div class="variablelist"><dl><dt><a name="d0e1919"></a><span class="term">call(* org.xyz.*.*(int, String...))</span></dt><dd><p><a name="d0e1922"></a>
            	Matches a call join point for a call to a method defined in the
            	<tt>org.xyz</tt> package, taking an <tt>int</tt>
            	and a <tt>String vararg</tt>.
            </p></dd><dt><a name="d0e1934"></a><span class="term">execution(* org.xyz.*.*(Integer...))</span></dt><dd><p><a name="d0e1937"></a>
            	Matches an execution join point for the execution of a method defined in the
            	<tt>org.xyz</tt> package, taking an <tt>Integer vararg</tt>.
            </p></dd><dt><a name="d0e1946"></a><span class="term">initialization(org.xyz.*.new((Foo || Goo)...))</span></dt><dd><p><a name="d0e1949"></a>
            	Matches the initialization join point for the construction of an
            	object in the <tt>org.xyz</tt> package via a constructor
            	taking either a variable number of <tt>Foo</tt> parameters or
            	a variable number of <tt>Goo</tt> parameters. (This example
            	illustrating the use of a type pattern with ...).
            </p></dd></dl></div><p>A variable argument parameter and an array parameter are treated as distinct
        signature elements, so given the method definitions:
        </p><pre class="programlisting">
    	void foo(String...);
    	void bar(String[]);
    	</pre><p>
            The pointcut <tt>execution(* *.*(String...))</tt> matches the execution join point
            for <tt>foo</tt>, but not <tt>bar</tt>. The pointcut 
            <tt>execution(* *.*(String[]))</tt> matches the execution join point
            for <tt>bar</tt> but not <tt>foo</tt>.
        </p></div><div class="sect2"><a name="d0e1985"></a><div class="titlepage"><div><h3 class="title"><a name="d0e1985"></a>Exposing variable-length arguments as context in pointcuts and advice</h3></div></div><p>
            When a varargs parameter is used within the body of a method, it has
            an array type, as discussed in the introduction to this section. We follow the
            same convention when binding a varargs parameter via the <tt>args</tt>
            pointcut designator. Given a method
            </p><pre class="programlisting">
		public void foo(int i, String... strings) { 
		}
		</pre><p>
            The call or execution join points for <tt>foo</tt> will be matched
            by the pointcut <tt>args(int,String[])</tt>. It is not permitted
            to use the varargs syntax within an args pointcut designator - so you
            <span class="emphasis"><i>cannot</i></span> write <tt>args(int,String...)</tt>.
            </p><p>
            Binding of a varargs parameter in an advice statement is straightforward:
            </p><pre class="programlisting">
		before(int i, String[] ss) : call(* foo(int,String...)) &amp;&amp; args(i,ss) {
		  // varargs String... argument is accessible in advice body through ss
		  // ...
		}
		</pre><p>Since you cannot use the varargs syntax in the <tt>args</tt>
             pointcut designator, you also cannot use the varargs syntax to declare
             advice parameters.</p><p>Note: the proposal in this section does not allow you to 
            distinguish between a join point with a signature (int, String...)
            and a join point with a signature (int, String[]) based 
            <span class="emphasis"><i>solely</i></span> on the use of the <tt>args</tt>
            pointcut designator. If this distinction is required, <tt>args</tt>
            can always be coupled with <tt>call</tt> or 
            <tt>execution</tt>.</p></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="enumeratedtypes"></a>Chapter 7. Enumerated Types</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#enums-in-java5">Enumerated Types in Java 5</a></dt><dt><a href="#enums-in-aspectj5">Enumerated Types in AspectJ 5</a></dt></dl></div><div class="sect1"><a name="enums-in-java5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="enums-in-java5"></a>Enumerated Types in Java 5</h2></div></div><p>Java 5 (and hence AspectJ 5) provides explicit support for
      enumerated types. In the simplest case, you can declare an enumerated
      type as follows:</p><pre class="programlisting">
      public enum ProgrammingLanguages {
       COBOL,C,JAVA,ASPECTJ
      }
      </pre><p>Enumerated types are just classes, and they can contain method
      and field declarations, and may implement interfaces. Enums may only
      have private constructors, and may not be extended.</p><p>Enumerated types in Java 5 all implicitly extend the type
      <tt>java.lang.Enum</tt>. It is illegal to explicitly
      declare a subtype of this class.</p></div><div class="sect1"><a name="enums-in-aspectj5"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="enums-in-aspectj5"></a>Enumerated Types in AspectJ 5</h2></div></div><p>
      AspectJ 5 supports the declaration of enumerated types just as Java 5
      does. Because of the special restrictions Java 5 places around enumerated
      types, AspectJ makes the following additional restrictions:
      </p><div class="itemizedlist"><ul><li><a name="d0e2058"></a>You cannot use declare parents to change the super type of
          an enum.</li><li><a name="d0e2060"></a>You cannot use declare parents to declare java.lang.Enum as
          the parent of any type.</li><li><a name="d0e2062"></a>You cannot make inter-type constructor declarations on an
          enum.</li><li><a name="d0e2064"></a>You cannot extend the set of values in an enum via any
          ITD-like construct.</li><li><a name="d0e2066"></a>You cannot make inter-type method or field declarations on 
          an enum.</li><li><a name="d0e2068"></a>You cannot use declare parents to make an enum type implement
          an interface.</li></ul></div><p>In theory, the last of these two items <span class="emphasis"><i>could</i></span>
      be supported. However, AspectJ 5 follows the simple rule that <span class="emphasis"><i>
      an enum type cannot be the target of an inter-type declaration or declare
      parents statement</i></span>. This position may be relaxed in a future
      version of AspectJ.</p><p>If an enum is named explicitly as the target of a
    declare parents statement, a compilation error will result. If an enumerated
    type is matched by a non-explicit type pattern used in a declare parents
    statement it will be ignored (and an XLint warning issued).</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="pertypewithin"></a>Chapter 8. The pertypewithin Aspect Instantiation Model</h2></div></div><p>
    AspectJ 5 defines a new per-clause type for aspect instantiation: 
    <tt>pertypewithin</tt>. Unlike the other per-clauses,
    <tt>pertypewithin</tt> takes a type pattern:  
  </p><pre class="programlisting">
  	PerTypeWithin := 'pertypewithin' '(' OptionalParensTypePattern ')'
	</pre><p>
      When an aspect is declared using the <tt>pertypewithin</tt>
      instantiation model, one new aspect instance will be created for each
      type matched by the associated type pattern.
  </p><p>
      Pertypewithin aspects have <tt>aspectOf</tt> and 
      <tt>hasAspect</tt> methods with the following signatures:
  </p><pre class="programlisting">
  	/**
  	 * return true if this aspect has an instance associated with
  	 * the given type.
  	 */
  	public static boolean hasAspect(Class clazz)
  	
  	/**
  	 * return the instance associated with the given type.
  	 * Throws NoAspectBoundException if there is no such
  	 * aspect.
  	 */
  	 public static P aspectOf(Class clazz)
	</pre><p>
       Where <tt>P</tt> is the type of the <tt>pertypewithin</tt>
       aspect.
   </p><p>
       In common with the other per-clause instantiation models, the execution
       of any advice declared within a <tt>pertypewithin</tt> aspect
       is conditional upon an implicit pointcut condition. In this case, that
       any join point be <tt>within</tt> the type that the executing
       aspect is an <tt>aspectOf</tt>. For example, given the aspect
       definition
   </p><pre class="programlisting">
  	 public aspect InstanceTracking pertypewithin(org.xyz..*) {
  	 
  	   private Set&lt;WeakReference&lt;Object&gt;&gt; instances = new HashSet&lt;WeakReference&lt;Object&gt;&gt;();
  	   
  	   after(Object o) returning : execution(new(..)) {
  	     instances.add(new WeakReference&lt;Object&gt;(o);
  	   }
  	 
  	   public Set&lt;Object&gt; getInstances() {
  	      Set&lt;Object&gt; result = new HashSet&lt;Object&gt;();
  	      for(WeakReference&lt;Object&gt; ref : instances) {
  	          if (ref.get() != null) {
  	           result.add(ref.get());
  	          }
  	      }
  	      return result;
  	   }
  	 }
	</pre><p>
	    Then one aspect instance will be created for each type within
	    <tt>org.xyz..*</tt>. For each aspect instance, the
	    after returning advice will match only the execution of constructors
	    in the type that the aspect is an instance of. The net result is that
	    the aspect tracks all known instances of each type within
	    <tt>org.xyz..*</tt>. To get access to the instances, a
	    programmer can simply write 
	    <tt>InstanceTracking.instanceOf(org.xyz.SomeType).getInstances()</tt>.
	</p><p>
        A <tt>pertypewithin</tt> aspect may optionally be declared
        with a single generic type parameter. In this case, for each type 
        <tt>T</tt> matched by the type pattern, the aspect instance
        created will be of type <tt>PerTypeWithinAspect&lt;T&gt;</tt>. 
        So the previous example could also be written as:
    </p><pre class="programlisting">
  	 public aspect InstanceTracking&lt;T&gt; pertypewithin(org.xyz..*) {
  	 
  	   private Set&lt;WeakReference&lt;T&gt;&gt; instances = new HashSet&lt;WeakReference&lt;T&gt;&gt;();
  	   
  	   after(T t) returning : execution(new(..)) {
  	     instances.add(new WeakReference&lt;T&gt;(t);
  	   }
  	 
  	   public Set&lt;T&gt; getInstances() {
  	      Set&lt;T&gt; result = new HashSet&lt;T&gt;();
  	      for(WeakReference&lt;T&gt; ref : instances) {
  	          if (ref.get() != null) {
  	           result.add(ref.get());
  	          }
  	      }
  	      return result;
  	   }
  	 }
	</pre><p>
        The <tt>pertypewithin</tt> aspect instantiation model should
        be used when the implementation of a crosscutting concern requires that
        some state be maintained for each type in a set of types. To maintain
        state for a single type, it is easier to use a static inter-type declared
        field. Examples of usage include instance tracking, profiling, and the
        implementation of a common tracing idiom that uses one Logger per 
        traced class.
    </p></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="reflection"></a>Chapter 9. New Reflection Interfaces</h2></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="miscellaneous"></a>Chapter 10. Other Changes in AspectJ 5</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#d0e2164">Pointcuts</a></dt><dd><dl><dt><a href="#d0e2167">Binding of formals</a></dt><dt><a href="#d0e2172">Additional lint warnings</a></dt></dl></dd><dt><a href="#declare-soft">Declare Soft</a></dt></dl></div><div class="sect1"><a name="d0e2164"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="d0e2164"></a>Pointcuts</h2></div></div><div class="sect2"><a name="d0e2167"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2167"></a>Binding of formals</h3></div></div><p>
            Binding of formals (cannot bind same formal more than once in a conjunction, 
            can bind exactly once in each branch of a disjunction, iff the branches are mutually
            exclusive based on e.g. join point kind).     
          </p></div><div class="sect2"><a name="d0e2172"></a><div class="titlepage"><div><h3 class="title"><a name="d0e2172"></a>Additional lint warnings</h3></div></div><p>
            Discuss detection of common errors -&gt; warning/error, eg. conjunction of more than one
            kind of join point. Differing numbers of args in method signature / args / @args /
            @parameters.
          </p></div></div><div class="sect1"><a name="declare-soft"></a><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="declare-soft"></a>Declare Soft</h2></div></div><p>
          Describe change to only soften checked exceptions if we decide to 
          make it.
      </p></div></div><div class="appendix"><div class="titlepage"><div><h2 class="title"><a name="grammar"></a>Appendix A. A Grammar for the AspectJ 5 Language</h2></div></div><pre class="programlisting">
        === type patterns ===
      
        TypePattern := SimpleTypePattern |
  	                   '!' TypePattern |
  	                   '(' AnnotationPattern? TypePattern ')'
  	                   TypePattern '&amp;&amp;' TypePattern |
  	                   TypePattern '||' TypePattern |
  	  	
        SimpleTypePattern := DottedNamePattern '+'? '[]'*
  	  	
        DottedNamePattern := FullyQualifiedName RestOfNamePattern? |
  		                     '*' NotStarNamePattern?
  		
        RestOfNamePattern := '..' DottedNamePattern |
  		                     '*' NotStarNamePattern?
  		                     
        NotStarNamePattern := FullyQualifiedName RestOfNamePattern? |
  		                      '..' DottedNamePattern               

        FullyQualifiedName := JavaIdentifierCharacter+ ('.' JavaIdentifierCharacter+)*  				  		  		  		               									 				  		             
 
        === annotation patterns ===
 
        AnnotationPattern := '!'? '@' AnnotationTypePattern AnnotationPattern* 

        
        AnnotationTypePattern := FullyQualifiedName |
                                 '(' TypePattern ')'
 
        === signature patterns ===
        
        -- field --
        
        FieldPattern := 
  		    AnnotationPattern? FieldModifiersPattern? 
  		    TypePattern (TypePattern DotOrDotDot)? SimpleNamePattern

        FieldModifiersPattern := '!'? FieldModifier FieldModifiersPattern*
		                         		
        FieldModifier := 'public' | 'private' | 'protected' | 'static' | 
		                 'transient' | 'final' 
		            			
        DotOrDotDot := '.' | '..'
		
        SimpleNamePattern := JavaIdentifierChar+ ('*' SimpleNamePattern)?		            
        
        -- method --
        
        MethodPattern := 
  		    AnnotationPattern? MethodModifiersPattern? TypePattern 
  		                       (TypePattern DotOrDotDot)? SimpleNamePattern 
  		                       '(' FormalsPattern ')' ThrowsPattern?

        MethodModifiersPattern := '!'? MethodModifier MethodModifiersPattern*
		
        MethodModifier := 'public' | 'private' | 'protected' | 'static' | 
		                  'synchronized' | 'final' 
		            		      
        FormalsPattern := '..' (',' FormalsPatternAfterDotDot)? |
		                  OptionalParensTypePattern (',' FormalsPattern)* |
		                  TypePattern '...'
		                  
        FormalsPatternAfterDotDot := 
		        OptionalParensTypePattern (',' FormalsPatternAfterDotDot)* |
		        TypePattern '...'
		                  
        ThrowsPattern := 'throws' TypePatternList
		
        TypePatternList := TypePattern (',' TypePattern)*
		
        -- constructor --
		            					            
        ConstructorPattern := 
  		    AnnotationPattern? ConstructorModifiersPattern?  
  		                       (TypePattern DotOrDotDot)? 'new' '(' FormalsPattern ')'
  		                       ThrowsPattern?
	
        ConstructorModifiersPattern := '!'? ConstructorModifier ConstructorModifiersPattern*
		
        ConstructorModifier := 'public' | 'private' | 'protected'
        
        === Pointcuts ===
        
        PointcutPrimitive := 
                    Call | Execution | Get | Set | Handler | 
                    Initialization | PreInitialization |
                    StaticInitialization | AdviceExecution |
                    This | Target | Args | CFlow | CFlowBelow |
                    Within | WithinCode | If |
                    AnnotationPointcut
                    
        AnnotationPointcut := AtAnnotation | AtThis | AtTarget |
                              AtWithin | AtWithinCode | AtArgs
                    
        
        Call := 'call' '(' MethodOrConstructorPattern ')'
        
        MethodOrConstructorPattern := MethodPattern | ConstructorPattern
        
        Execution := 'execution' '(' MethodOrConstructorPattern ')'
        
        Get := 'get' '(' FieldPattern ')'        
        Set := 'set' '(' FieldPattern ')'
        Handler := 'handler' '(' OptionalParensTypePattern ')'
        Initialization := 'initialization' '(' ConstructorPattern ')'
        PreInitialization := 'preinitialization' '(' ConstructorPattern ')'
        StaticInitialization := 'staticinitialization' '(' OptionalParensTypePattern ')'
        AdviceExecution := 'adviceexecution' '(' ')'
        This := 'this' '(' TypeOrIdentifier ')'
        Target := 'target' '(' TypeOrIdentifier ')'
        Args := 'args' '(' FormalsOrIdentifiersPattern ')'
        CFlow := 'cflow' '(' Pointcut ')'
        CFlowBelow := 'cflowbelow' '(' Pointcut ')'
        Within := 'within' '(' OptionalParensTypePattern ')'
        WithinCode := 'withincode' '(' OptionalParensTypePattern ')'
        If := 'if' '(' BooleanJavaExpression ')'
        
        TypeOrIdentifier := FullyQualifiedName ('[' ']')* | Identifier
        Identifier := JavaIdentifierChar+
        
        FormalsOrIdentifiersPattern :=
                          '..' (',' FormalsOrIdentifiersPatternAfterDotDot)? |
		                  TypeOrIdentifier (',' FormalsOrIdentifiersPattern)* |
		                  '*' (',' FormalsOrIdentifiersPattern)* 
		                  
        FormalsOrIdentifiersPatternAfterDotDot := 
		                  TypeOrIdentifier (',' FormalsOrIdentifiersPatternAfterDotDot)* |
		                  '*' (',' FormalsOrIdentifiersPatternAfterDotDot)*
        
        AtAnnotation := '@annotation' '(' AnnotationOrIdentifier ')'
        AtThis := '@this' '(' AnnotationOrIdentifer ')'
        AtTarget := '@target' '(' AnnotationOrIdentifier ')'
        AtWithin := '@within' '(' AnnotationOrIdentifier ')'
        AtWithinCode := '@withincode' '(' AnnotationOrIdentifier ')'        
        
        AnnotationOrIdentifier := '@' FullyQualifiedName | Identifier
        
        AtArgs := '@args' '(' AnnotationsOrIdentifiersPattern ')'
        
        AnnotationsOrIdentifiersPattern :=
                          '..' (',' AnnotationsOrIdentifiersPatternAfterDotDot)? |
                          AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPattern)* |
                          '*' (',' AnnotationsOrIdentifiersPattern)*
		                  
        AnnotationsOrIdentifiersPatternAfterDotDot := 
		                  AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPatternAfterDotDot)* |
		                  '*' (',' AnnotationsOrIdentifiersPatternAfterDotDot)*
        
        PointcutDeclaration := PointcutModifiers? 'pointcut' Identifier Formals
                               ':' PointcutExpression
                               
        PointcutModifiers := PointcutModifier*
        
        PointcutModifier :=  'public' | 'private' | 'protected' | 'abstract'
        
        Formals := '(' ParamList? ')'        
        ParamList := FullyQualifiedName Identifier (',' ParamList)*
        
        ReferencePointcut := (FullyQualifiedName '.')? Identifier Formals
        
        PointcutExpression := (PointcutPrimitive | ReferencePointcut) |
                              '!' PointcutExpression |
                              '(' PointcutExpression ')' |
                              PointcutExpression '&amp;&amp;' PointcutExpression |
                              PointcutExpression '||' PointcutExpression 
        
        === Advice ===
        
        to be written...
        
        === Inter-type Declarations ===
        
        to be written...
        
        === Declare Statements ===
        
        to be written...
        
        === Aspects ===
        
        to be written...
        
      </pre></div></div></body></html>
